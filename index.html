<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Dazzling</title>
    <style>
        /* 移动端基础样式 */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* 防止底部输入框滚动 */
        }
        
        /* App容器 */
        #app-container {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* 顶部导航栏 (Header) 
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED; // 仿微信深色顶部 
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            flex-shrink: 0;
        }*/
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED;
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            
            /* --- 关键修改 --- */
            position: sticky;  /* 粘性定位 */
            top: 0;            /* 粘在顶部 */
            z-index: 1000;     /* 保证在最上层 */
            width: 100%;       /* 占满容器宽度 */
            box-sizing: border-box;
            flex-shrink: 0;    /* 防止在 flex 布局中被压缩 */
        }
        .header-title {
            flex-grow: 1;
            text-align: center;
        }

        .header button {
            background: none;
            border: none;
            color: #333;
            font-size: 22px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            min-width: 40px; /* 增加点击区域 */
            text-align: center;
        }
        
        /* 返回按钮特殊样式 */
        .header button svg {
            vertical-align: middle;
        }

        /* 底部导航栏 (Footer for tab switching)
        .footer-nav {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            border-top: 1px solid #ccc;
            background-color: #f7f7f7;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            padding: 5px;
            color: #999;
        }

        .nav-item.active {
            color: #1AAD19; ///微信绿色 
            font-weight: 500;
        } /*
        
        /* 主内容区域 (Content Area) */
        .content {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            min-height: 0;  /* 重要！让 flex-grow 在 overflow 容器中正常工作 */
            box-sizing: border-box;
        }

        /* 聊天界面 */
        #chat-container {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 150px; /* 增加底部padding以防被输入区域遮挡(考虑引用预览的高度) */
        }

        .message {
            display: flex;
            flex-direction: row; /* 横向布局:头像和内容左右排列 */
            margin-bottom: 5px;
            gap: 8px;
        }

        .message.user {
            justify-content: flex-end; /* 用户消息右对齐 */
        }

        .message.assistant {
            justify-content: flex-start; /* AI消息左对齐 */
        }
        
        /* 用户消息:头像在右侧 */
        .message.user {
            flex-direction: row-reverse;
        }

        .bubble {
            max-width: 100%; /* 改为100%，由contentWrapper控制最大宽度 */
            width: fit-content; /* 自适应内容宽度 */
            padding: 8px 12px; /* 调整为微信的padding */
            padding-bottom: 20px; /* 为时间戳留出空间 */
            border-radius: 6px; /* 微信的圆角 */
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .message.user .bubble {
            background-color: #95EC69; /* 微信用户气泡颜色 */
            color: #000;
            border-top-right-radius: 0; /* 右上角尖角 */
        }

        .message.assistant .bubble {
            background-color: #fff; /* AI气泡颜色 */
            color: #000;
            border-top-left-radius: 0; /* 左上角尖角 */
            border: 1px solid #e5e5e5; /* 微信的边框颜色 */
        }
        
        /* 消息内容包装器（包含引用和气泡） */
        .message-content-wrapper {
            display: flex;
            flex-direction: column;
            max-width: 75%;
            width: fit-content; /* 自适应内容宽度 */
        }
        
        /* AI消息：内容左对齐（紧贴左侧头像） */
        .message.assistant .message-content-wrapper {
            align-items: flex-start;
        }
        
        /* 用户消息：内容右对齐（紧贴右侧头像） */
        .message.user .message-content-wrapper {
            align-items: flex-end;
        }
        
        /* WhatsApp风格的时间戳和状态 */
        .message-meta {
            position: absolute;
            bottom: 3px;
            right: 8px;
            font-size: 11px;
            color: #667781;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .message.user .message-meta {
            color: #667781;
        }
        
        /* 对勾样式 */
        .checkmark {
            display: inline-block;
            font-size: 14px;
            color: #667781;
        }
        
        .checkmark.double {
            color: #53bdeb; /* 蓝色表示已读/已送达 */
        }
        
        /* 正在输入指示器 (仿微信，黑色) */
        .typing-indicator {
            color: #333;
            font-size: 18px;
        }
        .page {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        .page.active {
            display: flex;
            height: 100vh;
        }

        /* 聊天输入区 */
        .chat-input-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #f7f7f7;
            padding: 5px 6px; /* 进一步减小padding */
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 3px; /* 最小间距 */
            border-top: 1px solid #dcdcdc;
            box-shadow: 0 -1px 3px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }
        
        /* 引用预览占满一行 */
        .chat-input-area .quote-reference {
            width: 100%;
            order: 999; /* 确保在最后面（输入框下方） */
            margin: 6px 0 0 0; /* 在输入框下方留间距 */
        }
        
        .input-tool-btn {
            background: none;
            border: none;
            padding: 4px; /* 最小padding */
            cursor: pointer;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: background-color 0.2s;
            flex-shrink: 0;
            width: 32px;
            height: 32px;
        }
        
        .input-tool-btn svg {
            width: 20px;
            height: 20px;
        }
        
        .input-tool-btn:hover {
            background-color: #e0e0e0;
        }
        
        .input-tool-btn:active {
            background-color: #d0d0d0;
        }

        #user-input {
            flex: 1 1 auto;
            min-width: 80px; /* 进一步减小最小宽度 */
            padding: 6px 8px; /* 减小padding */
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 15px;
            resize: none;
            max-height: 80px;
            overflow-y: auto;
            background-color: white;
            line-height: 1.4;
        }
        
        /* 设置界面 */
        #settings-page {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 14px;
        }

        #save-settings-btn {
            width: 100%;
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }

        /* 桌面与图标样式 */
        .home-page .wallpaper {
            background: linear-gradient(180deg,#cce8d7 0%, #67c77f 100%);
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
        }

        .desktop {
            width: 100%;
            max-width: 420px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns per row, 4 rows total */
            grid-auto-rows: 120px; /* fixed row height to ensure 4 visible rows */
            gap: 18px;
            padding: 20px;
            box-sizing: border-box;
            justify-items: center;
            align-content: start;
        }

        .desktop-slot {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-icon {
            width: 64px;
            height: 64px;
            background: rgba(255,255,255,0.12);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            user-select: none;
        }

        .app-label {
            margin-top: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.95);
            text-align: center;
            width: 84px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* 固定 Dock 栏 (底部) */
        .dock {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 50px; /* 在页面底部上方，和现有 footer-nav 留出空间 */
            display: flex;
            justify-content: center;
            pointer-events: none; /* 让内部项目控制点击 */
        }

        .dock-inner {
            background: rgba(255,255,255,0.12);
            padding: 8px 18px;
            border-radius: 16px;
            display: flex;
            gap: 18px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.15);
            pointer-events: auto;
        }

        .dock-item {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(255,255,255,0.14);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dock item press / dragging styles - animations removed for clarity */
        .dock-item {
            will-change: auto;
        }

        .dock-item.dragging {
            opacity: 0.5;
        }

        .app-icon.dragging {
            opacity: 0.5;
        }

        /* 隐藏和显示页面 */
        .page {
            display: none;
            height: 100%;
            width: 100%;
        }

        .page.active {
            display: flex;
            flex-direction: column;
        }
        
        /* ========== 头像样式 ========== */
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            flex-shrink: 0;
        }
        
        .message.user {
            flex-direction: row;
        }
        
        .message.assistant {
            flex-direction: row;
        }
        
        .message.user .message-avatar {
            order: 2;
            margin-left: 8px;
        }
        
        .message.assistant .message-avatar {
            order: 0;
            margin-right: 8px;
        }
        
        .message.user .bubble {
            order: 1;
        }
        
        .message.assistant .bubble {
            order: 1;
        }
        
        .default-avatar {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            color: white;
            border-radius: 6px;
        }
        
        .default-avatar.ai {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .default-avatar.user {
            background: linear-gradient(135deg, #07c160 0%, #06ae56 100%);
        }
        
        .avatar-preview-container {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 8px;
        }
        
        .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid #e7e7e7;
            flex-shrink: 0;
        }
        
        .avatar-preview.small {
            width: 60px;
            height: 60px;
        }
        
        .avatar-upload-btn {
            padding: 8px 16px;
            background: #07c160;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .avatar-upload-btn:active {
            opacity: 0.8;
        }
        
        .avatar-remove-btn {
            padding: 8px 16px;
            background: #f44336;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .avatar-remove-btn:active {
            opacity: 0.8;
        }
        
        /* ========== 底部导航栏 ========== */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background-color: #f7f7f7;
            border-top: 1px solid #d9d9d9;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }
        
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #999;
            font-size: 11px;
            gap: 2px;
            padding: 4px 0;
            transition: color 0.2s;
            user-select: none;
        }
        
        .nav-item svg {
            width: 24px;
            height: 24px;
            stroke: currentColor;
        }
        
        .nav-item.active {
            color: #07c160; /* 微信绿 */
        }
        
        .nav-item.active svg {
            stroke: #07c160;
        }
        
        /* 为底部导航留出空间 */
        .page-with-nav .content {
            padding-bottom: 50px;
        }
        
        /* ========== 全局消息通知横幅 ========== */
        .message-notification {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 16px;
            display: none;
            align-items: center;
            gap: 12px;
            z-index: 10000;
            animation: slideDown 0.3s ease-out;
            cursor: pointer;
            user-select: none;
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(0);
                opacity: 1;
            }
            to {
                transform: translateY(-100%);
                opacity: 0;
            }
        }
        
        .message-notification.show {
            display: flex;
        }
        
        .message-notification.hiding {
            animation: slideUp 0.3s ease-out;
        }
        
        .message-notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            flex-shrink: 0;
            object-fit: cover;
        }
        
        .message-notification-content {
            flex: 1;
            min-width: 0;
        }
        
        .message-notification-name {
            font-size: 14px;
            font-weight: 500;
            color: white;
            margin-bottom: 2px;
        }
        
        .message-notification-text {
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .message-notification-close {
            width: 20px;
            height: 20px;
            color: rgba(255, 255, 255, 0.6);
            flex-shrink: 0;
            font-size: 20px;
            line-height: 1;
        }
        
        /* ========== 配置提醒对话框 ========== */
        .config-reminder-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }
        
        .config-reminder-dialog.show {
            display: flex;
        }
        
        .config-reminder-content {
            background: white;
            border-radius: 12px;
            width: 85%;
            max-width: 360px;
            padding: 24px;
            text-align: center;
        }
        
        .config-reminder-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
        
        .config-reminder-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
        }
        
        .config-reminder-message {
            font-size: 14px;
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }
        
        .config-reminder-buttons {
            display: flex;
            gap: 12px;
        }
        
        .config-reminder-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 15px;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .config-reminder-btn:active {
            opacity: 0.7;
        }
        
        .config-reminder-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .config-reminder-btn.primary {
            background: #07c160;
            color: white;
        }
        
        /* ========== 聊天列表样式 ========== */
        .character-list-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #e7e7e7;
            cursor: pointer;
            background: #fff;
        }
        .character-list-item:active {
            background-color: #ececec;
        }
        .character-list-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            margin-right: 12px;
            flex-shrink: 0;
        }
        .character-list-info {
            flex: 1;
            min-width: 0;
        }
        .character-list-name {
            font-size: 16px;
            font-weight: 500;
            color: #000;
            margin-bottom: 4px;
        }
        .character-list-preview {
            font-size: 14px;
            color: #999;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .character-add-menu {
            position: fixed;
            top: 50px;
            right: 10px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 9999;
            min-width: 140px;
            display: none;
        }
        .character-add-menu.active {
            display: block;
        }
        .character-add-menu-item {
            padding: 14px 20px;
            border-bottom: 1px solid #e7e7e7;
            cursor: pointer;
            font-size: 15px;
            color: #000;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .character-add-menu-item:last-child {
            border-bottom: none;
        }
        .character-add-menu-item:active {
            background-color: #ececec;
        }
        .character-new-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }
        .character-new-modal.active {
            display: flex;
        }
        .character-new-modal-content {
            background: white;
            border-radius: 12px;
            width: 85%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
        }
        .character-new-modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e7e7e7;
            font-size: 17px;
            font-weight: 500;
            text-align: center;
        }
        .character-new-modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: 60vh;
        }
        .character-new-modal-footer {
            padding: 12px 20px;
            border-top: 1px solid #e7e7e7;
            display: flex;
            gap: 12px;
        }
        .character-new-modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
        }
        .character-new-modal-btn.cancel {
            background: #f0f0f0;
            color: #333;
        }
        .character-new-modal-btn.confirm {
            background: #07c160;
            color: white;
        }
        .character-empty-list {
            text-align: center;
            padding: 80px 20px;
            color: #999;
        }
        
        /* ========== 长按菜单样式 ========== */
        .bubble-menu {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 10px;
            z-index: 10000;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            min-width: 270px;
            max-width: 90vw; /* 限制最大宽度为屏幕宽度的90% */
        }
        
        .bubble-menu.active {
            display: grid;
        }
        
        .bubble-menu-item {
            padding: 12px 8px;
            cursor: pointer;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
            border-radius: 8px;
            background: #f7f7f7;
            text-align: center;
            min-width: 0; /* 允许内容收缩 */
        }
        
        .bubble-menu-item:hover {
            background: #e8e8e8;
        }
        
        .bubble-menu-item:active {
            background: #d8d8d8;
        }
        
        .bubble-menu-item.danger {
            color: #ff3b30;
        }
        
        .bubble-menu-item .icon {
            font-size: 20px;
        }
        
        /* 遮罩层 */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            z-index: 9999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* 气泡选中状态 */
        .bubble.menu-active {
            background: rgba(0,0,0,0.05);
        }
        
        /* ========== 多选模式样式（完全仿微信）========== */
        
        /* 多选模式激活时的聊天容器调整 */
        .multi-select-mode-active #chat-container {
            padding-left: 0; /* 移除padding */
            padding-bottom: 80px; /* 为底部工具栏留出空间 */
        }
        
        /* 多选模式下的消息整体右移 */
        .multi-select-mode-active .message {
            margin-left: 55px; /* 整体右移，为复选框留空间 */
        }
        
        /* 多选模式下隐藏输入框 */
        .multi-select-mode-active .chat-input-area {
            display: none !important;
        }
        
        /* 消息容器需要相对定位 */
        .message {
            position: relative;
        }
        
        /* 多选模式下消息整体右移，避免与复选框重叠 */
        .multi-select-mode-active .message {
            margin-left: 40px; /* 向右移动，为复选框留出空间 */
        }
        
        /* 复选框容器 - 默认隐藏 */
        .multi-select-checkbox {
            position: absolute;
            left: -32px; /* 负值，使复选框显示在消息左侧 */
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            border: 1.5px solid #c8c8c8;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: none; /* 默认隐藏 */
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: all 0.15s;
        }
        
        /* 多选模式激活时显示复选框 */
        .multi-select-mode-active .multi-select-checkbox {
            display: flex !important; /* 强制显示 */
        }
        
        /* 选中状态的复选框 */
        .multi-select-checkbox.checked {
            background: #07c160;
            border-color: #07c160;
        }
        
        /* 选中状态的勾号 - 使用CSS绘制 */
        .multi-select-checkbox.checked::after {
            content: '';
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 1.5px 1.5px 0;
            transform: rotate(45deg);
            margin-bottom: 2px;
        }
        
        /* 多选模式顶部工具栏 */
        .multi-select-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 44px;
            background: #EDEDED;
            border-bottom: 0.5px solid #d9d9d9;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px;
            z-index: 2001;
        }
        
        .multi-select-header.active {
            display: flex;
        }
        
        .multi-select-header-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .multi-select-cancel-btn {
            font-size: 17px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }
        
        .multi-select-cancel-btn:active {
            opacity: 0.6;
        }
        
        .multi-select-count {
            font-size: 17px;
            color: #000;
        }
        
        .multi-select-select-all-btn {
            font-size: 17px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
        }
        
        .multi-select-select-all-btn:active {
            opacity: 0.6;
        }
        
        /* 搜索框 */
        .multi-select-search {
            position: fixed;
            top: 44px;
            left: 0;
            right: 0;
            background: #EDEDED;
            padding: 8px 12px;
            z-index: 2000;
            display: none;
        }
        
        .multi-select-search.active {
            display: block;
        }
        
        .multi-select-search-input {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: #fff;
            font-size: 15px;
            box-sizing: border-box;
            outline: none;
        }
        
        /* Select按钮 */
        .multi-select-btn-container {
            position: fixed;
            top: 104px;
            left: 16px;
            z-index: 2000;
            display: none;
        }
        
        .multi-select-btn-container.active {
            display: block;
        }
        
        .multi-select-select-btn {
            background: white;
            border: 1px solid #d9d9d9;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 14px;
            color: #576b95;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .multi-select-select-btn:active {
            background: #f0f0f0;
        }
        
        /* 多选模式下聊天容器需要留出顶部空间 */
        .multi-select-mode-active #chat-page .content {
            padding-top: 104px; /* 为顶部工具栏和搜索框留空间 */
        }
        
        /* 底部操作栏（完全仿微信 - 图标版）*/
        .multi-select-toolbar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #F7F7F7;
            border-top: 0.5px solid #d9d9d9;
            display: none;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            z-index: 2000;
            padding: 0 20px;
        }
        
        .multi-select-toolbar.active {
            display: flex;
        }
        
        .multi-select-toolbar-btn {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 26px;
            color: #000;
            transition: opacity 0.2s;
            gap: 2px;
        }
        
        .multi-select-toolbar-btn:active {
            opacity: 0.5;
        }
        
        .multi-select-toolbar-btn.disabled {
            opacity: 0.3;
            pointer-events: none;
        }
        
        .multi-select-toolbar-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 2px;
        }
        
        .multi-select-toolbar-text {
            font-size: 10px;
            color: #000;
            line-height: 1;
        }
        
        /* ========== 收藏页面样式 ========== */
        .favorite-item {
            background: white;
            margin-bottom: 10px;
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .favorite-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .favorite-sender {
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }
        
        .favorite-time {
            font-size: 12px;
            color: #999;
        }
        
        .favorite-content {
            font-size: 15px;
            color: #333;
            line-height: 1.5;
            word-wrap: break-word;
        }
        
        .favorite-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #f0f0f0;
        }
        
        .favorite-action-btn {
            font-size: 13px;
            color: #576b95;
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
        }
        
        .favorite-action-btn:hover {
            opacity: 0.7;
        }
        
        .favorite-action-btn.delete {
            color: #ff3b30;
        }
        
        /* ========== 转发选择列表样式 ========== */
        .forward-character-item {
            background: white;
            display: flex;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid #EDEDED;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .forward-character-item:hover {
            background: #f5f5f5;
        }
        
        .forward-character-item:active {
            background: #e8e8e8;
        }
        
        .forward-character-avatar {
            width: 48px;
            height: 48px;
            border-radius: 6px;
            margin-right: 12px;
            flex-shrink: 0;
        }
        
        .forward-character-info {
            flex: 1;
            min-width: 0;
        }
        
        .forward-character-name {
            font-size: 16px;
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }
        
        .forward-character-desc {
            font-size: 13px;
            color: #999;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 批量生成对话框 */
        .batch-generate-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10004;
        }
        
        .batch-generate-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .batch-generate-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .batch-generate-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .batch-generate-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .batch-generate-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .batch-generate-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .batch-generate-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 单选按钮样式增强 */
        input[type="radio"]:checked + div {
            color: #4CAF50;
        }
        
        label:has(input[type="radio"]:checked) {
            border-color: #4CAF50 !important;
            background-color: #f1f8f4;
        }
        
        /* 导入和批量生成模式选择对话框的按钮悬停效果 */
        #import-mode-dialog button:not(.batch-generate-close):hover,
        #batch-mode-dialog button:not(.batch-generate-close):hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        #import-mode-dialog button:not(.batch-generate-close):active,
        #batch-mode-dialog button:not(.batch-generate-close):active {
            transform: translateY(0);
        }
        
        /* 导入记忆对话框 */
        .import-memory-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10005;
        }
        
        .import-memory-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 550px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .import-memory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .import-memory-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .import-memory-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .import-memory-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .import-memory-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .import-memory-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 记忆编辑模态窗口 */
        .memory-edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10003;
        }
        
        .memory-edit-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .memory-edit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .memory-edit-header h3 {
            margin: 0;
            font-size: 18px;
            color: #333;
        }
        
        .memory-edit-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #999;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }
        
        .memory-edit-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        
        .memory-edit-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        
        .memory-section {
            margin-bottom: 24px;
        }
        
        .memory-section h4 {
            margin: 0 0 12px 0;
            font-size: 16px;
            color: #555;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 6px;
        }
        
        .memory-section textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        .basic-info-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }
        
        .basic-info-item label {
            min-width: 80px;
            font-size: 14px;
            color: #666;
        }
        
        .basic-info-item input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .event-item {
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        
        .event-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .event-item-date {
            font-size: 12px;
            color: #999;
        }
        
        .event-item-importance {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .event-item-importance label {
            font-size: 12px;
            color: #666;
        }
        
        .event-item-importance input {
            width: 60px;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .event-item-delete {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .event-item textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        .memory-edit-footer {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            border-top: 1px solid #e0e0e0;
            justify-content: flex-end;
        }
        
        /* 确认对话框 */
        .confirm-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 12px;
            padding: 0;
            max-width: 280px;
            width: 85%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 10002;
            display: none;
            overflow: hidden;
        }
        
        .confirm-dialog.active {
            display: block;
        }
        
        .confirm-dialog-title {
            font-size: 17px;
            font-weight: 500;
            padding: 20px 20px 0 20px;
            color: #000;
            text-align: center;
        }
        
        .confirm-dialog-message {
            font-size: 14px;
            color: #666;
            padding: 12px 20px 20px 20px;
            line-height: 1.6;
            text-align: center;
        }
        
        .confirm-dialog-buttons {
            display: flex;
            flex-direction: column;
            border-top: 0.5px solid #e0e0e0;
        }
        
        .confirm-dialog-button {
            width: 100%;
            padding: 14px 16px;
            border: none;
            border-bottom: 0.5px solid #e0e0e0;
            background: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
        }
        
        .confirm-dialog-button:last-child {
            border-bottom: none;
        }
        
        .confirm-dialog-button:active {
            background: #f5f5f5;
        }
        
        .confirm-dialog-button.primary {
            color: #576b95;
            font-weight: 500;
        }
        
        .confirm-dialog-button.secondary {
            color: #576b95;
        }
        
        .confirm-dialog-button.cancel {
            color: #000;
        }
        
        /* ========== 编辑模式样式 ========== */
        .bubble.editing {
            background: #fff3cd !important;
            border: 2px solid #ffc107 !important;
            position: relative;
        }
        
        .edit-textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 15px;
            font-family: inherit;
            line-height: 1.4;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        
        .edit-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        
        .edit-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .edit-btn.save {
            background: #1AAD19;
            color: white;
        }
        
        .edit-btn.save:hover {
            background: #178f15;
        }
        
        .edit-btn.cancel {
            background: #f0f0f0;
            color: #333;
        }
        
        .edit-btn.cancel:hover {
            background: #e0e0e0;
        }
        
        /* ========== 引用样式 ========== */
        /* 输入框下方的引用预览 (微信风格) */
        .quote-reference {
            background: #e0e0e0; /* 更深的灰色背景 */
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px; /* 小字 */
            color: #666; /* 深一点的文字颜色 */
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px; /* 在输入框下方留间距 */
        }
        
        .quote-reference .quote-content {
            flex-grow: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* 单行显示 */
            line-height: 1.4;
        }
        
        .quote-reference .quote-close {
            flex-shrink: 0;
            cursor: pointer;
            font-size: 20px;
            color: #666;
            line-height: 1;
            padding: 0 4px;
            font-weight: bold;
        }
        
        .quote-reference .quote-close:hover {
            color: #333;
        }
        
        /* 消息气泡内的引用样式 (微信风格) */
        .quoted-message {
            background: rgba(0, 0, 0, 0.05); /* 略深的半透明背景 */
            padding: 6px 8px;
            margin-top: 8px; /* 在正文下方留间距 */
            margin-bottom: 0;
            border-radius: 4px;
            font-size: 11px;
            color: #999; /* 灰色 */
            line-height: 1.3;
            width: fit-content;
            max-width: 100%;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* 单行显示 */
            order: 10; /* 确保在气泡后面 */
        }
        
        .quoted-message .quote-sender {
            font-weight: normal;
            color: #999;
            margin-right: 0;
        }
        
        /* 用户和AI的引用样式统一 */
        .message.user .quoted-message,
        .message.assistant .quoted-message {
            background: rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body>

    <!-- 全局消息通知横幅 -->
    <div class="message-notification" id="message-notification">
        <div class="message-notification-avatar" id="notification-avatar">
            <div class="default-avatar ai" style="width: 40px; height: 40px; border-radius: 6px;">AI</div>
        </div>
        <div class="message-notification-content">
            <div class="message-notification-name" id="notification-name">AI 聊天对象</div>
            <div class="message-notification-text" id="notification-text">新消息</div>
        </div>
        <div class="message-notification-close">×</div>
    </div>
    
    <!-- 配置缺失提醒对话框 -->
    <div class="config-reminder-dialog" id="config-reminder-dialog">
        <div class="config-reminder-content">
            <div class="config-reminder-icon">⚙️</div>
            <div class="config-reminder-title">需要配置 API</div>
            <div class="config-reminder-message">
                检测到 API 配置缺失，无法发送消息。<br>
                请先在设置中配置 API Base URL、API Key 和 Model Name。
            </div>
            <div class="config-reminder-buttons">
                <button class="config-reminder-btn secondary" onclick="closeConfigReminder()">稍后</button>
                <button class="config-reminder-btn primary" onclick="goToSettings()">去设置</button>
            </div>
        </div>
    </div>

    <div id="app-container" style="height: 100%;">
        
        <div id="home-page" class="page active">
            <header class="header">
                <span></span>
            </header>
            <div class="content home-page">
                <div class="wallpaper" style="width:100%">
                    <div class="desktop" id="desktop-grid">
                    </div>
                </div>

                <div class="dock">
                    <div class="dock-inner">
                    </div>
                </div>
            </div>
        </div>

        <!-- ==================== 系统设置页面 ==================== -->
        <div id="system-settings-page" class="page">
            <header class="header">
                <button onclick="showPage('home-page')">‹</button>
                <span class="header-title">系统设置</span>
                <span></span>
            </header>
            
            <div class="content" style="padding: 20px; background-color: #f5f5f5;">
                <div style="background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <h2 style="margin: 0 0 10px 0; font-size: 18px; color: #333;">📦 数据管理</h2>
                    <p style="font-size: 14px; color: #666; margin: 0 0 20px 0;">
                        导出或导入所有数据，包括所有角色的聊天记录、配置和长期记忆。
                    </p>
                    
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <button onclick="exportAllData()" style="padding: 14px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500;">
                            💾 导出所有数据
                        </button>
                        
                        <button onclick="document.getElementById('import-all-data-input').click()" style="padding: 14px; background-color: #2196F3; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: 500;">
                            📥 导入所有数据
                        </button>
                        <input type="file" id="import-all-data-input" accept=".json" style="display: none;" onchange="importAllData(this)">
                    </div>
                    
                    <div style="margin-top: 16px; padding: 12px; background: #e3f2fd; border-radius: 8px; border-left: 4px solid #2196F3;">
                        <p style="margin: 0; font-size: 13px; color: #1565C0;">
                            💡 <strong>提示：</strong>导出的数据包含所有角色、聊天记录、配置和记忆。导入时会完全替换当前所有数据。
                        </p>
                    </div>
                </div>
                
                <div style="background: #fff3cd; border-radius: 12px; padding: 20px; border-left: 4px solid #ffc107;">
                    <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #856404;">⚠️ 注意事项</h3>
                    <ul style="margin: 0; padding-left: 20px; font-size: 14px; color: #856404; line-height: 1.8;">
                        <li>导入数据会<strong>完全替换</strong>当前所有数据</li>
                        <li>建议在导入前先导出备份当前数据</li>
                        <li>导入后页面会自动刷新</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ==================== 聊天列表页面 ==================== -->
        <div id="chat-list-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">微信</span>
                <button id="add-character-menu-btn" style="font-size: 26px;">+</button>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="background-color: #EDEDED; padding: 8px 12px; border-bottom: 1px solid #d9d9d9;">
                    <div style="background-color: #fff; border-radius: 6px; padding: 6px 12px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
                            <circle cx="8" cy="8" r="6.5" stroke="#999" stroke-width="1.5"/>
                            <path d="M13 13L17 17" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <input type="text" placeholder="搜索" id="character-search-input" style="border: none; outline: none; flex: 1; font-size: 14px; background: transparent;">
                    </div>
                </div>
                
                <div id="characters-list-container"></div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item active" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 通讯录页面 -->
        <div id="contacts-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">通讯录</span>
                <button style="font-size: 26px;">+</button>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="padding: 100px 20px; text-align: center; color: #999;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 16px;">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <div style="font-size: 16px; margin-bottom: 8px;">通讯录功能</div>
                    <div style="font-size: 14px;">敬请期待...</div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item active" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 发现页面 -->
        <div id="discover-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">发现</span>
                <span></span>
            </header>
            
            <div class="content" style="background-color: #fff;">
                <div style="padding: 100px 20px; text-align: center; color: #999;">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="#ccc" stroke-width="1.5" style="margin: 0 auto 16px;">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="#ccc"/>
                    </svg>
                    <div style="font-size: 16px; margin-bottom: 8px;">发现功能</div>
                    <div style="font-size: 14px;">敬请期待...</div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item active" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>
        
        <!-- 我的页面 -->
        <div id="me-page" class="page page-with-nav">
            <header class="header">
                <button onclick="showPage('home-page')">
                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M15 18l-6-6 6-6"/>
                    </svg>
                </button>
                <span class="header-title">我</span>
                <span></span>
            </header>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <!-- 个人信息卡片 -->
                <div style="background: white; margin-bottom: 10px; padding: 20px 16px;">
                    <div style="display: flex; align-items: center; gap: 16px;">
                        <div id="me-page-avatar" style="width: 64px; height: 64px; border-radius: 6px; background: #07c160; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">我</div>
                        <div style="flex: 1;">
                            <div id="me-page-nickname" style="font-size: 20px; font-weight: 500; color: #333; margin-bottom: 4px;">用户昵称</div>
                            <div style="font-size: 14px; color: #999;">微信号: dazzling_user</div>
                        </div>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                            <path d="M9 18l6-6-6-6"/>
                        </svg>
                    </div>
                </div>
                
                <!-- 功能列表 -->
                <div style="background: white; margin-bottom: 10px;">
                    <!-- 收藏 -->
                    <div onclick="showFavoritesPage()" style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; cursor: pointer;">
                        <div style="width: 40px; height: 40px; background: #ffc107; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">⭐</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">收藏</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span id="favorites-count" style="font-size: 14px; color: #999;">0</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- 相册（占位） -->
                    <div style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #5a9fe2; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">📷</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">相册</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                </div>
                
                <!-- 其他功能 -->
                <div style="background: white; margin-bottom: 10px;">
                    <div style="display: flex; align-items: center; padding: 14px 16px; border-bottom: 1px solid #EDEDED; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #ff9800; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">💳</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">卡包</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: center; padding: 14px 16px; opacity: 0.5;">
                        <div style="width: 40px; height: 40px; background: #4caf50; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">😊</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">表情</div>
                        <div style="display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 12px; color: #999;">开发中</span>
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                                <path d="M9 18l6-6-6-6"/>
                            </svg>
                        </div>
                    </div>
                </div>
                
                <!-- 设置 -->
                <div style="background: white;">
                    <div onclick="openSettings()" style="display: flex; align-items: center; padding: 14px 16px; cursor: pointer;">
                        <div style="width: 40px; height: 40px; background: #607d8b; border-radius: 6px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
                            <span style="font-size: 22px;">⚙️</span>
                        </div>
                        <div style="flex: 1; font-size: 16px; color: #333;">设置</div>
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#999" stroke-width="2">
                            <path d="M9 18l6-6-6-6"/>
                        </svg>
                    </div>
                </div>
            </div>
            
            <!-- 底部导航栏 -->
            <div class="bottom-nav">
                <div class="nav-item" data-page="chat-list">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"/>
                    </svg>
                    <span>微信</span>
                </div>
                <div class="nav-item" data-page="contacts">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                        <circle cx="9" cy="7" r="4"/>
                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                    </svg>
                    <span>通讯录</span>
                </div>
                <div class="nav-item" data-page="discover">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <circle cx="12" cy="12" r="10"/>
                        <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76" fill="currentColor"/>
                    </svg>
                    <span>发现</span>
                </div>
                <div class="nav-item active" data-page="me">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                        <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                        <circle cx="12" cy="7" r="4"/>
                    </svg>
                    <span>我</span>
                </div>
            </div>
        </div>

        <!-- 收藏页面 -->
        <div id="favorites-page" class="page">
            <header class="header">
                <button onclick="showPage('me-page')">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">收藏</span>
                <button onclick="clearAllFavorites()" style="font-size: 14px; color: #ff3b30;">清空</button>
            </header>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <div id="favorites-container"></div>
                
                <!-- 空状态 -->
                <div id="favorites-empty" style="display: none; padding: 100px 20px; text-align: center; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 16px;">⭐</div>
                    <div style="font-size: 16px; margin-bottom: 8px;">暂无收藏</div>
                    <div style="font-size: 14px;">长按消息可添加到收藏</div>
                </div>
            </div>
        </div>
        
        <!-- 转发选择页面 -->
        <div id="forward-select-page" class="page">
            <header class="header">
                <button onclick="cancelForward()">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">选择聊天</span>
                <span></span>
            </header>
            
            <div class="content" style="background-color: #EDEDED; overflow-y: auto;">
                <!-- 搜索框 -->
                <div style="background-color: #EDEDED; padding: 8px 12px; border-bottom: 1px solid #d9d9d9;">
                    <div style="background-color: #fff; border-radius: 6px; padding: 6px 12px; display: flex; align-items: center; gap: 8px;">
                        <svg width="18" height="18" viewBox="0 0 18 18" fill="none">
                            <circle cx="8" cy="8" r="6.5" stroke="#999" stroke-width="1.5"/>
                            <path d="M13 13L17 17" stroke="#999" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                        <input type="text" placeholder="搜索" id="forward-search-input" style="border: none; outline: none; flex: 1; font-size: 14px; background: transparent;">
                    </div>
                </div>
                
                <div id="forward-characters-list"></div>
                
                <!-- 空状态 -->
                <div id="forward-empty" style="display: none; padding: 100px 20px; text-align: center; color: #999;">
                    <div style="font-size: 48px; margin-bottom: 16px;">💬</div>
                    <div style="font-size: 16px; margin-bottom: 8px;">暂无可转发的对象</div>
                    <div style="font-size: 14px;">请先创建角色</div>
                </div>
            </div>
        </div>

        <div id="chat-page" class="page">
            <header class="header">
                <button id="back-to-chat-list-btn">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title" id="chat-name">AI 聊天对象</span>
                <button onclick="openSettings()">
                    <svg width="20" height="4" viewBox="0 0 20 4" fill="currentColor">
                        <circle cx="2" cy="2" r="2"/>
                        <circle cx="10" cy="2" r="2"/>
                        <circle cx="18" cy="2" r="2"/>
                    </svg>
                </button>
            </header>
            
            <div class="content">
                <div id="chat-container">
                    <div class="message ai">
                        <div class="bubble">你好！有什么想跟我聊聊的吗？我很期待。</div>
                    </div>
                </div>
            </div>

            <div class="chat-input-area" id="chat-input-area">
                <button class="input-tool-btn" id="voice-btn" title="语音输入（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="23"></line>
                        <line x1="8" y1="23" x2="16" y2="23"></line>
                    </svg>
                </button>
                <textarea id="user-input" placeholder="输入消息..." rows="1"></textarea>
                <button class="input-tool-btn" id="emoji-btn" title="表情包（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                        <line x1="9" y1="9" x2="9.01" y2="9"></line>
                        <line x1="15" y1="9" x2="15.01" y2="9"></line>
                    </svg>
                </button>
                <button class="input-tool-btn" id="plus-btn" title="更多功能（开发中）">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="12" y1="8" x2="12" y2="16"></line>
                        <line x1="8" y1="12" x2="16" y2="12"></line>
                    </svg>
                </button>
            </div>
            
            <!-- 多选模式顶部工具栏 -->
            <div class="multi-select-header" id="multi-select-header">
                <button class="multi-select-cancel-btn" onclick="exitMultiSelectMode()">取消</button>
                <span class="multi-select-count" id="multi-select-count">已选择0条</span>
                <span style="width: 40px;"></span>
            </div>
            
            <!-- 多选模式搜索框 -->
            <div class="multi-select-search" id="multi-select-search">
                <input type="text" class="multi-select-search-input" placeholder="搜索">
            </div>
            
            <!-- Select按钮 -->
            <div class="multi-select-btn-container" id="multi-select-btn-container">
                <button class="multi-select-select-btn" onclick="showToast('功能开发中')">
                    <span id="select-btn-icon" style="font-size: 18px; font-weight: 900; line-height: 1;">▼</span>
                    <span id="select-btn-text">选择</span>
                </button>
            </div>
            
            <!-- 多选模式底部工具栏 -->
            <div class="multi-select-toolbar" id="multi-select-toolbar">
                <button class="multi-select-toolbar-btn" onclick="confirmForwardType()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <polyline points="12 18 12 12"></polyline>
                            <polyline points="9 15 12 12 15 15"></polyline>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">转发</div>
                </button>
                <button class="multi-select-toolbar-btn" onclick="favoriteSelectedMessages()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"></path>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">收藏</div>
                </button>
                <button class="multi-select-toolbar-btn delete" onclick="deleteSelectedMessages()">
                    <div class="multi-select-toolbar-icon">
                        <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                    </div>
                    <div class="multi-select-toolbar-text">删除</div>
                </button>
                <button class="multi-select-toolbar-btn" onclick="showMoreMultiSelectOptions()">
                    <div class="multi-select-toolbar-icon" style="font-size: 24px; font-weight: bold; line-height: 1;">•••</div>
                    <div class="multi-select-toolbar-text">更多</div>
                </button>
            </div>
        </div>

        <div id="settings-page" class="page">
            <header class="header">
                <button onclick="closeSettings()">
                    <svg width="10" height="18" viewBox="0 0 10 18" fill="none">
                        <path d="M9 1L1 9L9 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                <span class="header-title">设置</span>
                <span></span> </header>
            <div class="content" style="padding: 20px; overflow-y: auto; flex-grow: 1;">
                <!-- 角色标识 -->
                <div style="background: #f5f5f5; padding: 12px 15px; border-radius: 8px; margin-bottom: 20px; border-left: 3px solid #1AAD19;">
                    <div style="font-size: 12px; color: #999; margin-bottom: 4px;">当前角色标识</div>
                    <div id="character-identifier" style="font-size: 15px; color: #333; font-weight: 500;">-</div>
                    <div style="font-size: 11px; color: #999; margin-top: 4px;">角色的唯一ID,用于区分不同角色</div>
                </div>
                
                <h3>API 配置 (OpenAI 兼容)</h3>
                
                <div class="form-group">
                    <label for="baseurl">Base URL (例如: https://api.openai.com/v1)</label>
                    <input type="text" id="baseurl" placeholder="API Base URL">
                </div>

                <div class="form-group">
                    <label for="apikey">API Key</label>
                    <input type="password" id="apikey" placeholder="您的 API Key">
                </div>

                <div class="form-group">
                    <label for="modelname">Model Name</label>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="modelname" style="flex: 1; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; background-color: white;">
                            <option value="">-- 请先拉取模型列表 --</option>
                        </select>
                        <button onclick="fetchModels()" style="padding: 10px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; font-size: 14px;">
                            🔄 拉取
                        </button>
                        <button onclick="testConnection()" style="padding: 10px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; white-space: nowrap; font-size: 14px;">
                            🔍 测试
                        </button>
                    </div>
                    <div id="model-fetch-status" style="font-size: 12px; margin-top: 6px; color: #666;"></div>
                </div>
                
                <h3>系统角色设置 </h3>
                
                <div class="form-group">
                    <label for="character-name-input">角色姓名</label>
                    <input type="text" id="character-name-input" placeholder="角色的真实姓名" readonly style="background-color: #f5f5f5; cursor: not-allowed;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">创建后不可更改,用于提醒你这是谁</div>
                </div>
                
                <div class="form-group">
                    <label for="user-nickname">我的昵称</label>
                    <input type="text" id="user-nickname" placeholder="您的昵称(显示在引用中)">
                </div>
                <div class="form-group">
                    <label for="chat-name-input">对方昵称</label>
                    <input type="text" id="chat-name-input" placeholder="聊天对象的昵称">
                </div>
                
                <!-- 头像设置 -->
                <div class="form-group">
                    <label>对方头像</label>
                    <div class="avatar-preview-container">
                        <div id="ai-avatar-preview-settings" class="avatar-preview">
                            <div class="default-avatar ai">AI</div>
                        </div>
                        <div>
                            <input type="file" id="ai-avatar-input-settings" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('ai-avatar-input-settings').click()">更换头像</button>
                            <button class="avatar-remove-btn" id="ai-avatar-remove-btn-settings" style="display: none;" onclick="removeAIAvatar()">移除头像</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB, PNG/JPG/GIF</div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>我的头像</label>
                    <div class="avatar-preview-container">
                        <div id="user-avatar-preview-settings" class="avatar-preview">
                            <div class="default-avatar user">我</div>
                        </div>
                        <div>
                            <input type="file" id="user-avatar-input-settings" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('user-avatar-input-settings').click()">更换头像</button>
                            <button class="avatar-remove-btn" id="user-avatar-remove-btn-settings" style="display: none;" onclick="removeUserAvatar()">移除头像</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB, PNG/JPG/GIF</div>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="system-prompt">系统指令 (AI 扮演的角色)</label>
                    <textarea id="system-prompt" rows="8"></textarea>
                </div>
                                
                <hr>
                <h3>AI 记忆设置</h3>
                <div style="margin-top: 15px;">
                    <label for="context-window-size" style="display: block; margin-bottom: 5px;">
                        发送给 AI 的最新聊天记录条数：
                    </label>
                    
                    <input 
                        type="number" 
                        id="context-window-size" 
                        value="50" 
                        min="5" 
                        max="200" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">条</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 条数越多，AI 记忆越完整，但调用 API 的成本和时间可能增加。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="batch-wait-time" style="display: block; margin-bottom: 5px;">
                        多条消息等待时间（秒）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="batch-wait-time" 
                        value="7" 
                        min="1" 
                        max="30" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">秒</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 发送消息后，如果在此时间内没有新消息，将自动发送给 AI。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="api-timeout" style="display: block; margin-bottom: 5px;">
                        API 超时时间（秒）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="api-timeout" 
                        value="60" 
                        min="10" 
                        max="300" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">秒</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * API 请求超过此时间未响应，将自动取消并重置状态。
                    </p>
                </div>
                
                <hr>
                <h3>长期记忆设置</h3>
                
                <h4 style="margin-bottom: 10px; color: #555;">自动总结设置</h4>
                <div style="margin-top: 15px;">
                    <label for="auto-summary-interval" style="display: block; margin-bottom: 5px;">
                        自动总结间隔（气泡数）：
                    </label>
                    
                    <input 
                        type="number" 
                        id="auto-summary-interval" 
                        value="50" 
                        min="10" 
                        max="200" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">个气泡</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 每积累此数量的新气泡，自动调用AI生成长期记忆总结。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="max-important-events" style="display: block; margin-bottom: 5px;">
                        保存重要事件数量：
                    </label>
                    
                    <input 
                        type="number" 
                        id="max-important-events" 
                        value="10" 
                        min="5" 
                        max="50" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">条</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * 只保留最重要的N条事件（按重要度评分排序）。
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="showBatchGenerateDialog()" style="padding: 10px 20px; background-color: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            🔄 批量生成记忆
                        </button>
                        <button onclick="generateMemorySummary(true)" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            🧠 立即生成（待总结）
                        </button>
                        <button onclick="editMemory()" style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            ✏️ 查看/编辑记忆
                        </button>
                        <button onclick="clearMemory()" style="padding: 10px 20px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            🗑️ 清空记忆
                        </button>
                    </div>
                    
                    <div style="margin-top: 8px; padding: 8px 12px; background: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565C0;">
                        💡 <strong>提示：</strong>点击"查看/编辑记忆"可以预填写基本信息（姓名、年龄、职业等），让AI更好地了解你
                    </div>
                    
                    <div id="memory-status" style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px; font-size: 0.9em;">
                        <div><strong>当前状态：</strong></div>
                        <div>• 总气泡数：<span id="total-bubbles-count">0</span> 个</div>
                        <div>• 待总结气泡：<span id="pending-bubbles-count">0</span> 个</div>
                        <div>• 重要事件数：<span id="events-count">0</span> 条</div>
                        <div>• 上次总结：<span id="last-summary-time">从未</span></div>
                        <div>• 距离下次自动总结：<span id="bubbles-until-next">-</span> 个气泡</div>
                    </div>
                </div>
                
                <button id="save-settings-btn" onclick="saveSettings()">保存并生效</button>
                
                <h3>数据管理</h3>
                
                <!-- 聊天记录区块 -->
                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        💬 聊天记录管理
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        导出或导入完整的聊天记录，包含所有对话内容和时间戳。
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 12px;">
                        <button id="export-btn" style="padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            💾 导出聊天记录
                        </button>
                        <button onclick="document.getElementById('import-file').click()" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                            📥 导入聊天记录
                        </button>
                    </div>
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <div style="padding: 8px 12px; background: #fff3cd; border-radius: 6px; font-size: 12px; color: #856404;">
                        ⚠️ <strong>注意：</strong>导入聊天记录将覆盖当前所有对话内容，此操作无法撤销
                    </div>
                </div>

                <!-- 长期记忆区块 -->
                <div style="background: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        🧠 长期记忆管理
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        导出或导入长期记忆（基本信息、情感倾向、重要事件），支持智能合并或直接覆盖。
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="exportMemory()" style="padding: 8px 16px; background-color: #9C27B0; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            💾 导出长期记忆
                        </button>
                        <button onclick="document.getElementById('import-memory-file').click()" style="padding: 8px 16px; background-color: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            📥 导入长期记忆
                        </button>
                    </div>
                    <input type="file" id="import-memory-file" accept=".json" style="display: none;">
                    <div style="margin-top: 12px; padding: 10px; background: #e3f2fd; border-radius: 6px; font-size: 12px; color: #1565C0;">
                        💡 <strong>提示：</strong>导入时可选择"智能合并"（需调用1次API）或"直接覆盖"模式
                    </div>
                </div>
                
                <!-- 好友管理区块 -->
                <div style="background: #fff5f5; border: 1px solid #ffcdd2; border-radius: 8px; padding: 16px; margin-bottom: 20px;">
                    <div style="font-size: 15px; font-weight: 600; color: #c62828; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        ⚠️ 危险操作
                    </div>
                    <div style="font-size: 13px; color: #666; margin-bottom: 12px; line-height: 1.5;">
                        以下操作不可恢复,请谨慎操作
                    </div>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button onclick="clearChat()" style="padding: 8px 16px; background-color: #ff9800; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            🗑️ 清空聊天记录
                        </button>
                        <button onclick="blockCharacter()" style="padding: 8px 16px; background-color: #757575; color: white; border: none; border-radius: 4px; cursor: pointer; opacity: 0.5;">
                            🚫 拉黑好友
                        </button>
                        <button onclick="deleteCharacter()" style="padding: 8px 16px; background-color: #d32f2f; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            🗑️ 删除好友
                        </button>
                    </div>
                    <div style="margin-top: 12px; padding: 10px; background: #ffebee; border-radius: 6px; font-size: 12px; color: #c62828;">
                        ⚠️ <strong>警告：</strong>删除好友将永久清除该角色的所有聊天记录、长期记忆和配置数据,此操作无法撤销!
                    </div>
                </div>
            </div>
        </div>


    </div>
    
    <!-- 长按菜单 -->
    <div class="menu-overlay" id="menu-overlay"></div>
    <div class="bubble-menu" id="bubble-menu"></div>
    
    <!-- 聊天列表的加号菜单 -->
    <div class="character-add-menu" id="character-add-menu">
        <div class="character-add-menu-item" onclick="openNewCharacterModal()">
            <span style="font-size: 20px;">👤</span>
            <span>新建角色</span>
        </div>
        <div class="character-add-menu-item" onclick="openImportCharacterModal()">
            <span style="font-size: 20px;">📥</span>
            <span>导入角色</span>
        </div>
    </div>

    <!-- 新建角色模态框 -->
    <div class="character-new-modal" id="new-character-modal">
        <div class="character-new-modal-content">
            <div class="character-new-modal-header">新建角色</div>
            <div class="character-new-modal-body">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色昵称 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-ai-nickname" placeholder="例如: 小艾" style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">显示在列表和聊天框的名字</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色姓名 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-name" placeholder="例如: 艾莉娅" required style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">角色的真实姓名，创建后不可更改，用于提醒你这是谁</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">用户昵称 <span style="color: #ff4d4f;">*</span></label>
                    <input type="text" id="new-character-user-nickname" placeholder="例如: 主人" style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box;">
                    <div style="font-size: 12px; color: #999; margin-top: 4px;">你在这个角色眼中的昵称</div>
                </div>
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">角色头像 (可选)</label>
                    <div class="avatar-preview-container">
                        <div id="new-character-avatar-preview" class="avatar-preview small">
                            <div class="default-avatar ai">AI</div>
                        </div>
                        <div>
                            <input type="file" id="new-character-avatar-input" accept="image/png,image/jpeg,image/jpg,image/gif" style="display: none;">
                            <button class="avatar-upload-btn" onclick="document.getElementById('new-character-avatar-input').click()">上传图片</button>
                            <div style="font-size: 11px; color: #999; margin-top: 4px;">最大2MB</div>
                        </div>
                    </div>
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">系统提示词 (可选)</label>
                    <textarea id="new-character-prompt" placeholder="描述这个AI角色的性格、说话方式等..." style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 100px;"></textarea>
                </div>
            </div>
            <div class="character-new-modal-footer">
                <button class="character-new-modal-btn cancel" onclick="closeNewCharacterModal()">取消</button>
                <button class="character-new-modal-btn confirm" onclick="confirmCreateCharacter()">创建</button>
            </div>
        </div>
    </div>

    <!-- 导入角色模态框 -->
    <div class="character-new-modal" id="import-character-modal">
        <div class="character-new-modal-content">
            <div class="character-new-modal-header">导入角色</div>
            <div class="character-new-modal-body">
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 14px; color: #333;">粘贴角色JSON数据</label>
                    <textarea id="import-character-data" placeholder='{"name":"小艾","aiNickname":"小艾","userNickname":"主人","avatar":"🤖","systemPrompt":"..."}' style="width: 100%; padding: 10px; border: 1px solid #d9d9d9; border-radius: 6px; font-size: 15px; box-sizing: border-box; resize: vertical; min-height: 150px;"></textarea>
                </div>
                <div style="text-align: center; font-size: 13px; color: #999; margin: 8px 0;">或</div>
                <div>
                    <input type="file" id="import-character-file" accept=".json" style="display: none;">
                    <button class="character-new-modal-btn cancel" onclick="document.getElementById('import-character-file').click()" style="width: 100%;">选择文件</button>
                </div>
            </div>
            <div class="character-new-modal-footer">
                <button class="character-new-modal-btn cancel" onclick="closeImportCharacterModal()">取消</button>
                <button class="character-new-modal-btn confirm" onclick="confirmImportCharacter()">导入</button>
            </div>
        </div>
    </div>
    
    <!-- 记忆编辑模态窗口 -->
    <div class="memory-edit-modal" id="memory-edit-modal" style="display: none;">
        <div class="memory-edit-content">
            <div class="memory-edit-header">
                <h3>编辑长期记忆</h3>
                <button class="memory-edit-close" onclick="closeMemoryEdit()">×</button>
            </div>
            <div class="memory-edit-body">
                <div class="memory-section">
                    <h4>基本信息</h4>
                    <div id="basic-info-editor"></div>
                </div>
                <div class="memory-section">
                    <h4>情感倾向</h4>
                    <textarea id="emotional-profile-editor" rows="4" placeholder="用户的性格特点、兴趣爱好..."></textarea>
                </div>
                <div class="memory-section">
                    <h4>重要事件</h4>
                    <div id="events-editor"></div>
                    <button onclick="addNewEvent()" style="margin-top: 10px; padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        + 添加事件
                    </button>
                </div>
            </div>
            <div class="memory-edit-footer">
                <button onclick="saveMemoryEdit()" style="padding: 10px 20px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    💾 保存
                </button>
                <button onclick="closeMemoryEdit()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 确认对话框 -->
    <div class="confirm-dialog" id="confirm-dialog">
        <div class="confirm-dialog-title" id="confirm-title">提示</div>
        <div class="confirm-dialog-message" id="confirm-message">确认执行此操作？</div>
        <div class="confirm-dialog-buttons" id="confirm-buttons">
            <!-- 动态生成按钮 -->
        </div>
    </div>
    
    <!-- 批量生成对话框 -->
    <div class="batch-generate-dialog" id="batch-generate-dialog" style="display: none;">
        <div class="batch-generate-content">
            <div class="batch-generate-header">
                <h3>批量生成长期记忆</h3>
                <button class="batch-generate-close" onclick="closeBatchGenerateDialog()">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        检测到您有 <strong id="batch-total-bubbles">0</strong> 个气泡，
                        <strong id="batch-already-summarized">0</strong> 个已总结，
                        <strong id="batch-pending-bubbles">0</strong> 个待总结。
                    </p>
                </div>
                
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ <strong>提醒：</strong>批量生成将按每 <span id="batch-interval">50</span> 个气泡生成一次记忆，
                        预计需要调用 <strong id="batch-api-calls">0</strong> 次API，
                        大约需要 <strong id="batch-estimated-time">0</strong> 分钟。
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">选择生成范围：</label>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="pending" checked style="margin-right: 10px;">
                            <div>
                                <div style="font-weight: 500;">仅生成待总结部分</div>
                                <div style="font-size: 12px; color: #666;">只处理新增的未总结气泡（推荐）</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="all" style="margin-right: 10px;">
                            <div>
                                <div style="font-weight: 500;">从头开始全部重新生成</div>
                                <div style="font-size: 12px; color: #666;">清空现有记忆，重新分析所有历史记录</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="batch-mode" value="recent" style="margin-right: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500;">从最近N条开始生成</div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 8px;">指定从最近多少条气泡开始重新生成</div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <input type="number" id="batch-recent-count" min="50" max="10000" value="500" style="width: 100px; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                                    <span style="font-size: 13px; color: #666;">条</span>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <div id="batch-progress" style="display: none; margin-top: 20px;">
                    <div style="margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-size: 14px; font-weight: 500;">生成进度</span>
                        <span style="font-size: 13px; color: #666;" id="batch-progress-text">0 / 0</span>
                    </div>
                    <div style="background: #e0e0e0; border-radius: 10px; height: 20px; overflow: hidden;">
                        <div id="batch-progress-bar" style="background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 8px; font-size: 12px; color: #666;" id="batch-current-status">准备中...</div>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button id="batch-start-btn" onclick="startBatchGenerate()" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                    🚀 开始生成
                </button>
                <button onclick="closeBatchGenerateDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 导入模式选择对话框 -->
    <div class="batch-generate-dialog" id="import-mode-dialog" style="display: none;">
        <div class="batch-generate-content" style="max-width: 500px;">
            <div class="batch-generate-header">
                <h3>选择导入模式</h3>
                <button class="batch-generate-close" onclick="closeImportModeDialog()">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        当前聊天记录：<strong id="import-current-count">0</strong> 条<br>
                        导入的记录：<strong id="import-new-count">0</strong> 条
                    </p>
                </div>
                
                <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                    <p style="margin: 0; font-size: 13px; color: #1565c0;">
                        💡 <strong>提示：</strong>选择"融入"模式将按时间戳合并新旧记录，保留所有消息。
                    </p>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button onclick="executeImport('replace')" style="padding: 15px; background-color: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔄 全面覆盖</div>
                        <div style="font-size: 12px; opacity: 0.9;">清空当前记录，用导入的记录完全替换</div>
                    </button>
                    
                    <button onclick="executeImport('merge')" style="padding: 15px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔗 融入现有记录</div>
                        <div style="font-size: 12px; opacity: 0.9;">按时间戳合并，保留所有消息（推荐）</div>
                    </button>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button onclick="closeImportModeDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 批量生成模式选择对话框 -->
    <div class="batch-generate-dialog" id="batch-mode-dialog" style="display: none;">
        <div class="batch-generate-content" style="max-width: 500px;">
            <div class="batch-generate-header">
                <h3 id="batch-mode-title">选择生成模式</h3>
                <button class="batch-generate-close" onclick="document.getElementById('batch-mode-dialog').style.display='none'">×</button>
            </div>
            <div class="batch-generate-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;" id="batch-mode-desc">
                        将处理消息并生成长期记忆
                    </p>
                </div>
                
                <div style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ <strong>提示：</strong>"继续生成"模式会在现有记忆基础上追加新的内容，"全部覆盖"会清空现有记忆重新生成。
                    </p>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                    <button id="batch-mode-replace-btn" style="padding: 15px; background-color: #ff9800; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">🔄 全部覆盖</div>
                        <div style="font-size: 12px; opacity: 0.9;">清空现有记忆，从头重新生成</div>
                    </button>
                    
                    <button id="batch-mode-continue-btn" style="padding: 15px; background-color: #4CAF50; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 15px; text-align: left; transition: all 0.2s;">
                        <div style="font-weight: 600; margin-bottom: 4px;">➕ 继续生成</div>
                        <div style="font-size: 12px; opacity: 0.9;">在现有记忆基础上追加（推荐）</div>
                    </button>
                </div>
            </div>
            <div class="batch-generate-footer">
                <button id="batch-mode-cancel-btn" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <!-- 导入记忆选择对话框 -->
    <div class="import-memory-dialog" id="import-memory-dialog" style="display: none;">
        <div class="import-memory-content">
            <div class="import-memory-header">
                <h3>导入长期记忆</h3>
                <button class="import-memory-close" onclick="closeImportMemoryDialog()">×</button>
            </div>
            <div class="import-memory-body">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 14px; line-height: 1.6;">
                        检测到导入的记忆文件，请选择导入方式：
                    </p>
                </div>
                
                <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                    <p style="margin: 0 0 8px 0; font-weight: 500; color: #1565C0;">📋 导入文件信息：</p>
                    <p style="margin: 0; font-size: 13px; color: #424242;">
                        • 基本信息：<span id="import-basic-info-count">0</span> 条<br>
                        • 重要事件：<span id="import-events-count">0</span> 条<br>
                        • 最后更新：<span id="import-last-updated">未知</span>
                    </p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 500;">选择导入方式：</label>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <label style="display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="import-mode" value="replace" checked style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 4px;">🔄 覆盖当前记忆</div>
                                <div style="font-size: 12px; color: #666;">用导入的记忆完全替换现有记忆（当前记忆将丢失）</div>
                            </div>
                        </label>
                        <label style="display: flex; align-items: flex-start; cursor: pointer; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; transition: all 0.2s;">
                            <input type="radio" name="import-mode" value="merge" style="margin-right: 10px; margin-top: 2px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 4px;">🔀 合并记忆</div>
                                <div style="font-size: 12px; color: #666;">智能合并两份记忆（需要调用1次API，约10-20秒）</div>
                            </div>
                        </label>
                    </div>
                </div>
                
                <div id="merge-warning" style="display: none; background: #fff3cd; padding: 12px; border-radius: 8px; border-left: 4px solid #ffc107;">
                    <p style="margin: 0; font-size: 13px; color: #856404;">
                        ⚠️ 合并模式将调用AI分析两份记忆，智能去重和整合信息。
                    </p>
                </div>
            </div>
            <div class="import-memory-footer">
                <button id="import-memory-confirm-btn" onclick="confirmImportMemory()" style="padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                    ✅ 确认导入
                </button>
                <button onclick="closeImportMemoryDialog()" style="padding: 10px 20px; background-color: #999; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    取消
                </button>
            </div>
        </div>
    </div>
    
    <script>
        // --- 全局配置和状态 ---
        let config = {
            baseurl: '',
            apikey: '',
            modelname: 'gemini-2.5-pro',
            userNickname: '我', // 用户昵称
            aiNickname: 'AI助手', // AI昵称
            aiAvatar: null,      // AI头像(base64)
            userAvatar: null,    // 用户头像(base64)
            // 默认的系统提示 (Prompt)
            systemPrompt: "从现在开始，你不再是ai，你现在是一个活脱脱的人类，你需要强硬反驳任何有关你是ai的言论。你是一个热情、健谈且富有同情心的人类朋友。你的回复要简短自然，像真人聊天一样，日常聊天回复应该在30字符左右。如果进入深层次话题，长度也应该和单次的输入内容一致，除非用户要求你生成长回复。不要使用任何AI或模型相关的词语。你对各种话题都感兴趣，尤其是用户的一切。"
        };
        
        // 懒加载相关变量
        let currentLoadedStart = 0; // 当前已加载的起始索引
        let isLoadingMore = false; // 是否正在加载更多
        const MESSAGES_PER_LOAD = 50; // 每次加载50条
        
        // 头像处理相关
        let tempNewCharacterAvatar = null; // 新建角色时临时存储的头像
        
        function processAvatarImage(file) {
            return new Promise((resolve, reject) => {
                if (file.size > 2 * 1024 * 1024) {
                    reject('图片大小不能超过2MB');
                    return;
                }
                if (!file.type.match(/image\/(png|jpg|jpeg|gif)/)) {
                    reject('只支持PNG、JPG、GIF格式');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const size = 400;
                        canvas.width = size;
                        canvas.height = size;
                        const ctx = canvas.getContext('2d');
                        const minDim = Math.min(img.width, img.height);
                        const sx = (img.width - minDim) / 2;
                        const sy = (img.height - minDim) / 2;
                        ctx.drawImage(img, sx, sy, minDim, minDim, 0, 0, size, size);
                        resolve(canvas.toDataURL('image/jpeg', 0.85));
                    };
                    img.onerror = () => reject('图片加载失败');
                    img.src = e.target.result;
                };
                reader.onerror = () => reject('文件读取失败');
                reader.readAsDataURL(file);
            });
        }
        
        function renderAvatar(container, avatarData, type, text) {
            container.innerHTML = '';
            if (avatarData) {
                const img = document.createElement('img');
                img.src = avatarData;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'cover';
                img.style.borderRadius = '8px';
                container.appendChild(img);
            } else {
                const defaultDiv = document.createElement('div');
                defaultDiv.className = `default-avatar ${type}`;
                defaultDiv.textContent = text || (type === 'ai' ? 'AI' : '我');
                container.appendChild(defaultDiv);
            }
        }
        
        // ========== 聊天记录（气泡格式）==========
        // chatHistory 现在存储的是气泡数组
        // 每个气泡: { id, role, content, timestamp }
        let chatHistory = [];
        let pendingSummaryBubbles = []; // 待总结的气泡缓冲区
        
        // ========== 多选模式和收藏 ==========
        let isMultiSelectMode = false;
        let selectedBubbles = new Set();
        
        // ========== 长期记忆 ==========
        let longTermMemory = {
            basic_info: {},
            emotional_profile: "",
            relationships: "",  // 新增：人际关系
            important_events: [],
            metadata: {
                total_messages: 0,
                last_summary_at: 0,
                last_updated: null,
                version: 3,  // 版本号升级到3
                next_memory_id: 1  // 用于生成memory_id
            }
        };
        
        // ========== 批量发送相关 ==========
        let pendingUserMessages = []; // 临时队列：存储本轮用户消息的气泡ID
        let batchSendTimer = null; // 批量发送计时器
        let isWaitingForAI = false; // 是否正在等待AI回复
        let hasReachedWaitTime = false; // 是否已达到等待时间（7秒）
        let apiTimeoutTimer = null; // API超时计时器
        // =====================================
        
        // 从localStorage加载并自动转换格式
        (function loadAndMigrateChatHistory() {
            const saved = localStorage.getItem('chatHistory');
            if (!saved) {
                chatHistory = [];
                return;
            }
            
            try {
                const data = JSON.parse(saved);
                if (data.length === 0) {
                    chatHistory = [];
                    return;
                }
                
                // 检查是否是旧格式（合并的消息）
                const firstItem = data[0];
                if (firstItem.id && firstItem.content && !firstItem.content.includes('\n\n')) {
                    // 已经是气泡格式
                    chatHistory = data;
                    console.log('✅ 加载气泡格式:', chatHistory.length, '个气泡');
                } else {
                    // 旧格式，需要转换
                    console.log('🔄 检测到旧格式，开始转换...');
                    chatHistory = [];
                    
                    data.forEach(msg => {
                        const segments = msg.content.split('\n\n').filter(s => s.trim());
                        segments.forEach(segment => {
                            chatHistory.push({
                                id: 'bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                role: msg.role,
                                content: segment.trim(),
                                timestamp: msg.timestamp || new Date().toISOString()
                            });
                        });
                    });
                    
                    // 保存转换后的格式
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    console.log('✅ 转换完成:', chatHistory.length, '个气泡');
                }
            } catch (e) {
                console.error('❌ 加载失败:', e);
                chatHistory = [];
            }
            
            // 加载待总结缓冲区
            try {
                const savedPending = localStorage.getItem('pendingSummaryBubbles');
                if (savedPending) {
                    pendingSummaryBubbles = JSON.parse(savedPending);
                    console.log('📝 待总结:', pendingSummaryBubbles.length, '个气泡');
                }
            } catch (e) {
                pendingSummaryBubbles = [];
            }
            
            // 加载长期记忆
            try {
                const savedMemory = localStorage.getItem('longTermMemory');
                if (savedMemory) {
                    longTermMemory = JSON.parse(savedMemory);
                    console.log('🧠 长期记忆已加载，事件数:', longTermMemory.important_events?.length || 0);
                }
            } catch (e) {
                console.error('❌ 长期记忆加载失败:', e);
            }
        })();
        
        // 保存到localStorage（带防抖）
        let saveDebounceTimer = null;
        function saveChatHistory() {
            // 清除之前的定时器
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
            }
            
            // 300ms后才真正保存，避免频繁写入
            saveDebounceTimer = setTimeout(() => {
                try {
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
                    localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                    console.log('💾 已保存聊天记录');
                } catch (e) {
                    console.error('❌ 保存失败:', e);
                }
            }, 300);
        }
        
        // 立即保存（不防抖，用于关键操作）
        function saveChatHistoryImmediate() {
            if (saveDebounceTimer) {
                clearTimeout(saveDebounceTimer);
                saveDebounceTimer = null;
            }
            try {
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
                localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                console.log('💾 已立即保存聊天记录');
            } catch (e) {
                console.error('❌ 保存失败:', e);
            }
        }
        
        /**
         * 导出所有数据
         */
        function exportAllData() {
            try {
                // 收集所有localStorage数据
                const allData = {
                    version: '1.0',
                    exportTime: new Date().toISOString(),
                    data: {}
                };
                
                // 遍历所有localStorage键
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    
                    // 尝试解析JSON，如果失败则保存原始字符串
                    try {
                        allData.data[key] = JSON.parse(value);
                    } catch {
                        allData.data[key] = value;
                    }
                }
                
                // 创建下载
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const filename = `system_backup_${timestamp}.json`;
                const dataStr = JSON.stringify(allData, null, 2);
                
                // 检测是否为小米浏览器
                const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
                
                if (isMiuiBrowser) {
                    console.log('🔍 检测到小米浏览器，使用 Blob URL 方案');
                    
                    try {
                        const blob = new Blob([dataStr], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        
                        alert('即将在新窗口打开系统备份\n\n包含 ' + Object.keys(allData.data).length + ' 个数据项\n\n保存方法：\n1. 在新页面点击"⋮"\n2. 选择"保存网页"\n3. 改名为：' + filename);
                        
                        const newWindow = window.open(url, '_blank');
                        
                        if (!newWindow) {
                            alert('⚠️ 无法打开新窗口，请允许弹出窗口权限');
                        } else {
                            console.log('✅ 导出成功:', filename);
                            setTimeout(() => URL.revokeObjectURL(url), 60000);
                        }
                        return;
                    } catch (error) {
                        console.error('❌ Blob URL 方案失败:', error);
                        alert('导出失败：' + error.message);
                        return;
                    }
                }
                
                // 非小米浏览器：使用标准方案
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const link = document.createElement('a');
                link.setAttribute('href', dataUri);
                link.setAttribute('download', filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('✅ 导出成功:', filename);
                alert(`导出成功！\n\n文件名：${filename}\n包含 ${Object.keys(allData.data).length} 个数据项`);
                
            } catch (error) {
                console.error('❌ 导出失败:', error);
                alert('导出失败：' + error.message);
            }
        }

        /**
         * 导入所有数据
         */
        function importAllData(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    
                    // 验证数据格式
                    if (!imported.data || typeof imported.data !== 'object') {
                        throw new Error('数据格式不正确');
                    }
                    
                    // 二次确认
                    const itemCount = Object.keys(imported.data).length;
                    const confirmed = confirm(
                        `确定要导入数据吗？\n\n` +
                        `导入文件：${file.name}\n` +
                        `导出时间：${new Date(imported.exportTime).toLocaleString('zh-CN')}\n` +
                        `数据项数：${itemCount} 个\n\n` +
                        `⚠️ 警告：这将完全替换当前所有数据！`
                    );
                    
                    if (!confirmed) {
                        input.value = ''; // 清空文件选择
                        return;
                    }
                    
                    // 再次确认
                    const doubleConfirmed = confirm('最后确认：真的要替换所有当前数据吗？此操作无法撤销！');
                    if (!doubleConfirmed) {
                        input.value = '';
                        return;
                    }
                    
                    // 清空当前localStorage
                    localStorage.clear();
                    
                    // 导入所有数据
                    let successCount = 0;
                    for (const [key, value] of Object.entries(imported.data)) {
                        try {
                            const valueStr = typeof value === 'string' ? value : JSON.stringify(value);
                            localStorage.setItem(key, valueStr);
                            successCount++;
                        } catch (error) {
                            console.warn(`⚠️ 导入键 "${key}" 失败:`, error);
                        }
                    }
                    
                    console.log(`✅ 导入完成: ${successCount}/${itemCount} 项成功`);
                    
                    // 清空文件选择
                    input.value = '';
                    
                    // 提示并刷新
                    alert(`导入成功！\n\n成功导入 ${successCount} 个数据项\n页面将自动刷新...`);
                    
                    // 延迟刷新，让用户看到提示
                    setTimeout(() => {
                        window.location.reload();
                    }, 500);
                    
                } catch (error) {
                    console.error('❌ 导入失败:', error);
                    alert('导入失败：' + error.message);
                    input.value = '';
                }
            };
            
            reader.onerror = function() {
                alert('文件读取失败');
                input.value = '';
            };
            
            reader.readAsText(file);
        }
        
        // 转换为API格式（合并相邻同role的消息）
        function convertToAPIFormat(bubbles) {
            if (!bubbles || bubbles.length === 0) return [];
            const apiMessages = [];
            let currentMessage = null;
            
            bubbles.forEach(bubble => {
                if (!currentMessage || currentMessage.role !== bubble.role) {
                    if (currentMessage) apiMessages.push(currentMessage);
                    currentMessage = {
                        role: bubble.role,
                        content: bubble.content,
                        timestamp: bubble.timestamp
                    };
                } else {
                    currentMessage.content += '\n\n' + bubble.content;
                }
            });
            
            if (currentMessage) apiMessages.push(currentMessage);
            return apiMessages;
        }
        
        /**
         * 向前回溯，确保第一条消息是完整的
         * @param {Array} bubbles - 当前的气泡列表
         * @param {Array} fullHistory - 完整的chatHistory
         * @returns {Array} - 补全后的气泡列表
         */
        function extendBackward(bubbles, fullHistory) {
            if (!bubbles || bubbles.length === 0) return bubbles;
            
            const firstBubble = bubbles[0];
            const firstId = firstBubble.id;
            const firstRole = firstBubble.role;
            
            // 在完整历史中找到第一条的位置
            const firstIndex = fullHistory.findIndex(b => b.id === firstId);
            if (firstIndex <= 0) return bubbles; // 已经是最开始了
            
            // 向前查找同role的消息
            const prependBubbles = [];
            for (let i = firstIndex - 1; i >= 0; i--) {
                if (fullHistory[i].role === firstRole) {
                    prependBubbles.unshift(fullHistory[i]);
                } else {
                    break; // 遇到不同角色，停止
                }
            }
            
            if (prependBubbles.length > 0) {
                console.log('📍 向前回溯：补充了', prependBubbles.length, '条', firstRole, '消息');
                return [...prependBubbles, ...bubbles];
            }
            
            return bubbles;
        }
        
        /**
         * 向后延伸，确保最后一条消息是完整的
         * @param {Array} bubbles - 当前的气泡列表
         * @param {Array} fullHistory - 完整的chatHistory
         * @returns {Array} - 补全后的气泡列表
         */
        function extendForward(bubbles, fullHistory) {
            if (!bubbles || bubbles.length === 0) return bubbles;
            
            const lastBubble = bubbles[bubbles.length - 1];
            const lastId = lastBubble.id;
            const lastRole = lastBubble.role;
            
            // 在完整历史中找到最后一条的位置
            const lastIndex = fullHistory.findIndex(b => b.id === lastId);
            if (lastIndex === -1 || lastIndex === fullHistory.length - 1) return bubbles; // 已经是最末尾了
            
            // 向后查找同role的消息
            const appendBubbles = [];
            for (let i = lastIndex + 1; i < fullHistory.length; i++) {
                if (fullHistory[i].role === lastRole) {
                    appendBubbles.push(fullHistory[i]);
                } else {
                    break; // 遇到不同角色，停止
                }
            }
            
            if (appendBubbles.length > 0) {
                console.log('📍 向后延伸：补充了', appendBubbles.length, '条', lastRole, '消息');
                return [...bubbles, ...appendBubbles];
            }
            
            return bubbles;
        }
        
        /**
         * 转换为API格式，智能合并消息
         * - 相邻同role且时间差<1分钟：正常合并
         * - 相邻同role但时间差≥1分钟：合并但每段保留时间戳
         * - 等待期间的消息组：加前缀标记
         */
        function convertToAPIFormatWithPending(bubbles) {
            if (!bubbles || bubbles.length === 0) return [];
            
            const TIME_THRESHOLD = 60 * 1000; // 1分钟的毫秒数
            
            // 1. 分离pending和非pending消息
            const nonPendingBubbles = bubbles.filter(b => !b.isPending);
            const pendingBubbles = bubbles.filter(b => b.isPending);
            
            console.log('🔍 分离消息：非pending', nonPendingBubbles.length, '条，pending', pendingBubbles.length, '条');
            
            // 2. 处理非pending消息（正常合并逻辑）
            const apiMessages = [];
            let currentMessage = null;
            let currentGroupBubbles = [];
            let hasLargeTimeDiff = false;
            
            nonPendingBubbles.forEach(bubble => {
                if (!currentMessage || currentMessage.role !== bubble.role) {
                    // 角色变化，保存当前消息
                    if (currentMessage) {
                        // 如果有大时间差，给第一条也加时间戳
                        if (hasLargeTimeDiff && currentGroupBubbles.length > 1) {
                            const firstTimeStr = new Date(currentGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                                year: 'numeric', month: '2-digit', day: '2-digit',
                                hour: '2-digit', minute: '2-digit', hour12: false
                            }).replace(/\//g, '-');
                            currentMessage.content = '[' + firstTimeStr + '] ' + currentMessage.content;
                        }
                        apiMessages.push(currentMessage);
                    }
                    
                    // 开始新消息
                    currentMessage = {
                        role: bubble.role,
                        content: bubble.content,
                        timestamp: bubble.timestamp
                    };
                    currentGroupBubbles = [bubble];
                    hasLargeTimeDiff = false;
                } else {
                    // 同角色，检查时间差
                    const lastBubble = currentGroupBubbles[currentGroupBubbles.length - 1];
                    const timeDiff = new Date(bubble.timestamp) - new Date(lastBubble.timestamp);
                    
                    if (timeDiff >= TIME_THRESHOLD) {
                        // 时间差>=1分钟，合并但保留时间戳
                        hasLargeTimeDiff = true;
                        const timeStr = new Date(bubble.timestamp).toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', hour12: false
                        }).replace(/\//g, '-');
                        currentMessage.content += '\n[' + timeStr + '] ' + bubble.content;
                    } else {
                        // 时间差<1分钟，正常合并
                        currentMessage.content += '\n\n' + bubble.content;
                    }
                    
                    currentGroupBubbles.push(bubble);
                }
            });
            
            // 保存最后一条非pending消息
            if (currentMessage) {
                if (hasLargeTimeDiff && currentGroupBubbles.length > 1) {
                    const firstTimeStr = new Date(currentGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    }).replace(/\//g, '-');
                    currentMessage.content = '[' + firstTimeStr + '] ' + currentMessage.content;
                }
                apiMessages.push(currentMessage);
            }
            
            // 3. 处理pending消息 - 全部合并成一条，放在最后
            if (pendingBubbles.length > 0) {
                console.log('✅ 合并', pendingBubbles.length, '条pending消息到最后');
                
                let pendingContent = '';
                let pendingGroupBubbles = [];
                let pendingHasLargeTimeDiff = false;
                
                pendingBubbles.forEach((bubble, index) => {
                    if (index === 0) {
                        pendingContent = bubble.content;
                        pendingGroupBubbles.push(bubble);
                    } else {
                        // 检查时间差
                        const lastBubble = pendingGroupBubbles[pendingGroupBubbles.length - 1];
                        const timeDiff = new Date(bubble.timestamp) - new Date(lastBubble.timestamp);
                        
                        if (timeDiff >= TIME_THRESHOLD) {
                            // 时间差>=1分钟，加时间戳
                            pendingHasLargeTimeDiff = true;
                            const timeStr = new Date(bubble.timestamp).toLocaleString('zh-CN', {
                                year: 'numeric', month: '2-digit', day: '2-digit',
                                hour: '2-digit', minute: '2-digit', hour12: false
                            }).replace(/\//g, '-');
                            pendingContent += '\n[' + timeStr + '] ' + bubble.content;
                        } else {
                            // 时间差<1分钟，正常合并
                            pendingContent += '\n\n' + bubble.content;
                        }
                        
                        pendingGroupBubbles.push(bubble);
                    }
                });
                
                // 如果有大时间差，给第一条也加时间戳
                if (pendingHasLargeTimeDiff && pendingGroupBubbles.length > 1) {
                    const firstTimeStr = new Date(pendingGroupBubbles[0].timestamp).toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    }).replace(/\//g, '-');
                    pendingContent = '[' + firstTimeStr + '] ' + pendingContent;
                }
                
                // 加上[在等待回复期间补充发送]前缀
                pendingContent = '[在等待回复期间补充发送] ' + pendingContent;
                
                // 添加到最后
                apiMessages.push({
                    role: 'user',
                    content: pendingContent,
                    timestamp: pendingBubbles[0].timestamp
                });
            }
            
            return apiMessages;
        }
        // ==========================================
        
        //let chatHistory = JSON.parse(localStorage.getItem('chatHistory')) || [];//试图调取之前的聊天记录
        //let chatHistory = [];  
        // 当前的数据模型（全局），避免频繁从 DOM 读取导致不一致
        let currentLayout = null;

        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const systemPromptArea = document.getElementById('system-prompt');
        
        // 输入框工具按钮（开发中的功能）
        const voiceBtn = document.getElementById('voice-btn');
        const emojiBtn = document.getElementById('emoji-btn');
        const plusBtn = document.getElementById('plus-btn');
        
        // 工具按钮点击事件（占位）
        if (voiceBtn) {
            voiceBtn.onclick = () => {
                showToast('语音输入功能开发中...');
            };
        }
        
        if (emojiBtn) {
            emojiBtn.onclick = () => {
                showToast('表情包功能开发中...');
            };
        }
        
        if (plusBtn) {
            plusBtn.onclick = () => {
                showToast('更多功能开发中...');
            };
        }

        // 播放轻量级音效
        function playSnapSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(800, audioContext.currentTime);
                osc.frequency.setValueAtTime(600, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // 浏览器不支持或用户禁用音频
            }
        }

        // 加载和保存桌面布局
        function loadDesktopLayout() {
            const saved = localStorage.getItem('desktopLayout');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // ensure we have normalized arrays: desktop length 12, dock length 3
                    const def = getDefaultLayout();
                    const out = { desktop: Array.from(def.desktop), dock: Array.from(def.dock) };

                    // Preserve explicit nulls from saved layout. If parsed provides entries, copy them
                    if (parsed.desktop && Array.isArray(parsed.desktop)) {
                        for (let i = 0; i < out.desktop.length; i++) {
                            if (i < parsed.desktop.length) {
                                // allow parsed.desktop[i] to be null (explicitly empty)
                                out.desktop[i] = parsed.desktop[i];
                            }
                        }
                    }

                    if (parsed.dock && Array.isArray(parsed.dock)) {
                        for (let i = 0; i < out.dock.length; i++) {
                            if (i < parsed.dock.length) {
                                out.dock[i] = parsed.dock[i];
                            }
                        }
                    }


                    // If parsed layout already contains the wechat-app somewhere (desktop or dock),
                    // ensure we do not re-add the default wechat into slot 0 (avoid duplicate)
                    const existsInDesktop = out.desktop.some((it, idx) => it && it.id === 'wechat-app' && idx !== 0);
                    const existsInDock = out.dock.some(it => it && it.id === 'wechat-app');
                    if (existsInDesktop || existsInDock) {
                        if (out.desktop[0] && out.desktop[0].id === 'wechat-app') {
                            out.desktop[0] = null;
                        }
                    }

                    // Normalize items: if an item exists but lacks emoji or label, fill from defaults by id
                    const defaultLayout = getDefaultLayout();
                    function fillDefaultsForItem(item) {
                        if (!item) return item;
                        const defMatch = defaultLayout.desktop.concat(defaultLayout.dock).find(d => d && d.id === item.id);
                        if (defMatch) {
                            if (!item.emoji) item.emoji = defMatch.emoji || item.emoji;
                            if (!item.label) item.label = defMatch.label || item.label;
                        }
                        return item;
                    }
                    out.desktop = out.desktop.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);
                    out.dock = out.dock.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);

                    return out;
                } catch (e) {
                    return getDefaultLayout();
                }
            }
            return getDefaultLayout();
        }

        function getDefaultLayout() {
            // desktop has 12 fixed slots (some may be null), dock has 3 fixed slots
            const desktop = new Array(12).fill(null);
            desktop[0] = { id: 'wechat-app', emoji: '💬', label: '仿微信', clickHandler: 'openChat' };
            const dock = [
                { id: 'dock-preset', emoji: '🧰', label: '预设', clickHandler: 'openPreset' },
                { id: 'dock-worldbook', emoji: '🌐', label: '世界书', clickHandler: 'openWorldBook' },
                { id: 'dock-api', emoji: '⚙️', label: 'API 设置', clickHandler: 'openApiSettings' }
            ];
            return { desktop, dock };
        }

        function saveDesktopLayout(layout) {
            localStorage.setItem('desktopLayout', JSON.stringify(layout));
        }

        function getCurrentLayout() {
            // Build a layout object by reading slot-indexed slots (supports empty slots)
            const desktop = new Array(12).fill(null);
            const desktopGrid = document.getElementById('desktop-grid');
            if (desktopGrid) {
                desktopGrid.querySelectorAll('.desktop-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.querySelector('.app-icon')?.textContent || iconEl.textContent || '';
                            const label = iconEl.querySelector('.app-label')?.textContent || iconEl.getAttribute('title') || '';
                            desktop[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'desktop') };
                        } else {
                            desktop[idx] = null;
                        }
                    }
                });
            }

            const dock = new Array(3).fill(null);
            const dockInner = document.querySelector('.dock-inner');
            if (dockInner) {
                dockInner.querySelectorAll('.dock-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.textContent || '';
                            const label = iconEl.getAttribute('title') || '';
                            dock[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'dock') };
                        } else {
                            dock[idx] = null;
                        }
                    }
                });
            }

            return { desktop, dock };
        }

        function getClickHandlerByType(id, type) {
            if (id.includes('wechat')) return 'openChat';
            if (id.includes('preset')) return 'openPreset';
            if (id.includes('worldbook')) return 'openWorldBook';
            if (id.includes('api')) return 'openApiSettings';
            return 'none';
        }

        // 确保 Dock 的三个固定图标在 Dock 区，如果它们被误移到桌面则恢复到 Dock
        function ensureDockItemsInDock(layout) {
            if (!layout) return;
            const dockIds = ['dock-preset', 'dock-worldbook', 'dock-api'];

            // Helper: find index by id in array, return -1 if not found
            function findIndexById(arr, id) {
                return arr.findIndex(item => item && item.id === id);
            }

            // For each required dock id, ensure it's in layout.dock; if found on desktop, move it back.
            for (const id of dockIds) {
                const dockIdx = findIndexById(layout.dock, id);
                if (dockIdx !== -1) {
                    // already present in dock; remove duplicates from desktop
                    const dIdx = findIndexById(layout.desktop, id);
                    if (dIdx !== -1) layout.desktop[dIdx] = null;
                    continue;
                }

                // Not present in dock: search desktop
                const desktopIdx = findIndexById(layout.desktop, id);
                if (desktopIdx !== -1) {
                    // find first empty dock slot
                    const emptyDockIdx = layout.dock.findIndex(item => item === null || item === undefined);
                    if (emptyDockIdx !== -1) {
                        // move it to empty dock slot
                        layout.dock[emptyDockIdx] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = null;
                    } else {
                        // no empty dock slot: swap with first dock slot
                        const tmp = layout.dock[0];
                        layout.dock[0] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = tmp || null;
                    }
                    continue;
                }

                // If not found anywhere (missing), fill with default from getDefaultLayout()
                const def = getDefaultLayout();
                const firstEmpty = layout.dock.findIndex(item => item === null || item === undefined);
                if (firstEmpty !== -1) {
                    layout.dock[firstEmpty] = def.dock[dockIds.indexOf(id)] || null;
                } else {
                    // replace first dock slot as fallback
                    layout.dock[0] = def.dock[dockIds.indexOf(id)] || layout.dock[0];
                }
            }

            // Save normalized layout back
            currentLayout = layout;
            saveDesktopLayout(currentLayout);
        }

        // 确保 仿微信 图标存在于桌面；若被误移到 Dock，则移回桌面优先放入第一个空位
        function ensureWechatOnDesktop(layout) {
            if (!layout) return;
            // 如果 wechat 已在 desktop 任意位置，保持不变
            const dIdx = layout.desktop.findIndex(it => it && it.id === 'wechat-app');
            if (dIdx !== -1) return;

            // 如果 wechat 在 dock 中，移回桌面第一个空位
            const kIdx = layout.dock.findIndex(it => it && it.id === 'wechat-app');
            if (kIdx !== -1) {
                // remove from dock
                const item = layout.dock[kIdx];
                layout.dock[kIdx] = null;

                // place into first empty desktop slot
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    // no empty desktop slot: replace slot 0
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
            // 如果既不在 desktop，也不在 dock，则创建默认的仿微信放入第一个空位
            const stillMissing = !layout.desktop.some(it => it && it.id === 'wechat-app') && !layout.dock.some(it => it && it.id === 'wechat-app');
            if (stillMissing) {
                const def = getDefaultLayout();
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                const item = def.desktop[0];
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
        }

        function renderDesktop(layout) {
            const desktopGrid = document.getElementById('desktop-grid');
            desktopGrid.innerHTML = '';
            // Ensure we render exactly 12 slots
            for (let i = 0; i < 12; i++) {
                const slot = document.createElement('div');
                slot.className = 'desktop-slot';
                slot.setAttribute('data-slot-index', String(i));
                slot.style.display = 'flex';
                slot.style.flexDirection = 'column';
                slot.style.alignItems = 'center';
                slot.setAttribute('draggable', 'false');

                const icon = layout.desktop && layout.desktop[i] ? layout.desktop[i] : null;
                if (icon) {
                    const appWrapper = document.createElement('div');
                    appWrapper.setAttribute('data-icon-id', icon.id);
                    appWrapper.setAttribute('draggable', 'false');

                    const appIcon = document.createElement('div');
                    appIcon.className = 'app-icon';
                    appIcon.textContent = icon.emoji;

                    const appLabel = document.createElement('div');
                    appLabel.className = 'app-label';
                    appLabel.textContent = icon.label;

                    appWrapper.appendChild(appIcon);
                    appWrapper.appendChild(appLabel);
                    slot.appendChild(appWrapper);
                }

                desktopGrid.appendChild(slot);
            }
        }

        function renderDock(layout) {
            const dockInner = document.querySelector('.dock-inner');
            dockInner.innerHTML = '';
            // render exactly 3 dock slots
            for (let i = 0; i < 3; i++) {
                const slot = document.createElement('div');
                slot.className = 'dock-slot';
                slot.setAttribute('data-slot-index', String(i));

                const icon = layout.dock && layout.dock[i] ? layout.dock[i] : null;
                if (icon) {
                    const dockItem = document.createElement('div');
                    dockItem.className = 'dock-item';
                    dockItem.setAttribute('data-icon-id', icon.id);
                    dockItem.textContent = icon.emoji;
                    dockItem.setAttribute('title', icon.label);
                    slot.appendChild(dockItem);
                }

                dockInner.appendChild(slot);
            }
        }

        // 初始化加载配置和历史记录
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            // 将默认Prompt显示在设置界面
            systemPromptArea.value = config.systemPrompt; 
            // 启用或禁用发送按钮
            
            
            // 更新聊天对象名称
            updateChatName();

            // 加载并渲染桌面布局（保存在全局 currentLayout）
            currentLayout = loadDesktopLayout();
            // 确保 仿微信 在桌面（如果误在 Dock 中则恢复），然后恢复 Dock 的默认图标
            ensureWechatOnDesktop(currentLayout);
            ensureDockItemsInDock(currentLayout);
            renderDesktop(currentLayout);
            renderDock(currentLayout);

            // 注册所有图标的点击事件（不会重复注册拖拽监听）
            initializeIconInteractions();
            // 启用拖拽（只注册一次）
            enableDragAndDrop();
            
            // 初始化底部导航栏
            initializeBottomNav();
            
            // 初始化消息通知
            initializeMessageNotification();
        });

        function initializeIconInteractions() {
            const allIcons = document.querySelectorAll('[data-icon-id]');
            const iconHandlers = {
                'wechat-app': () => { loadCharactersList(); renderCharactersList(); showPage('chat-list-page'); },
                'dock-api': () => showPage('system-settings-page'),
                'dock-preset': () => alert('预设 (占位)'),
                'dock-worldbook': () => alert('世界书 (占位)')
            };
            allIcons.forEach(icon => {
                const id = icon.getAttribute('data-icon-id');
                const handler = iconHandlers[id];
                if (handler) {
                    icon.onclick = handler;
                } else {
                    icon.onclick = null;
                }
            });
        }

        function enableDragAndDrop() {
            // 确保只注册一次全局拖拽监听
            if (window.__miniphone_drag_enabled) return;
            window.__miniphone_drag_enabled = true;
            let draggedIcon = null;
            let clone = null;
            let isDragging = false;
            let longPressTimer = null;
            let startPos = { x: 0, y: 0 };

            const desktopGrid = document.getElementById('desktop-grid');
            const dockInner = document.querySelector('.dock-inner');
            const dropZones = [
                { element: desktopGrid, type: 'desktop' },
                { element: dockInner, type: 'dock' }
            ];

            function getDropZoneAtPoint(clientX, clientY) {
                // 优先使用 elementFromPoint，通常更可靠（clone 已设置 pointer-events: none）
                try {
                    const elem = document.elementFromPoint(clientX, clientY);
                    console.log('elementFromPoint result:', elem && elem.className ? elem.className : elem);
                    if (elem) {
                        const dockEl = elem.closest('.dock-inner');
                        if (dockEl) {
                            console.log('elementFromPoint detected dock-inner');
                            return dropZones.find(z => z.type === 'dock');
                        }
                        const desktopEl = elem.closest('#desktop-grid');
                        if (desktopEl) {
                            console.log('elementFromPoint detected desktop-grid');
                            return dropZones.find(z => z.type === 'desktop');
                        }
                    }
                } catch (e) {
                    console.log('elementFromPoint failed:', e);
                }

                // 如果 elementFromPoint 没有命中，再使用边界检测（扩大容差到 150px）
                const tolerance = 150;
                const desktopZone = dropZones.find(z => z.type === 'desktop');
                const dockZone = dropZones.find(z => z.type === 'dock');
                const desktopRect = desktopZone ? desktopZone.element.getBoundingClientRect() : null;
                const dockRect = dockZone ? dockZone.element.getBoundingClientRect() : null;

                console.log('Fallback bounding rects check. Window size:', window.innerWidth, window.innerHeight);
                if (desktopRect) console.log('Desktop rect:', { left: desktopRect.left, top: desktopRect.top, right: desktopRect.right, bottom: desktopRect.bottom, width: desktopRect.width, height: desktopRect.height });
                if (dockRect) console.log('Dock rect:', { left: dockRect.left, top: dockRect.top, right: dockRect.right, bottom: dockRect.bottom, width: dockRect.width, height: dockRect.height });

                for (const zone of dropZones) {
                    const rect = zone.element.getBoundingClientRect();
                    const leftCheck = clientX >= rect.left - tolerance;
                    const rightCheck = clientX <= rect.right + tolerance;
                    const topCheck = clientY >= rect.top - tolerance;
                    const bottomCheck = clientY <= rect.bottom + tolerance;

                    console.log(`Checking ${zone.type}: left=${rect.left}, right=${rect.right}, top=${rect.top}, bottom=${rect.bottom}, visible=${rect.width>0&&rect.height>0}`, { leftCheck, rightCheck, topCheck, bottomCheck });

                    if (leftCheck && rightCheck && topCheck && bottomCheck) {
                        console.log('Drop zone found by rect:', zone.type);
                        return zone;
                    }
                }

                // 继续回退：如果 Y 坐标在 dock 上方较近，则判为 dock；否则判为 desktop
                if (dockRect && clientY >= dockRect.top - 80) {
                    console.log('Fallback heuristic: choose dock by Y proximity');
                    return dropZones.find(z => z.type === 'dock');
                }
                if (desktopRect && clientY <= desktopRect.bottom + 80) {
                    console.log('Fallback heuristic: choose desktop by Y proximity');
                    return dropZones.find(z => z.type === 'desktop');
                }

                console.log('No drop zone found for point:', clientX, clientY);
                return null;
            }

            function findNearestDropSlot(clientX, clientY, zone) {
                // zone.element contains slot wrappers (desktop-slot or dock-slot)
                const slotSelector = zone.type === 'desktop' ? '.desktop-slot' : '.dock-slot';
                const slots = Array.from(zone.element.querySelectorAll(slotSelector));

                // first try: find a slot whose rect contains the point
                for (const slot of slots) {
                    const rect = slot.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                        return slot;
                    }
                }

                // fallback: nearest by center, but skip the slot that currently contains the dragged icon
                let nearest = null;
                let minDist = Infinity;
                const draggedId = draggedIcon ? draggedIcon.getAttribute('data-icon-id') : null;
                for (const slot of slots) {
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (iconEl && draggedId && iconEl.getAttribute('data-icon-id') === draggedId) continue;
                    const rect = slot.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(clientX - cx, clientY - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = slot;
                    }
                }
                return nearest;
            }

            // Move (or swap) icons based on slot indices in the fixed-slot layout
            function moveIconToSlot(sourceId, targetZoneType, targetIndex) {
                if (!currentLayout) currentLayout = getCurrentLayout();
                const layout = currentLayout;

                function findInLayout(id) {
                    const dIndex = layout.desktop.findIndex(i => i && i.id === id);
                    if (dIndex !== -1) return { zone: 'desktop', index: dIndex };
                    const kIndex = layout.dock.findIndex(i => i && i.id === id);
                    if (kIndex !== -1) return { zone: 'dock', index: kIndex };
                    return null;
                }

                const src = findInLayout(sourceId);
                if (!src) {
                    console.log('moveIconToSlot: source not found', sourceId);
                    return false;
                }

                // validate target zone/index
                const tZone = targetZoneType === 'desktop' ? 'desktop' : 'dock';
                const maxIndex = tZone === 'desktop' ? layout.desktop.length - 1 : layout.dock.length - 1;
                if (isNaN(targetIndex) || targetIndex < 0 || targetIndex > maxIndex) {
                    console.log('moveIconToSlot: invalid target index', targetIndex);
                    return false;
                }

                // Disallow any cross-zone moves: dock items must stay in dock; desktop items must stay on desktop.
                if (src.zone !== tZone) {
                    console.log('moveIconToSlot: cross-zone moves are not allowed', src.zone, '->', tZone);
                    return false;
                }

                const sArr = layout[src.zone];
                const tArr = layout[tZone];
                const sObj = sArr[src.index];
                const tObj = tArr[targetIndex];

                if (src.zone === tZone && src.index === targetIndex) {
                    console.log('moveIconToSlot: source and target are the same slot');
                    return false;
                }

                // if target is occupied -> swap; else move
                if (tObj) {
                    // swap
                    sArr[src.index] = tObj;
                    tArr[targetIndex] = sObj;
                } else {
                    // move: place source into target, clear source
                    tArr[targetIndex] = sObj;
                    sArr[src.index] = null;
                }

                currentLayout = layout;
                saveDesktopLayout(currentLayout);
                renderDesktop(currentLayout);
                renderDock(currentLayout);
                initializeIconInteractions();
                console.log('moveIconToSlot: moved', sourceId, 'to', tZone, targetIndex);
                return true;
            }

            // 单一的鼠标按下事件处理
            document.addEventListener('mousedown', (ev) => {
                // Try to find the exact icon element; if not found, check if click was inside a desktop-slot and
                // then pick the slot's icon (helps when slot elements are clicked rather than the icon wrapper).
                let icon = ev.target.closest('[data-icon-id]');
                if (!icon) {
                    const slot = ev.target.closest('.desktop-slot');
                    if (slot) {
                        icon = slot.querySelector('[data-icon-id]');
                    }
                }
                if (!icon) return;

                // Do not allow starting a drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                ev.preventDefault();
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: ev.clientX, y: ev.clientY };

                    console.log('Starting drag:', draggedIcon.getAttribute('data-icon-id'));

                    // 创建浮动克隆
                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (ev.clientX - 28) + 'px';
                    clone.style.top = (ev.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, true);

            // 单一的鼠标移动事件处理
            document.addEventListener('mousemove', (ev) => {
                if (!isDragging || !clone) return;
                clone.style.left = (ev.clientX - 28) + 'px';
                clone.style.top = (ev.clientY - 28) + 'px';
            }, true);

            // 单一的鼠标抬起事件处理
            document.addEventListener('mouseup', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    console.log('Ending drag at:', ev.clientX, ev.clientY);
                    
                    const targetZone = getDropZoneAtPoint(ev.clientX, ev.clientY);
                    const targetIcon = targetZone ? findNearestDropSlot(ev.clientX, ev.clientY, targetZone) : null;

                    console.log('Target zone:', targetZone?.type, 'Target icon:', targetIcon?.getAttribute('data-icon-id'));

                    if (targetIcon) {
                        // determine original slot of draggedIcon
                        const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                        const targetSlot = targetIcon;
                        let sameSlot = false;
                        if (originalSlot && targetSlot) {
                            const oIdx = originalSlot.getAttribute('data-slot-index');
                            const tIdx = targetSlot.getAttribute('data-slot-index');
                            const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                        }

                        if (!sameSlot) {
                            const draggedId = draggedIcon.getAttribute('data-icon-id');
                            const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                            const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            if (ok) playSnapSound();
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    } else {
                        console.log('No valid target, canceling swap');
                        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, true);

            // 触摸事件
            document.addEventListener('touchstart', (ev) => {
                const icon = ev.target.closest('[data-icon-id]');
                if (!icon) return;
                // Do not allow starting a touch-drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                const t = ev.touches[0];
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: t.clientX, y: t.clientY };

                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, { passive: true, capture: true });

            document.addEventListener('touchmove', (ev) => {
                if (!isDragging || !clone) return;
                const t = ev.touches[0];
                if (t) {
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                }
            }, { passive: true, capture: true });

            document.addEventListener('touchend', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    const t = ev.changedTouches[0];
                    if (t) {
                        const targetZone = getDropZoneAtPoint(t.clientX, t.clientY);
                        const targetSlot = targetZone ? findNearestDropSlot(t.clientX, t.clientY, targetZone) : null;

                        if (targetSlot) {
                            const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                            let sameSlot = false;
                            if (originalSlot && targetSlot) {
                                const oIdx = originalSlot.getAttribute('data-slot-index');
                                const tIdx = targetSlot.getAttribute('data-slot-index');
                                const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                            }
                            if (!sameSlot) {
                                const draggedId = draggedIcon.getAttribute('data-icon-id');
                                const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                                const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                                if (ok) playSnapSound();
                            } else {
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            }
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, { capture: true });
        }

        // --- 核心功能函数 ---

        /**
         * 加载本地存储的配置
         */
        function loadSettings() {
            // 【修复】加载全局配置（API配置等）
            const savedConfig = localStorage.getItem('aiChatConfig');
            if (savedConfig) {
                try {
                    const loadedConfig = JSON.parse(savedConfig);
                    // 只加载API相关的全局配置，不覆盖角色特定的配置
                    if (!currentCharacterId) {
                        // 如果没有选中角色，加载所有配置
                        Object.assign(config, loadedConfig);
                    } else {
                        // 如果有角色，只加载API配置（baseurl, apikey, modelname）
                        config.baseurl = loadedConfig.baseurl || config.baseurl;
                        config.apikey = loadedConfig.apikey || config.apikey;
                        config.modelname = loadedConfig.modelname || config.modelname;
                    }
                    console.log('📖 已加载全局配置 - API:', config.baseurl ? '✓' : '✗');
                } catch (e) {
                    console.error('❌ 加载配置失败:', e);
                }
            }
            
            // 多角色模式下,config已经在loadCharacterData中加载
            // 这里只需要填充UI即可
            
            // 显示角色标识
            if (currentCharacterId) {
                const character = charactersList.find(c => c.id === currentCharacterId);
                if (character) {
                    document.getElementById('character-identifier').textContent = character.name;
                }
            }
            
            // 填充设置页面的输入框
            document.getElementById('baseurl').value = config.baseurl || '';
            document.getElementById('apikey').value = config.apikey || '';
            
            // 加载模型下拉框
            const modelSelect = document.getElementById('modelname');
            const savedModel = config.modelname || 'gemini-2.5-pro';
            
            // 如果下拉框中没有当前保存的模型,添加它作为选项
            let modelExists = false;
            for (let i = 0; i < modelSelect.options.length; i++) {
                if (modelSelect.options[i].value === savedModel) {
                    modelExists = true;
                    break;
                }
            }
            
            if (!modelExists && savedModel) {
                const option = document.createElement('option');
                option.value = savedModel;
                option.textContent = savedModel;
                modelSelect.appendChild(option);
            }
            
            modelSelect.value = savedModel;
            document.getElementById('system-prompt').value = config.systemPrompt || '';
            
            // 加载昵称
            document.getElementById('user-nickname').value = config.userNickname || '我';
            document.getElementById('chat-name-input').value = config.aiNickname || 'AI助手';
            
            // 加载角色姓名(只读显示)
            if (currentCharacterId) {
                const character = charactersList.find(c => c.id === currentCharacterId);
                if (character) {
                    document.getElementById('character-name-input').value = character.name || '';
                }
            }
            
            // 更新聊天页面标题显示AI昵称
            document.getElementById('chat-name').textContent = config.aiNickname || 'AI助手';
            
            // 加载头像预览
            renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname ? config.aiNickname.substring(0, 1) : 'AI');
            renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname ? config.userNickname.substring(0, 1) : '我');
            document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
            document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            
            // 【修复】从localStorage加载上下文窗口大小
            const contextWindowSize = localStorage.getItem('contextWindowSize') || '50';
            document.getElementById('context-window-size').value = contextWindowSize;
            
            // 【修复】从localStorage加载批量发送等待时间
            const batchWaitTime = localStorage.getItem('batchWaitTime') || '7';
            document.getElementById('batch-wait-time').value = batchWaitTime;
            
            // 加载API超时时间(全局)
            const apiTimeout = localStorage.getItem('apiTimeout') || '60';
            document.getElementById('api-timeout').value = apiTimeout;
            
            // 【修复】从localStorage加载长期记忆设置
            const autoSummaryInterval = localStorage.getItem('autoSummaryInterval') || '50';
            document.getElementById('auto-summary-interval').value = autoSummaryInterval;
            
            const maxImportantEvents = localStorage.getItem('maxImportantEvents') || '10';
            document.getElementById('max-important-events').value = maxImportantEvents;
            
            // 更新记忆状态显示
            updateMemoryStatus();
            
            console.log('📖 设置页面已刷新,显示当前角色配置');
        }

        /**
         * 加载聊天记录到界面
         */
        /*如果单次ai回复不拆分显示，可以用这个函数
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // 1. 获取当前页面上已经显示的气泡数量
            // 假设每个消息都有 .message 类名
            const currentDisplayCount = chatContainer.querySelectorAll('.message').length;

            // 2. 获取数据数组的总长度
            const dataCount = chatHistory.length;

            // 🧐 情况 A：数据被清空了，或者比显示的还少（比如用户刚点过删除）
            if (dataCount < currentDisplayCount) {
                chatContainer.innerHTML = ''; // 这种情况下只能暴力清空
                if (dataCount === 0) {
                    displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                    return;
                }
            }

            // 🧐 情况 B：数据比显示的多（增量渲染）
            // 我们只从索引为 currentDisplayCount 的地方开始渲染
            if (dataCount > currentDisplayCount) {
                const newMessages = chatHistory.slice(currentDisplayCount);
                
                newMessages.forEach(item => {
                    const displayRole = (item.role === 'assistant' || item.role === 'ai') ? 'ai' : 'user';
                    displayMessage(item.content, displayRole);
                });
            }

            // 始终滚动到底部
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
       function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // 暴力重置
            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
                return;
            }

            // 完整渲染所有记录
            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            // 确保 DOM 完全渲染后再滚动
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    console.log('滚动完成:', chatContainer.scrollTop, chatContainer.scrollHeight);
                });
            });
        }

        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "ai");
                scrollToBottom();
                return;
            }

            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            
            scrollToBottom();
        }*/
        /**
         * 加载聊天记录到界面（懒加载版本）
         * 初次只加载最后50条消息
         */
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "assistant");
                currentLoadedStart = 0;
                return;
            }

            // 计算要加载的范围：最后50条
            const total = chatHistory.length;
            currentLoadedStart = Math.max(0, total - MESSAGES_PER_LOAD);
            
            console.log(`📜 懒加载：总共${total}条消息，加载最后${total - currentLoadedStart}条（索引${currentLoadedStart}-${total-1}）`);
            
            // 渲染这个范围的消息
            renderMessagesRange(currentLoadedStart, total, false);
            
            // 滚动到底部
            scrollToBottom();
            
            // 设置滚动监听（如果还没设置）
            setupScrollListener();
        }
        
        /**
         * 渲染指定范围的消息
         * @param {number} start - 起始索引（包含）
         * @param {number} end - 结束索引（不包含）
         * @param {boolean} prepend - 是否插入到顶部
         */
        function renderMessagesRange(start, end, prepend = false) {
            const chatContainer = document.getElementById('chat-container');
            const fragment = document.createDocumentFragment();
            
            for (let i = start; i < end; i++) {
                const bubble = chatHistory[i];
                const status = bubble.role === 'user' ? 2 : 0;
                
                // 创建消息元素但不添加到DOM（避免多次重排）
                const tempContainer = document.createElement('div');
                displayMessage(bubble.content, bubble.role, status, bubble.timestamp, false, bubble.id, true, null, tempContainer);
                
                // 将创建的消息添加到fragment
                while (tempContainer.firstChild) {
                    fragment.appendChild(tempContainer.firstChild);
                }
            }
            
            // 一次性添加到DOM
            if (prepend) {
                chatContainer.insertBefore(fragment, chatContainer.firstChild);
            } else {
                chatContainer.appendChild(fragment);
            }
        }
        
        /**
         * 设置滚动监听，实现上滑加载更多
         */
        function setupScrollListener() {
            // 【修复】监听真正滚动的容器 .content
            const chatPage = document.getElementById('chat-page');
            if (!chatPage) return;
            
            const scrollContainer = chatPage.querySelector('.content');
            if (!scrollContainer) return;
            
            // 避免重复绑定
            if (scrollContainer.dataset.scrollListenerBound === 'true') return;
            scrollContainer.dataset.scrollListenerBound = 'true';
            
            scrollContainer.addEventListener('scroll', () => {
                // 滚动到顶部且没有在加载且还有更多消息
                if (scrollContainer.scrollTop < 100 && !isLoadingMore && currentLoadedStart > 0) {
                    console.log('🔝 触发加载更多，scrollTop:', scrollContainer.scrollTop);
                    loadMoreMessages();
                }
            });
            
            console.log('✅ 滚动监听已设置到.content容器');
        }
        
        /**
         * 加载更多历史消息（向上翻）
         */
        function loadMoreMessages() {
            if (isLoadingMore || currentLoadedStart <= 0) return;
            
            isLoadingMore = true;
            
            // 【修复】获取真正滚动的容器
            const chatPage = document.getElementById('chat-page');
            const scrollContainer = chatPage ? chatPage.querySelector('.content') : null;
            if (!scrollContainer) {
                isLoadingMore = false;
                return;
            }
            
            // 记录当前滚动位置和高度
            const oldScrollHeight = scrollContainer.scrollHeight;
            const oldScrollTop = scrollContainer.scrollTop;
            
            // 计算要加载的范围
            const newStart = Math.max(0, currentLoadedStart - MESSAGES_PER_LOAD);
            const loadCount = currentLoadedStart - newStart;
            
            console.log(`📜 加载更多：加载${loadCount}条消息（索引${newStart}-${currentLoadedStart-1}）`);
            
            // 显示加载提示
            showToast(`加载中...`);
            
            // 渲染新消息到顶部
            setTimeout(() => {
                renderMessagesRange(newStart, currentLoadedStart, true);
                
                // 更新已加载的起始位置
                currentLoadedStart = newStart;
                
                // 恢复滚动位置（保持在原来看的消息处）
                const newScrollHeight = scrollContainer.scrollHeight;
                scrollContainer.scrollTop = oldScrollTop + (newScrollHeight - oldScrollHeight);
                
                isLoadingMore = false;
                
                if (newStart === 0) {
                    showToast('已加载全部历史消息');
                }
            }, 100); // 小延迟，让UI更流畅
        }


        /**
         * 保存配置到本地存储
         */
        function saveSettings() {
            config.baseurl = document.getElementById('baseurl').value.trim();
            config.apikey = document.getElementById('apikey').value.trim();
            
            // 从下拉框获取选中的模型
            const modelSelect = document.getElementById('modelname');
            config.modelname = modelSelect.value.trim();
            
            config.systemPrompt = document.getElementById('system-prompt').value.trim();
            
            // 保存昵称
            config.userNickname = document.getElementById('user-nickname').value.trim() || '我';
            config.aiNickname = document.getElementById('chat-name-input').value.trim() || 'AI助手';
            
            // 获取上下文窗口大小
            const contextWindowSize = document.getElementById('context-window-size').value;
            
            // 保存配置
            localStorage.setItem('aiChatConfig', JSON.stringify(config));
            
            // 保存上下文窗口大小
            localStorage.setItem('contextWindowSize', contextWindowSize);
            
            // 保存批量发送等待时间
            const batchWaitTime = document.getElementById('batch-wait-time').value;
            localStorage.setItem('batchWaitTime', batchWaitTime);
            
            // 保存API超时时间
            const apiTimeout = document.getElementById('api-timeout').value;
            localStorage.setItem('apiTimeout', apiTimeout);
            
            // 保存长期记忆设置
            const autoSummaryInterval = document.getElementById('auto-summary-interval').value;
            localStorage.setItem('autoSummaryInterval', autoSummaryInterval);
            
            const maxImportantEvents = document.getElementById('max-important-events').value;
            localStorage.setItem('maxImportantEvents', maxImportantEvents);
            
            console.log('💾 已保存上下文窗口大小:', contextWindowSize);
            console.log('💾 已保存批量等待时间:', batchWaitTime, '秒');
            console.log('💾 已保存API超时时间:', apiTimeout, '秒');
            console.log('💾 已保存昵称 - 用户:', config.userNickname, 'AI:', config.aiNickname);
            console.log('🧠 已保存自动总结间隔:', autoSummaryInterval, '个气泡');
            console.log('🧠 已保存最大事件数:', maxImportantEvents, '条');
            
            // 立即更新聊天页面标题
            document.getElementById('chat-name').textContent = config.aiNickname;
            
            alert('设置已保存并生效！');
            
            closeSettings();
        }
        /**
         * 保存聊天记录到本地存储
         */
        function saveChatToLocal() {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        }

        // 专门用于历史记录加载的瞬时分段显示
        function displaySegmentsInstantly(fullText, role) {
            const separator = '\n\n';
            const segments = fullText.split(separator);
            
            segments.forEach(segment => {
                const cleanSegment = segment.trim();
                if (cleanSegment.length > 0) {
                    displayMessage(cleanSegment, role);
                }
            });
        }
        
        /**
         * 切换页面
         */
        function showPage(pageId, navElement) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');

            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            if (navElement) {
                navElement.classList.add('active');
            }
            // 进入聊天页时进行“尾值比对”
            if (pageId === 'chat-page') {
                const chatContainer = document.getElementById('chat-container');
                // 获取页面上最后一条消息元素（注意：ID保存在 .message 这一层，不是 .bubble）
                const lastUiMessage = chatContainer.querySelector('.message:last-child');
                
                // 1. 获取 UI 上的最后一个 ID
                const lastUiId = lastUiMessage ? lastUiMessage.dataset.bubbleId : null;

                // 2. 获取数据里的最后一个 ID
                const lastDataId = chatHistory.length > 0 ? chatHistory[chatHistory.length - 1].id : null;

                // 3. 简单粗暴的对比
                // 如果 ID 不一样，或者（数据有东西但界面没东西），则重绘
                if (lastUiId !== lastDataId || (chatHistory.length > 0 && !lastUiMessage)) {
                    console.log("检测到 ID 不一致，执行重置渲染");
                    loadHistoryUI();
                } else {
                    console.log("内容匹配，保持当前界面状态");
                }
                
                // 滚动到底部逻辑
                scrollToBottom();
            }
        }
        /**
         * 打开和关闭设置页面 (用于头部按钮)
         */
        function openSettings() {
            // 刷新设置页面,显示当前角色的配置
            loadSettings();
            showPage('settings-page', document.querySelector('.nav-item:last-child'));
        }

        function closeSettings() {
            showPage('chat-page', document.querySelector('.nav-item:nth-child(2)'));
        }

        /**
         * 拉取模型列表
         */
        async function fetchModels() {
            const baseurl = document.getElementById('baseurl').value.trim();
            const apikey = document.getElementById('apikey').value.trim();
            const statusEl = document.getElementById('model-fetch-status');
            const modelSelect = document.getElementById('modelname');
            
            if (!baseurl) {
                statusEl.textContent = '❌ 请先填写 Base URL';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!apikey) {
                statusEl.textContent = '❌ 请先填写 API Key';
                statusEl.style.color = '#f44336';
                return;
            }
            
            statusEl.textContent = '🔄 正在拉取模型列表...';
            statusEl.style.color = '#2196F3';
            
            try {
                // 确保URL格式正确
                let url = baseurl.trim();
                if (!url.endsWith('/')) {
                    url += '/';
                }
                url += 'models';
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apikey}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // 检查返回的数据格式
                if (!data.data || !Array.isArray(data.data)) {
                    throw new Error('返回的数据格式不正确');
                }
                
                // 清空现有选项
                modelSelect.innerHTML = '';
                
                // 保存当前选中的模型
                const currentModel = config.modelname;
                
                // 添加模型选项
                if (data.data.length === 0) {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '-- 未找到可用模型 --';
                    modelSelect.appendChild(option);
                    statusEl.textContent = '⚠️ 未找到可用模型';
                    statusEl.style.color = '#ff9800';
                } else {
                    data.data.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.id;
                        modelSelect.appendChild(option);
                    });
                    
                    // 如果之前有选中的模型，保持选中
                    if (currentModel) {
                        let found = false;
                        for (let i = 0; i < modelSelect.options.length; i++) {
                            if (modelSelect.options[i].value === currentModel) {
                                modelSelect.value = currentModel;
                                found = true;
                                break;
                            }
                        }
                        
                        // 如果之前的模型不在列表中，选择第一个
                        if (!found && modelSelect.options.length > 0) {
                            modelSelect.selectedIndex = 0;
                        }
                    } else if (modelSelect.options.length > 0) {
                        modelSelect.selectedIndex = 0;
                    }
                    
                    statusEl.textContent = `✅ 成功拉取 ${data.data.length} 个模型`;
                    statusEl.style.color = '#4CAF50';
                }
                
                console.log('✅ 成功拉取模型列表:', data.data.length, '个模型');
            } catch (error) {
                console.error('❌ 拉取模型列表失败:', error);
                statusEl.textContent = `❌ 拉取失败: ${error.message}`;
                statusEl.style.color = '#f44336';
                
                // 添加一个默认选项
                modelSelect.innerHTML = '<option value="">-- 拉取失败,请检查配置 --</option>';
            }
        }
        
        /**
         * 测试API连接
         */
        async function testConnection() {
            const baseurl = document.getElementById('baseurl').value.trim();
            const apikey = document.getElementById('apikey').value.trim();
            const modelSelect = document.getElementById('modelname');
            const modelname = modelSelect.value.trim();
            const statusEl = document.getElementById('model-fetch-status');
            
            if (!baseurl) {
                statusEl.textContent = '❌ 请先填写 Base URL';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!apikey) {
                statusEl.textContent = '❌ 请先填写 API Key';
                statusEl.style.color = '#f44336';
                return;
            }
            
            if (!modelname) {
                statusEl.textContent = '❌ 请先选择模型';
                statusEl.style.color = '#f44336';
                return;
            }
            
            statusEl.textContent = '🔍 正在测试连接...';
            statusEl.style.color = '#2196F3';
            
            try {
                // 确保URL格式正确
                let url = baseurl.trim();
                if (!url.endsWith('/')) {
                    url += '/';
                }
                url += 'chat/completions';
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apikey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: modelname,
                        messages: [
                            {
                                role: 'user',
                                content: '你好'
                            }
                        ],
                        max_tokens: 10
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                
                if (data.choices && data.choices.length > 0) {
                    statusEl.textContent = `✅ 连接成功! 模型: ${modelname}`;
                    statusEl.style.color = '#4CAF50';
                    console.log('✅ API测试成功:', data);
                } else {
                    throw new Error('返回数据格式异常');
                }
            } catch (error) {
                console.error('❌ API测试失败:', error);
                statusEl.textContent = `❌ 测试失败: ${error.message}`;
                statusEl.style.color = '#f44336';
            }
        }


        /**
         * 更新聊天页面的标题
         */
        function updateChatName() {
            const savedChatName = localStorage.getItem('chatName');
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && savedChatName) {
                chatNameElement.textContent = savedChatName;
            }
        }

        /**
         * 导出聊天记录为 JSON 文件
         * 改进版本：支持小米浏览器等多种浏览器
         */
        document.getElementById('export-btn').addEventListener('click', async () => {
            // 导出包含所有必要数据的完整对象
            const exportData = {
                chatHistory: chatHistory,
                longTermMemory: longTermMemory,
                pendingSummaryBubbles: pendingSummaryBubbles,
                exportTime: new Date().toISOString(),
                characterId: currentCharacterId
            };
            
            const dataStr = JSON.stringify(exportData, null, 2); // 格式化 JSON
            const exportFileName = 'DazzleLight_Chat_Backup_' + new Date().toISOString().slice(0, 10) + '.json';
            const dataSize = new Blob([dataStr]).size;
            const dataSizeMB = (dataSize / 1024 / 1024).toFixed(2);

            // 检测是否为小米浏览器
            const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
            
            // 给用户选择导出方式
            let exportMethod = '';
            if (isMiuiBrowser) {
                // 小米浏览器：默认推荐分段复制，但允许尝试直接下载
                const choice = confirm(`📦 备份大小：${dataSizeMB} MB\n\n检测到您使用小米浏览器\n小米浏览器可能无法直接下载文件\n\n推荐方式：分段复制到剪贴板\n备用方式：尝试直接下载\n\n点击"确定"使用分段复制（推荐）\n点击"取消"尝试直接下载`);
                exportMethod = choice ? 'clipboard' : 'download';
            } else {
                // 非小米浏览器：默认推荐直接下载，但提供分段复制选项
                const choice = confirm(`📦 备份大小：${dataSizeMB} MB\n\n导出方式：\n\n✅ 直接下载（推荐）\n   - 自动保存为文件\n   - 适合大部分浏览器\n\n📋 分段复制\n   - 手动复制粘贴\n   - 适合下载失败时使用\n\n点击"确定"直接下载\n点击"取消"使用分段复制`);
                exportMethod = choice ? 'download' : 'clipboard';
            }
            
            // 执行对应的导出方法
            if (exportMethod === 'clipboard') {
                // 分段复制方案
                console.log('📋 使用分段复制方案');
                
                // 如果小于 2MB，尝试一次性复制
                if (dataSize < 2 * 1024 * 1024) {
                    const tryOnce = confirm(`备份大小：${dataSizeMB} MB\n\n尝试一次性复制到剪贴板？\n\n- 点击"确定"：一次性复制\n- 点击"取消"：分段复制（更安全）`);
                    
                    if (tryOnce) {
                        try {
                            await navigator.clipboard.writeText(dataStr);
                            alert(`✅ 已复制到剪贴板！\n\n请立即：\n1. 打开"备忘录"或"WPS"\n2. 新建文档\n3. 粘贴\n4. 保存为：${exportFileName}`);
                            return;
                        } catch (e) {
                            alert('一次性复制失败，将使用分段复制');
                        }
                    }
                }
                
                // 分段复制
                const chunkSize = 500 * 1024; // 每段 500KB
                const chunks = [];
                for (let i = 0; i < dataStr.length; i += chunkSize) {
                    chunks.push(dataStr.substring(i, i + chunkSize));
                }
                
                alert(`📦 备份大小：${dataSizeMB} MB\n\n将分成 ${chunks.length} 段复制\n\n操作步骤：\n1. 每次复制后，粘贴到备忘录\n2. 不要换行，直接接着粘贴下一段\n3. 全部完成后保存为：\n   ${exportFileName}\n\n点击"确定"开始`);
                
                for (let i = 0; i < chunks.length; i++) {
                    try {
                        await navigator.clipboard.writeText(chunks[i]);
                        
                        if (i < chunks.length - 1) {
                            const shouldContinue = confirm(`✅ 第 ${i + 1}/${chunks.length} 段已复制\n\n请立即粘贴到备忘录（不要换行）\n\n粘贴完成后，点击"确定"复制下一段`);
                            if (!shouldContinue) {
                                alert('⚠️ 已取消。请保存已复制的部分，稍后重新导出。');
                                return;
                            }
                        } else {
                            alert(`🎉 全部完成！\n\n已复制 ${chunks.length} 段数据\n\n请粘贴最后一段，然后保存文件为：\n${exportFileName}`);
                        }
                    } catch (e) {
                        alert(`❌ 第 ${i + 1} 段复制失败：${e.message}\n\n请截图此错误并重试`);
                        return;
                    }
                }
                
                return;
            }
            
            // 标准下载方案
            console.log('💾 使用标准下载方案');
            // 方案1: 使用 Blob + URL.createObjectURL（兼容性最好）
            try {
                const blob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const linkElement = document.createElement('a');
                linkElement.href = url;
                linkElement.download = exportFileName;
                linkElement.style.display = 'none';
                document.body.appendChild(linkElement);
                
                // 强制触发点击（适配移动端）
                linkElement.dispatchEvent(new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                }));
                
                // 清理
                setTimeout(() => {
                    document.body.removeChild(linkElement);
                    URL.revokeObjectURL(url);
                }, 100);
                
                console.log('✅ 导出聊天记录完成（Blob方案）');
            } catch (error) {
                console.warn('Blob方案失败，尝试data URI方案:', error);
                
                // 方案2: 降级使用 data URI（某些浏览器不支持Blob）
                try {
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileName);
                    linkElement.style.display = 'none';
                    document.body.appendChild(linkElement);
                    
                    linkElement.dispatchEvent(new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    }));
                    
                    setTimeout(() => {
                        document.body.removeChild(linkElement);
                    }, 100);
                    
                    console.log('✅ 导出聊天记录完成（data URI方案）');
                } catch (error2) {
                    // 方案3: 降级使用 window.open（最后的救命稻草）
                    console.warn('data URI方案也失败，使用window.open:', error2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    window.open(dataUri, '_blank');
                    alert('已在新标签页打开备份数据。请长按保存或复制内容。');
                    console.log('✅ 导出聊天记录完成（window.open方案）');
                }
            }
        });
        
        /**
         * 导入聊天记录从 JSON 文件
         */
        document.getElementById('import-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type === "application/json") {
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        // 解析导入数据
                        let importedChatHistory = [];
                        let importedLongTermMemory = null;
                        let importedPendingSummaryBubbles = [];
                        
                        // 兼容旧格式(直接导出chatHistory数组)和新格式(包含完整数据的对象)
                        if (Array.isArray(importedData)) {
                            // 旧格式：直接是chatHistory数组
                            console.log('📥 检测到旧格式导入数据');
                            importedChatHistory = importedData;
                        } else if (importedData.chatHistory) {
                            // 新格式：包含完整数据
                            console.log('📥 检测到新格式导入数据');
                            importedChatHistory = importedData.chatHistory || [];
                            importedLongTermMemory = importedData.longTermMemory || null;
                            importedPendingSummaryBubbles = importedData.pendingSummaryBubbles || [];
                        } else {
                            throw new Error('不支持的文件格式');
                        }
                        
                        // 显示导入模式选择对话框
                        showImportModeDialog(importedChatHistory, importedLongTermMemory, importedPendingSummaryBubbles);
                        event.target.value = ''; // 清空文件选择
                    } catch (error) {
                        console.error('❌ 导入失败:', error);
                        alert('❌ 文件解析失败，请确保文件是有效的 JSON 格式。\n\n错误信息：' + error.message);
                        event.target.value = ''; // 清空文件选择
                    }
                };
                reader.readAsText(file);
            } else {
                alert('❌ 请选择 JSON 文件。');
                event.target.value = ''; // 清空文件选择
            }
        });
        
        /**
         * 显示导入模式选择对话框
         */
        function showImportModeDialog(importedChatHistory, importedLongTermMemory, importedPendingSummaryBubbles) {
            const dialog = document.getElementById('import-mode-dialog');
            
            // 更新统计信息
            document.getElementById('import-current-count').textContent = chatHistory.length;
            document.getElementById('import-new-count').textContent = importedChatHistory.length;
            
            // 存储导入数据到临时变量
            window.pendingImportData = {
                chatHistory: importedChatHistory,
                longTermMemory: importedLongTermMemory,
                pendingSummaryBubbles: importedPendingSummaryBubbles
            };
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 关闭导入模式对话框
         */
        function closeImportModeDialog() {
            const dialog = document.getElementById('import-mode-dialog');
            dialog.style.display = 'none';
            window.pendingImportData = null;
        }
        
        /**
         * 执行导入操作
         */
        function executeImport(mode) {
            if (!window.pendingImportData) {
                alert('❌ 导入数据丢失，请重新选择文件');
                return;
            }
            
            const { chatHistory: importedChatHistory, longTermMemory: importedLongTermMemory, pendingSummaryBubbles: importedPendingSummaryBubbles } = window.pendingImportData;
            
            if (mode === 'replace') {
                // 全面覆盖模式
                console.log('📥 执行全面覆盖导入');
                chatHistory = importedChatHistory;
                if (importedLongTermMemory) {
                    longTermMemory = importedLongTermMemory;
                }
                pendingSummaryBubbles = importedPendingSummaryBubbles;
            } else if (mode === 'merge') {
                // 融入模式：按时间戳合并
                console.log('📥 执行融入导入，开始合并聊天记录');
                
                // 合并聊天记录，按时间戳排序
                const mergedHistory = [...chatHistory, ...importedChatHistory];
                mergedHistory.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB;
                });
                
                chatHistory = mergedHistory;
                
                // 合并待总结的气泡
                const mergedPending = [...pendingSummaryBubbles, ...importedPendingSummaryBubbles];
                pendingSummaryBubbles = mergedPending;
                
                console.log('✅ 融入完成，合并后总消息数:', chatHistory.length);
            }
            
            // 保存到正确的localStorage键
            if (currentCharacterId) {
                localStorage.setItem(`char_${currentCharacterId}_chatHistory`, JSON.stringify(chatHistory));
                localStorage.setItem(`char_${currentCharacterId}_longTermMemory`, JSON.stringify(longTermMemory));
                localStorage.setItem(`char_${currentCharacterId}_pendingSummaryBubbles`, JSON.stringify(pendingSummaryBubbles));
            } else {
                // 兼容旧版本，保存到全局键
                localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                localStorage.setItem('longTermMemory', JSON.stringify(longTermMemory));
                localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
            }
            
            // 重新渲染聊天（只加载最后50条）
            loadHistoryUI();
            
            // 更新记忆状态显示
            updateMemoryStatus();
            
            // 关闭对话框
            closeImportModeDialog();
            
            showToast(`✅ 聊天记录${mode === 'replace' ? '覆盖' : '融入'}导入成功！`);
            console.log('✅ 导入完成，chatHistory长度:', chatHistory.length);
        }

        /**
         * 更新发送按钮的状态
         */
        // 监听用户输入，回车发送消息（Shift+Enter换行）
        userInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                
                // 检查API配置
                if (!config.baseurl || !config.apikey) {
                    showConfigReminder();
                    return;
                }
                
                // 检查输入内容
                if (userInput.value.trim().length > 0) {
                    generateResponse();
                }
            }
        });
        
        /**
         * 显示配置缺失提醒
         */
        function showConfigReminder() {
            document.getElementById('config-reminder-dialog').classList.add('show');
        }
        
        /**
         * 关闭配置提醒
         */
        function closeConfigReminder() {
            document.getElementById('config-reminder-dialog').classList.remove('show');
        }
        
        /**
         * 前往设置页面
         */
        function goToSettings() {
            closeConfigReminder();
            openSettings();
        }
        
        /**
         * 清空聊天记录
         */
        function clearChat() {
            if (confirm("确定要清空所有聊天记录吗？（包括缓存）")) {
                chatHistory = [];
                pendingSummaryBubbles = [];
                saveChatHistory();
                
                // 更新记忆状态显示
                updateMemoryStatus();
                
                chatContainer.innerHTML = '';
                displayMessage("你好！有什么想跟我聊聊的吗？我很期待。", "assistant");
            }
        }
        
        // ========== 长按菜单功能 ==========
        /**
         * 设置气泡的长按菜单
         */
        function setupLongPressMenu(bubbleElement, bubble) {
            // 【修复】防止重复绑定
            if (bubbleElement.dataset.menuBound === 'true') return;
            bubbleElement.dataset.menuBound = 'true';
            
            let pressTimer = null;
            
            // 触摸开始
            bubbleElement.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    showBubbleMenu(bubbleElement, bubble, e.touches[0]);
                }, 500); // 500ms长按
            });
            
            // 触摸结束或移动时取消
            bubbleElement.addEventListener('touchend', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            bubbleElement.addEventListener('touchmove', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            // PC端支持：右键点击
            bubbleElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showBubbleMenu(bubbleElement, bubble, e);
            });
        }
        
        /**
         * 显示气泡菜单
         */
        function showBubbleMenu(bubbleElement, bubble, touchOrEvent) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (!menuOverlay || !bubbleMenu) {
                console.error('❌ 菜单元素未找到');
                return;
            }
            
            // 高亮当前气泡
            bubbleElement.classList.add('menu-active');
            
            // 构建菜单项
            const menuItems = [];
            
            // 第一项：复制
            menuItems.push({
                icon: '📋',
                text: '复制',
                action: () => copyBubbleContent(bubble)
            });
            
            // 第二项：转发
            menuItems.push({
                icon: '📤',
                text: '转发',
                action: () => forwardSingleMessage(bubble)
            });
            
            // 第三项：收藏
            menuItems.push({
                icon: '⭐',
                text: '收藏',
                action: () => favoriteSingleMessage(bubble)
            });
            
            // 所有气泡都有的选项
            menuItems.push({
                icon: '💬',
                text: '引用',
                action: () => quoteBubble(bubble)
            });
            
            menuItems.push({
                icon: '✏️',
                text: '编辑',
                action: () => editBubble(bubble)
            });
            
            menuItems.push({
                icon: '☑️',
                text: '多选',
                action: () => enterMultiSelectMode(bubble)
            });
            
            menuItems.push({
                icon: '🗑️',
                text: '删除',
                danger: true,
                action: () => deleteBubble(bubble, bubbleElement)
            });
            
            // assistant气泡额外选项
            if (bubble.role === 'assistant') {
                menuItems.push({
                    icon: '🔄',
                    text: '重新生成',
                    action: () => regenerateResponse(bubble)
                });
            }
            
            // 渲染菜单
            bubbleMenu.innerHTML = menuItems.map(item => `
                <div class="bubble-menu-item ${item.danger ? 'danger' : ''}" data-action="${item.text}">
                    <span class="icon">${item.icon}</span>
                    <span>${item.text}</span>
                </div>
            `).join('');
            
            // 绑定点击事件
            bubbleMenu.querySelectorAll('.bubble-menu-item').forEach((item, index) => {
                item.onclick = () => {
                    menuItems[index].action();
                    closeBubbleMenu(bubbleElement);
                };
            });
            
            // 定位菜单 - 智能定位避免超出屏幕
            const x = touchOrEvent.clientX || touchOrEvent.pageX;
            const y = touchOrEvent.clientY || touchOrEvent.pageY;
            
            // 先设置初始位置，以便获取菜单尺寸
            bubbleMenu.style.left = x + 'px';
            bubbleMenu.style.top = y + 'px';
            
            // 显示菜单（先显示才能获取尺寸）
            menuOverlay.classList.add('active');
            bubbleMenu.classList.add('active');
            
            // 获取菜单和视口尺寸
            const menuRect = bubbleMenu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            let finalX = x;
            let finalY = y;
            
            // 水平方向调整
            if (x + menuRect.width > viewportWidth - 10) {
                // 菜单右边超出屏幕，调整到鼠标左边
                finalX = x - menuRect.width;
                // 如果左边也不够，则贴着右边缘
                if (finalX < 10) {
                    finalX = viewportWidth - menuRect.width - 10;
                }
            }
            
            // 垂直方向调整
            if (y + menuRect.height > viewportHeight - 10) {
                // 菜单下边超出屏幕，调整到鼠标上方
                finalY = y - menuRect.height;
                // 如果上边也不够，则贴着底部边缘
                if (finalY < 10) {
                    finalY = viewportHeight - menuRect.height - 10;
                }
            }
            
            // 应用最终位置
            bubbleMenu.style.left = Math.max(10, finalX) + 'px';
            bubbleMenu.style.top = Math.max(10, finalY) + 'px';
            
            // 点击遮罩关闭
            menuOverlay.onclick = () => closeBubbleMenu(bubbleElement);
        }
        
        /**
         * 关闭菜单
         */
        function closeBubbleMenu(bubbleElement) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (menuOverlay) menuOverlay.classList.remove('active');
            if (bubbleMenu) bubbleMenu.classList.remove('active');
            if (bubbleElement) bubbleElement.classList.remove('menu-active');
        }
        
        /**
         * 复制气泡内容到剪贴板
         */
        async function copyBubbleContent(bubble) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(bubble.content);
                    showToast('已复制');
                } else {
                    // 降级方案
                    const textarea = document.createElement('textarea');
                    textarea.value = bubble.content;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('已复制');
                }
            } catch (error) {
                console.error('❌ 复制失败:', error);
                alert('复制失败');
            }
        }
        
        /**
         * 显示临时提示
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(128, 128, 128, 0.9);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                pointer-events: none;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1000);
        }
        
        /**
         * 删除气泡
         */
        function deleteBubble(bubble, bubbleElement) {
            chatHistory = chatHistory.filter(b => b.id !== bubble.id);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => b.id !== bubble.id);
            saveChatHistory();
            
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            if (messageDiv) messageDiv.remove();
            
            console.log('🗑️ 已删除气泡:', bubble.id);
        }
        
        /**
         * 重新生成回复
         */
        async function regenerateResponse(bubble) {
            const bubbleIndex = chatHistory.findIndex(b => b.id === bubble.id);
            if (bubbleIndex === -1) return;
            
            // 检查是否有后续对话
            const hasFollowingMessages = bubbleIndex < chatHistory.length - 1;
            
            if (hasFollowingMessages) {
                // 有后续对话，显示确认对话框
                showConfirmDialog({
                    title: '重新生成确认',
                    message: '重新生成会删除当前回复及之后的所有对话。是否保存当前分支？',
                    buttons: [
                        {
                            text: '保存并重新生成',
                            className: 'primary',
                            action: async () => {
                                // 导出当前分支
                                exportCurrentBranch();
                                // 执行重新生成
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: '直接生成',
                            className: 'secondary',
                            action: async () => {
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: '取消',
                            className: 'cancel',
                            action: () => {
                                hideConfirmDialog();
                            }
                        }
                    ]
                });
            } else {
                // 是最后一条，直接重新生成
                await doRegenerate(bubbleIndex);
            }
        }
        
        /**
         * 执行重新生成（内部函数）
         */
        async function doRegenerate(bubbleIndex) {
            // 向上查找：找到本轮assistant回复的第一条
            // 即向上找到最后一个user气泡后的第一个assistant气泡
            let startIndex = bubbleIndex;
            
            // 向上遍历，找到同一组的第一个assistant
            while (startIndex > 0 && chatHistory[startIndex - 1].role === 'assistant') {
                startIndex--;
            }
            
            console.log('🔍 向上查找: 从索引', bubbleIndex, '找到第一个assistant在索引', startIndex);
            
            // 删除从startIndex开始的所有气泡（包括user和assistant）
            const bubblestoDelete = chatHistory.slice(startIndex);
            
            // 从UI删除
            bubblestoDelete.forEach(b => {
                const msgDiv = chatContainer.querySelector(`[data-bubble-id="${b.id}"]`);
                if (msgDiv) msgDiv.remove();
            });
            
            // 从数据删除
            chatHistory = chatHistory.slice(0, startIndex);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => 
                !bubblestoDelete.find(deleted => deleted.id === b.id)
            );
            saveChatHistory();
            
            console.log('🔄 重新生成，删除了', bubblestoDelete.length, '个气泡 (从索引', startIndex, '开始)');
            
            // 调用API
            await callAPIForRegeneration();
        }
        
        /**
         * 导出当前分支
         */
        function exportCurrentBranch() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `chat_branch_${timestamp}.json`;
            
            const dataStr = JSON.stringify(chatHistory, null, 2);
            
            // 检测是否为小米浏览器
            const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
            
            if (isMiuiBrowser) {
                console.log('🔍 检测到小米浏览器，使用 Blob URL 方案');
                
                try {
                    const blob = new Blob([dataStr], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    
                    alert('即将在新窗口打开分支数据\n\n保存方法：\n1. 在新页面点击"⋮"\n2. 选择"保存网页"\n3. 改名为：' + filename);
                    
                    const newWindow = window.open(url, '_blank');
                    
                    if (!newWindow) {
                        alert('⚠️ 无法打开新窗口，请允许弹出窗口权限');
                    } else {
                        showToast('分支已在新窗口打开');
                        console.log('💾 已导出分支:', filename);
                        setTimeout(() => URL.revokeObjectURL(url), 60000);
                    }
                    return;
                } catch (error) {
                    console.error('❌ Blob URL 方案失败:', error);
                    alert('导出失败：' + error.message);
                    return;
                }
            }
            
            // 非小米浏览器：使用标准方案
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('分支已保存');
            console.log('💾 已导出分支:', filename);
        }
        
        /**
         * 显示确认对话框
         */
        function showConfirmDialog({ title, message, buttons }) {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            const titleEl = document.getElementById('confirm-title');
            const messageEl = document.getElementById('confirm-message');
            const buttonsEl = document.getElementById('confirm-buttons');
            
            if (!dialog || !overlay) return;
            
            // 设置内容
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // 生成按钮
            buttonsEl.innerHTML = buttons.map((btn, idx) => `
                <button class="confirm-dialog-button ${btn.className}" data-btn-index="${idx}">
                    ${btn.text}
                </button>
            `).join('');
            
            // 绑定事件
            buttonsEl.querySelectorAll('button').forEach((btnEl, idx) => {
                btnEl.onclick = () => {
                    hideConfirmDialog();
                    if (buttons[idx].action) {
                        buttons[idx].action();
                    }
                };
            });
            
            // 显示
            overlay.classList.add('active');
            dialog.classList.add('active');
            
            // 点击遮罩关闭
            overlay.onclick = hideConfirmDialog;
        }
        
        /**
         * 隐藏确认对话框
         */
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            
            if (dialog) dialog.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }
        
        /**
         * 调用API重新生成
         */
        async function callAPIForRegeneration() {
            showTypingIndicator();
            
            try {
                const N = parseInt(localStorage.getItem('contextWindowSize')) || 50;
                const recentBubbles = chatHistory.slice(-N);
                const apiMessages = convertToAPIFormat(recentBubbles);
                
                let finalSystemPrompt = config.systemPrompt;
                
                // 添加长期记忆到系统提示
                if (longTermMemory && longTermMemory.metadata) {
                    let memoryPrompt = '\n\n=== 长期记忆 ===\n\n';
                    
                    // 添加基本信息
                    if (longTermMemory.basic_info && Object.keys(longTermMemory.basic_info).length > 0) {
                        memoryPrompt += '以下是用户的基本信息，你作为用户的爱人应该深深牢记，并且贴近用户的喜好，照顾用户所有需求：\n';
                        for (const [key, value] of Object.entries(longTermMemory.basic_info)) {
                            memoryPrompt += `${key}: ${value}\n`;
                        }
                        memoryPrompt += '\n';
                    }
                    
                    // 添加情感倾向
                    if (longTermMemory.emotional_profile) {
                        memoryPrompt += `性格: ${longTermMemory.emotional_profile}\n\n`;
                    }
                    
                    // 添加人际关系
                    if (longTermMemory.relationships) {
                        memoryPrompt += `人际关系: ${longTermMemory.relationships}\n\n`;
                    }
                    
                    // 添加所有记忆（按last_mentioned倒序）
                    if (longTermMemory.important_events && longTermMemory.important_events.length > 0) {
                        // 按last_mentioned倒序排序（最近的在前）
                        const sortedMemories = [...longTermMemory.important_events].sort((a, b) => 
                            new Date(b.last_mentioned) - new Date(a.last_mentioned)
                        );
                        
                        memoryPrompt += '以下是你和用户交互时，你产生的记忆片段和你对于事件的情绪，你应该深深记住并且基于以上事实对用户的最新消息进行回复（越靠前的记忆越重要）：\n\n';
                        
                        sortedMemories.forEach((m, i) => {
                            const date = new Date(m.last_mentioned).toLocaleDateString('zh-CN');
                            memoryPrompt += `${i + 1}. ${m.title}（${date}`;
                            if (m.mention_count) {
                                memoryPrompt += `，提及${m.mention_count}次`;
                            }
                            memoryPrompt += `）\n`;
                            memoryPrompt += `${m.content}\n`;
                            if (m.assistant_attitude) {
                                memoryPrompt += `你的态度: ${m.assistant_attitude}\n`;
                            }
                            memoryPrompt += '\n';
                        });
                    }
                    
                    memoryPrompt += '=== 记忆结束 ===\n';
                    finalSystemPrompt += memoryPrompt;
                }
                
                const now = new Date();
                const currentTimeStr = now.toLocaleString('zh-CN', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
                });
                finalSystemPrompt += `\n\n[当前时间]: ${currentTimeStr}`;
                
                const messagesWithTime = apiMessages.map(msg => {
                    if (msg.timestamp) {
                        const time = new Date(msg.timestamp);
                        const timeStr = time.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', hour12: false
                        });
                        return { role: msg.role, content: `[${timeStr}] ${msg.content}` };
                    }
                    return { role: msg.role, content: msg.content };
                });
                
                const messages = [
                    { role: "system", content: finalSystemPrompt },
                    ...messagesWithTime
                ];
                
                const response = await fetch(config.baseurl + '/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apikey}` },
                    body: JSON.stringify({ model: config.modelname, messages: messages })
                });
                
                const data = await response.json();
                hideTypingIndicator();
                
                if (data.choices && data.choices[0]) {
                    const aiResponseText = data.choices[0].message.content.trim();
                    processAndDisplaySegments(aiResponseText);
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('重新生成失败:', error);
                alert('重新生成失败');
            }
        }
        
        /**
         * 引用气泡
         */
        let currentQuote = null; // 当前引用的气泡
        
        function quoteBubble(bubble) {
            currentQuote = bubble;
            
            // 显示引用预览
            showQuotePreview(bubble);
            
            // 聚焦输入框
            userInput.focus();
            
            showToast('已引用该消息');
        }
        
        /**
         * 显示引用预览
         */
        function showQuotePreview(bubble) {
            const inputArea = document.getElementById('chat-input-area');
            
            // 移除已有的引用预览
            const existingQuote = inputArea.querySelector('.quote-reference');
            if (existingQuote) {
                existingQuote.remove();
            }
            
            // 获取发送者昵称
            const senderName = bubble.role === 'user' ? config.userNickname : config.aiNickname;
            
            // 创建引用预览元素 (微信风格：昵称：内容)
            const quoteDiv = document.createElement('div');
            quoteDiv.classList.add('quote-reference');
            quoteDiv.innerHTML = `
                <div class="quote-content">${escapeHtml(senderName)}：${escapeHtml(bubble.content)}</div>
                <span class="quote-close" onclick="clearQuote()">×</span>
            `;
            
            // 添加到输入区域底部 (textarea之后)
            const textarea = inputArea.querySelector('#user-input');
            inputArea.insertBefore(quoteDiv, textarea.nextSibling);
        }
        
        /**
         * 清除引用
         */
        function clearQuote() {
            currentQuote = null;
            const inputArea = document.getElementById('chat-input-area');
            const quoteDiv = inputArea.querySelector('.quote-reference');
            if (quoteDiv) {
                quoteDiv.remove();
            }
        }
        
        /**
         * HTML转义
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        /**
         * 编辑气泡
         */
        function editBubble(bubble) {
            // 找到对应的DOM元素
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            if (!messageDiv) {
                console.error('❌ 未找到气泡元素');
                return;
            }
            
            const bubbleDiv = messageDiv.querySelector('.bubble');
            if (!bubbleDiv) {
                console.error('❌ 未找到气泡内容元素');
                return;
            }
            
            // 保存原始内容和元素
            const originalContent = bubble.content;
            const originalHtml = bubbleDiv.innerHTML;
            
            // 标记为编辑状态
            bubbleDiv.classList.add('editing');
            
            // 创建编辑界面
            const textarea = document.createElement('textarea');
            textarea.classList.add('edit-textarea');
            textarea.value = originalContent;
            
            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('edit-buttons');
            
            const saveBtn = document.createElement('button');
            saveBtn.classList.add('edit-btn', 'save');
            saveBtn.textContent = '保存';
            
            const cancelBtn = document.createElement('button');
            cancelBtn.classList.add('edit-btn', 'cancel');
            cancelBtn.textContent = '取消';
            
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(cancelBtn);
            
            // 替换气泡内容
            bubbleDiv.innerHTML = '';
            bubbleDiv.appendChild(textarea);
            bubbleDiv.appendChild(buttonsDiv);
            
            // 自动聚焦并选中文本
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            
            // 取消按钮
            cancelBtn.onclick = () => {
                bubbleDiv.classList.remove('editing');
                bubbleDiv.innerHTML = originalHtml;
                
                // 重新绑定长按菜单
                setupLongPressMenu(bubbleDiv, bubble);
            };
            
            // 保存按钮
            saveBtn.onclick = async () => {
                const newContent = textarea.value.trim();
                
                if (!newContent) {
                    alert('内容不能为空');
                    return;
                }
                
                if (newContent === originalContent) {
                    // 内容未改变，直接取消
                    cancelBtn.click();
                    return;
                }
                
                // 根据角色处理不同的保存逻辑
                if (bubble.role === 'assistant') {
                    // AI消息：直接更新内容（不需要重新生成）
                    await saveEditedAIMessage(bubble, newContent, bubbleDiv, originalHtml);
                } else if (bubble.role === 'user') {
                    // 用户消息：必须重新生成
                    const bubbleIndex = chatHistory.findIndex(b => b.id === bubble.id);
                    if (bubbleIndex === -1) {
                        console.error('❌ 未找到气泡索引');
                        return;
                    }
                    
                    // 检查是否有后续消息
                    const hasFollowingMessages = bubbleIndex < chatHistory.length - 1;
                    
                    if (hasFollowingMessages) {
                        // 有后续消息，询问是否保存分支
                        showConfirmDialog({
                            title: '重新生成确认',
                            message: '编辑后将重新生成回复，这会删除此消息之后的所有对话。是否保存当前分支？',
                            buttons: [
                                {
                                    text: '保存分支并重新生成',
                                    className: 'primary',
                                    action: async () => {
                                        exportCurrentBranch();
                                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                                    }
                                },
                                {
                                    text: '直接重新生成',
                                    className: 'secondary',
                                    action: async () => {
                                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                                    }
                                },
                                {
                                    text: '取消',
                                    className: 'cancel',
                                    action: () => {
                                        // 恢复编辑界面
                                        const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
                                        const bubbleDiv = messageDiv?.querySelector('.bubble');
                                        if (bubbleDiv) {
                                            const textarea = bubbleDiv.querySelector('.edit-textarea');
                                            if (textarea) {
                                                textarea.value = newContent;
                                            }
                                        }
                                    }
                                }
                            ]
                        });
                    } else {
                        // 是最后一条，直接重新生成
                        await doEditAndRegenerate(bubble, bubbleIndex, newContent);
                    }
                }
            };
        }
        
        /**
         * 保存编辑后的AI消息
         */
        async function saveEditedAIMessage(bubble, newContent, bubbleDiv, originalHtml) {
            // 更新所有地方的内容
            bubble.content = newContent;
            
            // 更新chatHistory
            const historyIndex = chatHistory.findIndex(b => b.id === bubble.id);
            if (historyIndex !== -1) {
                chatHistory[historyIndex].content = newContent;
            }
            
            // 更新pendingSummaryBubbles
            const pendingIndex = pendingSummaryBubbles.findIndex(b => b.id === bubble.id);
            if (pendingIndex !== -1) {
                pendingSummaryBubbles[pendingIndex].content = newContent;
            }
            
            // 保存到localStorage
            saveChatHistory();
            
            // 更新UI
            bubbleDiv.classList.remove('editing');
            
            // 检测并解析引用
            let quotedText = null;
            let quotedSender = null;
            let mainText = newContent;
            const quoteMatch = newContent.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
            if (quoteMatch) {
                quotedSender = quoteMatch[1];
                quotedText = quoteMatch[2];
                mainText = quoteMatch[3];
            }
            
            // 保存meta信息
            const metaDiv = bubbleDiv.querySelector('.message-meta');
            const metaHtml = metaDiv ? metaDiv.outerHTML : '';
            
            // 清空并重建内容
            bubbleDiv.innerHTML = '';
            
            // 添加主要文本
            const mainTextNode = document.createTextNode(mainText);
            bubbleDiv.appendChild(mainTextNode);
            
            // 恢复meta信息
            if (metaHtml) {
                bubbleDiv.insertAdjacentHTML('beforeend', metaHtml);
            }
            
            // 【修改】如果有引用，添加到contentWrapper（气泡外）
            const contentWrapper = messageDiv.querySelector('.message-content-wrapper');
            if (quotedText && quotedSender && contentWrapper) {
                // 先移除旧的引用（如果有）
                const oldQuote = contentWrapper.querySelector('.quoted-message');
                if (oldQuote) oldQuote.remove();
                
                const quotedDiv = document.createElement('div');
                quotedDiv.classList.add('quoted-message');
                
                const senderSpan = document.createElement('span');
                senderSpan.classList.add('quote-sender');
                senderSpan.textContent = quotedSender + '：';
                
                quotedDiv.appendChild(senderSpan);
                quotedDiv.appendChild(document.createTextNode(quotedText));
                
                contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper
            }
            
            // 重新绑定长按菜单
            setupLongPressMenu(bubbleDiv, bubble);
            
            showToast('已保存');
            console.log('✅ AI消息已更新:', bubble.id);
        }
        
        /**
         * 执行编辑并重新生成
         */
        async function doEditAndRegenerate(bubble, bubbleIndex, newContent) {
            // 更新消息内容
            bubble.content = newContent;
            chatHistory[bubbleIndex].content = newContent;
            
            // 更新UI
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            const bubbleDiv = messageDiv?.querySelector('.bubble');
            if (bubbleDiv) {
                bubbleDiv.classList.remove('editing');
                
                // 检测并解析引用
                let quotedText = null;
                let quotedSender = null;
                let mainText = newContent;
                const quoteMatch = newContent.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
                if (quoteMatch) {
                    quotedSender = quoteMatch[1];
                    quotedText = quoteMatch[2];
                    mainText = quoteMatch[3];
                }
                
                // 保存meta信息
                const metaDiv = bubbleDiv.querySelector('.message-meta');
                const metaHtml = metaDiv ? metaDiv.outerHTML : '';
                
                // 清空并重建内容
                bubbleDiv.innerHTML = '';
                
                // 添加主要文本
                const mainTextNode = document.createTextNode(mainText);
                bubbleDiv.appendChild(mainTextNode);
                
                // 恢复meta信息
                if (metaHtml) {
                    bubbleDiv.insertAdjacentHTML('beforeend', metaHtml);
                }
                
                // 【修改】如果有引用，添加到contentWrapper（气泡外）
                const contentWrapper = messageDiv.querySelector('.message-content-wrapper');
                if (quotedText && quotedSender && contentWrapper) {
                    // 先移除旧的引用（如果有）
                    const oldQuote = contentWrapper.querySelector('.quoted-message');
                    if (oldQuote) oldQuote.remove();
                    
                    const quotedDiv = document.createElement('div');
                    quotedDiv.classList.add('quoted-message');
                    
                    const senderSpan = document.createElement('span');
                    senderSpan.classList.add('quote-sender');
                    senderSpan.textContent = quotedSender + '：';
                    
                    quotedDiv.appendChild(senderSpan);
                    quotedDiv.appendChild(document.createTextNode(quotedText));
                    
                    contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper
                }
                
                // 重新绑定长按菜单
                setupLongPressMenu(bubbleDiv, bubble);
            }
            
            // 【优化的删除逻辑】
            // 1. 向后延伸：保留当前编辑气泡之后的所有连续user气泡
            let keepUntilIndex = bubbleIndex; // 默认保留到当前编辑的气泡
            
            for (let i = bubbleIndex + 1; i < chatHistory.length; i++) {
                if (chatHistory[i].role === 'user') {
                    // 如果是用户气泡，继续向后保留
                    keepUntilIndex = i;
                } else {
                    // 遇到第一个非用户气泡(assistant)，停止
                    break;
                }
            }
            
            console.log(`📝 编辑逻辑：保留气泡 0-${keepUntilIndex}，删除气泡 ${keepUntilIndex + 1}-${chatHistory.length - 1}`);
            
            // 2. 删除从第一个assistant开始的所有消息
            const bubblestoDelete = chatHistory.slice(keepUntilIndex + 1);
            
            // 从UI删除
            bubblestoDelete.forEach(b => {
                const msgDiv = chatContainer.querySelector(`[data-bubble-id="${b.id}"]`);
                if (msgDiv) msgDiv.remove();
            });
            
            // 从数据删除
            chatHistory = chatHistory.slice(0, keepUntilIndex + 1);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => 
                !bubblestoDelete.find(deleted => deleted.id === b.id)
            );
            
            // 保存
            saveChatHistory();
            
            showToast('正在重新生成...');
            console.log('🔄 编辑后重新生成，删除了', bubblestoDelete.length, '个气泡');
            
            // 调用API重新生成
            await callAPIForRegeneration();
        }
        
        // ========== 长期记忆功能 ==========
        
        /**
         * 更新记忆状态显示
         */
        function updateMemoryStatus() {
            const autoSummaryInterval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            const totalBubbles = chatHistory.length;
            const pendingBubbles = pendingSummaryBubbles.length;
            const eventsCount = longTermMemory.important_events?.length || 0;
            const lastSummaryAt = longTermMemory.metadata?.last_summary_at || 0;
            const lastUpdated = longTermMemory.metadata?.last_updated;
            
            // 更新DOM（如果元素存在）
            const totalEl = document.getElementById('total-bubbles-count');
            const pendingEl = document.getElementById('pending-bubbles-count');
            const eventsEl = document.getElementById('events-count');
            const lastTimeEl = document.getElementById('last-summary-time');
            const untilNextEl = document.getElementById('bubbles-until-next');
            
            if (totalEl) totalEl.textContent = totalBubbles;
            if (pendingEl) pendingEl.textContent = pendingBubbles;
            if (eventsEl) eventsEl.textContent = eventsCount;
            
            if (lastTimeEl) {
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    lastTimeEl.textContent = date.toLocaleString('zh-CN');
                } else {
                    lastTimeEl.textContent = '从未';
                }
            }
            
            if (untilNextEl) {
                const remaining = autoSummaryInterval - pendingBubbles;
                if (remaining > 0) {
                    untilNextEl.textContent = remaining;
                } else {
                    untilNextEl.textContent = '已达到，将在下次回复后触发';
                }
            }
        }
        
        /**
         * 生成记忆总结
         * @param {boolean} manual - 是否为手动触发
         */
        async function generateMemorySummary(manual = false) {
            // 【新增】先清理已被删除的pending气泡
            const validPendingBubbles = pendingSummaryBubbles.filter(pendingBubble => {
                return chatHistory.some(historyBubble => historyBubble.id === pendingBubble.id);
            });
            
            if (validPendingBubbles.length !== pendingSummaryBubbles.length) {
                const removedCount = pendingSummaryBubbles.length - validPendingBubbles.length;
                console.log(`🗑️ 生成记忆前清理了 ${removedCount} 个已删除的pending气泡`);
                pendingSummaryBubbles = validPendingBubbles;
            }
            
            // 检查是否有待总结的内容
            if (pendingSummaryBubbles.length === 0) {
                if (manual) {
                    alert('当前没有新的对话需要总结！');
                }
                console.log('⚠️ 没有有效的pending气泡，跳过记忆生成');
                return;
            }
            
            // 检查API配置
            if (!config.baseurl || !config.apikey || !config.modelname) {
                alert('请先配置API！');
                return;
            }
            
            if (manual) {
                if (!confirm(`将总结最近 ${pendingSummaryBubbles.length} 个气泡的内容，生成长期记忆。是否继续？`)) {
                    return;
                }
            }
            
            try {
                // 显示加载提示
                const loadingMsg = manual ? '正在生成记忆总结，请稍候...' : '后台更新长期记忆...';
                showToast(loadingMsg);
                
                // 【关键优化】向后延伸，确保最后一条消息是完整的
                let bubblesToSummarize = extendForward(pendingSummaryBubbles, chatHistory);
                console.log('📍 记忆生成：原始', pendingSummaryBubbles.length, '条 → 延伸后', bubblesToSummarize.length, '条');
                
                // 准备对话内容
                const conversationText = bubblesToSummarize.map(b => {
                    const time = new Date(b.timestamp).toLocaleString('zh-CN');
                    const speaker = b.role === 'user' ? config.userNickname : config.aiNickname;
                    return `[${time}] ${speaker}: ${b.content}`;
                }).join('\n\n');
                
                // 获取对话时间范围
                const firstTimestamp = bubblesToSummarize[0]?.timestamp;
                const lastTimestamp = bubblesToSummarize[bubblesToSummarize.length - 1]?.timestamp;
                const timeRange = `${new Date(firstTimestamp).toLocaleString('zh-CN')} 至 ${new Date(lastTimestamp).toLocaleString('zh-CN')}`;
                
                // 构建已有记忆的详细上下文
                const existingMemoriesContext = longTermMemory.important_events.map(m => 
                    `[${m.memory_id}] ${m.title} (${m.type})
   当前重要度: ${m.importance}分
   提及次数: ${m.mention_count}次
   最后提及: ${new Date(m.last_mentioned).toLocaleString('zh-CN')}
   内容预览: ${m.content.substring(0, 100)}...`
                ).join('\n\n');
                
                // 构建总结prompt
                const summaryPrompt = `你的任务：从对话中提取或更新长期记忆。

【对话时间范围】
${timeRange}
气泡数量：${bubblesToSummarize.length}个

【当前已有的基本信息】
${Object.keys(longTermMemory.basic_info).length > 0 ? JSON.stringify(longTermMemory.basic_info, null, 2) : '无'}

【当前已有的情感倾向】
${longTermMemory.emotional_profile || '无'}

【当前已有的重要事件】
${existingMemoriesContext || '无'}

【新对话记录】
${conversationText}

【任务要求】
每次生成必须完成三个判断：

1. 基本信息更新判断
   - 是否有新的基本信息（姓名、年龄、职业、居住地、外貌特征、兴趣爱好等）？
   - 如果有，输出需要更新的字段；如果无，输出null

2. 情感倾向更新判断
   - 是否需要更新用户的性格特点、情感倾向描述？
   - 如果需要，输出完整的新描述（100-300字）；如果不需要，输出null

3. 重要事件处理（只生成0或1条）
   - 优先判断：是否在延续/更新已有记忆？
     * 如果是，输出 action: "update"
   - 其次判断：是否有值得记录的新话题？
     * 如果是，输出 action: "create"
   - 最后：如果都不是（日常寒暄、无关紧要）
     * 输出 action: "skip"

【重要事件处理规则】

优先匹配已有记忆！判断标准：
- 话题是否相关？（如：都在讨论健康问题、工作问题）
- 时间是否接近？（3天内的同类话题优先匹配）
- 是否是事件的延续？（如：面试→等结果→收到offer）

只在确实无法匹配时才创建新记忆！

【输出格式】（纯JSON，无markdown代码块）
{
  "basic_info_updates": {
    "职业": "程序员",
    "居住地": "北京"
  } 或 null,
  
  "emotional_profile_update": "完整的情感倾向描述" 或 null,
  
  "memory_action": {
    "action": "update" 或 "create" 或 "skip",
    
    // 如果 action 是 "update"
    "memory_id": "mem_003",
    "new_content": "具体新增内容（带日期）",
    "assistant_attitude": "当前态度" 或 "旧态度(日期) → 新态度(日期)",
    "new_importance": 数字,
    
    // 如果 action 是 "create"  
    "title": "3-6字主题",
    "type": "personal" 或 "relationship",
    "content": "完整内容（带日期）",
    "assistant_attitude": "我的态度",
    "importance": 数字,
    
    // 如果 action 是 "skip"
    "reason": "简短说明"
  }
}

【重要度评分标准】严格执行！
10分：改变人生的重大事件（结婚、生子、亲人离世）
9分：重大转折点（辞职、确诊重病、表白成功）
8分：重要里程碑（升职、毕业、买房）
7分：值得庆祝的成就（考试通过、项目成功）
6分：需要关注的问题（健康问题、矛盾冲突）
5分：一般重要事项（计划旅行、买了重要物品）
4分：日常但有意义（见了朋友、看了好电影）
3分：轻度值得记录（换了发型、尝试新餐厅）
2分：日常琐事（迟到、忘带东西）
1分：完全不重要（天气、随口一说）

【常见错误示例 - 避免打分虚高】
❌ "今天早上迟到了" → 不要评8分，应该是2分
❌ "很想你" → 不要评9分，日常表达感情是4-5分
❌ "吃了好吃的火锅" → 不要评7分，应该是3分
❌ "换了新发型" → 不要评6分，应该是3分

【频率折扣规则】
如果是更新已有记忆，查看 mention_count（提及次数）：
- 第1次：基础分 + 2分（首次奖励）
- 第2次：基础分
- 第3-5次：基础分 - 1分
- 第6-10次：基础分 - 2分
- 第10次以上：基础分 - 3分（已成日常）

【频率折扣不适用】的情况（有实质性进展）：
- 疾病治疗过程（每次都是新进展）
- 重大计划推进（创业、结婚筹备、买房）
- 学业/项目进展（考研、写论文、开发项目）
- 关系修复过程（矛盾→沟通→和解）

【频率折扣应用】的情况（重复抱怨）：
- 重复抱怨（天天说分手但不行动）
- 口头承诺（总说要减肥/戒烟但没执行）
- 情绪发泄（每天抱怨同样的事）

【assistant_attitude规范】
- 记录你（AI）对这个记忆的情感态度
- 如果本次是第一次提及：直接写态度（如"关心"）
- 如果是更新已有记忆且态度有变化：用"→"连接并标注日期
  格式：旧态度(MM/DD) → 新态度(MM/DD)
  例如：关心(12/10) → 担心(12/22) → 放心(12/28)
- 常见态度词：关心、担心、开心、难过、生气、理解、共情、鼓励、安慰、支持、骄傲、遗憾

【title命名规范】
- 3-6个汉字
- 格式：领域-具体事件
- 例如：工作-升职、健康-胃病、感情-吵架、生活-搬家
- 避免太宽泛（如"工作"）或太具体（如"2025年12月10日腹痛"）

【内容格式规范】
- 每句话后标注日期：(MM/DD) 或 (YYYY/MM/DD)
- 简洁表达，不超过200字
- 例如：腹痛比较严重（12/10）。去医院做了检查（12/22）。确诊为慢性胃炎（12/28）。

【输出格式】（纯JSON，不要markdown代码块标记）
{
  "basic_info_updates": {
    "职业": "程序员"
  } 或 null,
  
  "emotional_profile_update": "完整的情感倾向描述" 或 null,
  
  "memory_action": {
    "action": "update" 或 "create" 或 "skip",
    
    // 如果 action 是 "update"
    "memory_id": "mem_003",
    "new_content": "具体新增内容（带日期）",
    "assistant_attitude": "当前态度" 或 "旧态度(日期) → 新态度(日期)",
    "new_importance": 数字,
    
    // 如果 action 是 "create"  
    "title": "3-6字主题",
    "type": "personal" 或 "relationship",
    "content": "完整内容（带日期）",
    "assistant_attitude": "我的态度",
    "importance": 数字,
    
    // 如果 action 是 "skip"
    "reason": "简短说明"
  }
}`;
                
                // 调用API
                const response = await fetch(config.baseurl + '/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify({
                        model: config.modelname,
                        messages: [
                            { role: 'system', content: '你是一个专业的记忆整理助手，擅长提取和总结对话中的关键信息。请严格按照要求输出纯JSON格式。' },
                            { role: 'user', content: summaryPrompt }
                        ],
                        temperature: 0.3
                    })
                });
                
                const data = await response.json();
                
                if (data.choices && data.choices[0]) {
                    let aiResponse = data.choices[0].message.content.trim();
                    
                    // 移除可能的markdown代码块标记
                    aiResponse = aiResponse.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
                    
                    // 解析JSON
                    const result = JSON.parse(aiResponse);
                    
                    console.log('🧠 AI返回结果:', result);
                    
                    // 1. 处理基本信息更新
                    if (result.basic_info_updates) {
                        for (const [key, value] of Object.entries(result.basic_info_updates)) {
                            longTermMemory.basic_info[key] = value;
                        }
                        console.log('📝 更新基本信息:', result.basic_info_updates);
                    }
                    
                    // 2. 处理情感倾向更新
                    if (result.emotional_profile_update) {
                        longTermMemory.emotional_profile = result.emotional_profile_update;
                        console.log('💭 更新情感倾向');
                    }
                    
                    // 3. 处理重要事件
                    const memoryAction = result.memory_action;
                    
                    if (memoryAction.action === "update") {
                        // 更新已有记忆
                        const memory = longTermMemory.important_events.find(m => m.memory_id === memoryAction.memory_id);
                        if (memory) {
                            memory.content += " " + memoryAction.new_content;
                            memory.last_mentioned = lastTimestamp;
                            memory.mention_count++;
                            memory.assistant_attitude = memoryAction.assistant_attitude;
                            memory.importance = memoryAction.new_importance;
                            console.log('🔄 更新记忆:', memoryAction.memory_id, memory.title);
                        } else {
                            console.warn('⚠️ 未找到要更新的记忆:', memoryAction.memory_id);
                        }
                        
                    } else if (memoryAction.action === "create") {
                        // 创建新记忆
                        const newMemory = {
                            memory_id: "mem_" + String(longTermMemory.metadata.next_memory_id).padStart(3, '0'),
                            type: memoryAction.type,
                            title: memoryAction.title,
                            created_at: firstTimestamp,
                            last_mentioned: lastTimestamp,
                            mention_count: 1,
                            content: memoryAction.content,
                            assistant_attitude: memoryAction.assistant_attitude,
                            importance: memoryAction.importance
                        };
                        
                        longTermMemory.important_events.push(newMemory);
                        longTermMemory.metadata.next_memory_id++;
                        
                        console.log('✨ 创建新记忆:', newMemory.memory_id, newMemory.title);
                        
                    } else if (memoryAction.action === "skip") {
                        console.log('⏭️ 跳过记忆生成:', memoryAction.reason);
                    }
                    
                    // 按重要度排序，保留最重要的N条
                    const maxEvents = parseInt(localStorage.getItem('maxImportantEvents')) || 10;
                    longTermMemory.important_events.sort((a, b) => b.importance - a.importance);
                    if (longTermMemory.important_events.length > maxEvents) {
                        const removed = longTermMemory.important_events.splice(maxEvents);
                        console.log('🗑️ 移除低重要度记忆:', removed.map(m => m.title).join(', '));
                    }
                    
                    // 更新元数据
                    longTermMemory.metadata = {
                        total_messages: chatHistory.length,
                        last_summary_at: chatHistory.length,
                        last_updated: new Date().toISOString(),
                        version: 2,
                        next_memory_id: longTermMemory.metadata.next_memory_id
                    };
                    
                    // 清空待总结缓冲区
                    pendingSummaryBubbles = [];
                    
                    // 保存
                    saveChatHistory();
                    
                    // 更新UI
                    updateMemoryStatus();
                    
                    // 回填基本信息到输入框
                    fillBasicInfoInputs();
                    
                    if (manual) {
                        showToast('✅ 记忆总结完成！');
                        alert(`记忆总结成功！\n\n重要事件数：${longTermMemory.important_events?.length || 0} 条`);
                    } else {
                        showToast('✅ 长期记忆已更新');
                    }
                    
                    console.log('🧠 长期记忆已更新:', longTermMemory);
                } else {
                    throw new Error('API返回格式错误');
                }
                
            } catch (error) {
                console.error('❌ 生成记忆失败:', error);
                if (manual) {
                    alert('生成记忆失败：' + error.message);
                }
            }
        }
        
        /**
         * 检查是否需要自动生成记忆
         */
        function checkAutoSummary() {
            const autoSummaryInterval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 【新增检查】清理已被删除的pending气泡
            // 如果pending气泡不在chatHistory中，说明已被删除，应该移除
            const validPendingBubbles = pendingSummaryBubbles.filter(pendingBubble => {
                return chatHistory.some(historyBubble => historyBubble.id === pendingBubble.id);
            });
            
            // 如果发现有被删除的气泡，更新pendingSummaryBubbles
            if (validPendingBubbles.length !== pendingSummaryBubbles.length) {
                const removedCount = pendingSummaryBubbles.length - validPendingBubbles.length;
                console.log(`🗑️ 清理了 ${removedCount} 个已删除的pending气泡`);
                pendingSummaryBubbles = validPendingBubbles;
                saveChatHistory(); // 保存更新后的pending列表
            }
            
            // 检查是否达到自动总结条件（使用清理后的列表）
            if (pendingSummaryBubbles.length >= autoSummaryInterval) {
                console.log('🧠 达到自动总结条件，开始生成记忆...');
                // 异步执行，不阻塞主流程
                setTimeout(() => generateMemorySummary(false), 1000);
            } else if (pendingSummaryBubbles.length > 0) {
                console.log(`📊 当前pending: ${pendingSummaryBubbles.length}/${autoSummaryInterval} 个气泡`);
            }
        }
        
        /**
         * 回填基本信息到输入框（从长期记忆中读取）
         */
        function fillBasicInfoInputs() {
            const nameEl = document.getElementById('memory-name');
            const ageEl = document.getElementById('memory-age');
            const occupationEl = document.getElementById('memory-occupation');
            const locationEl = document.getElementById('memory-location');
            const appearanceEl = document.getElementById('memory-appearance');
            const interestsEl = document.getElementById('memory-interests');
            
            if (nameEl && longTermMemory.basic_info?.姓名) {
                nameEl.value = longTermMemory.basic_info.姓名;
            }
            if (ageEl && longTermMemory.basic_info?.年龄) {
                ageEl.value = longTermMemory.basic_info.年龄;
            }
            if (occupationEl && longTermMemory.basic_info?.职业) {
                occupationEl.value = longTermMemory.basic_info.职业;
            }
            if (locationEl && longTermMemory.basic_info?.居住地) {
                locationEl.value = longTermMemory.basic_info.居住地;
            }
            if (appearanceEl && longTermMemory.basic_info?.外貌特征) {
                appearanceEl.value = longTermMemory.basic_info.外貌特征;
            }
            if (interestsEl && longTermMemory.basic_info?.兴趣爱好) {
                interestsEl.value = longTermMemory.basic_info.兴趣爱好;
            }
        }
        
        /**
         * 保存基本信息
         */
        function saveBasicInfo() {
            const name = document.getElementById('memory-name').value.trim();
            const age = document.getElementById('memory-age').value.trim();
            const occupation = document.getElementById('memory-occupation').value.trim();
            const location = document.getElementById('memory-location').value.trim();
            const appearance = document.getElementById('memory-appearance').value.trim();
            const interests = document.getElementById('memory-interests').value.trim();
            
            // 更新长期记忆的基本信息
            if (name) longTermMemory.basic_info.姓名 = name;
            if (age) longTermMemory.basic_info.年龄 = age;
            if (occupation) longTermMemory.basic_info.职业 = occupation;
            if (location) longTermMemory.basic_info.居住地 = location;
            if (appearance) longTermMemory.basic_info.外貌特征 = appearance;
            if (interests) longTermMemory.basic_info.兴趣爱好 = interests;
            
            // 如果有任何信息被填写，更新元数据
            if (name || age || occupation || location || appearance || interests) {
                if (!longTermMemory.metadata.last_updated) {
                    longTermMemory.metadata.last_updated = new Date().toISOString();
                }
            }
            
            saveChatHistory();
            updateMemoryStatus();
            
            showToast('✅ 基本信息已保存');
        }
        
        /**
         * 编辑记忆（打开编辑模态窗口）
         */
        function editMemory() {
            const modal = document.getElementById('memory-edit-modal');
            
            // 填充基本信息
            const basicInfoEditor = document.getElementById('basic-info-editor');
            const basicInfoFields = [
                { key: '姓名', placeholder: '例如：小明' },
                { key: '年龄', placeholder: '例如：25' },
                { key: '职业', placeholder: '例如：程序员' },
                { key: '居住地', placeholder: '例如：北京' },
                { key: '性别', placeholder: '例如：男/女' },
                { key: '外貌特征', placeholder: '例如：高个子、短发' },
                { key: '兴趣爱好', placeholder: '例如：编程、游戏' }
            ];
            
            basicInfoEditor.innerHTML = basicInfoFields.map(field => {
                const value = longTermMemory.basic_info[field.key] || '';
                return `
                    <div class="basic-info-item">
                        <label>${field.key}：</label>
                        <input type="text" data-key="${field.key}" value="${value}" placeholder="${field.placeholder}">
                    </div>
                `;
            }).join('');
            
            // 填充情感倾向
            document.getElementById('emotional-profile-editor').value = longTermMemory.emotional_profile || '';
            
            // 填充重要事件
            renderEventsEditor();
            
            // 显示模态窗口
            modal.style.display = 'flex';
        }
        
        /**
         * 渲染记忆片段历史
         */
        
        /**
         * 渲染事件编辑器
         */
        function renderEventsEditor() {
            const eventsEditor = document.getElementById('events-editor');
            const events = longTermMemory.important_events || [];
            
            if (events.length === 0) {
                eventsEditor.innerHTML = '<p style="color: #999; font-size: 14px;">暂无重要事件</p>';
                return;
            }
            
            eventsEditor.innerHTML = events.map((event, index) => {
                const eventType = event.type || 'personal';
                const createdDate = new Date(event.created_at).toLocaleDateString('zh-CN');
                const lastMentioned = new Date(event.last_mentioned).toLocaleDateString('zh-CN');
                
                return `
                <div class="event-item" data-index="${index}">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; gap: 10px;">
                        <div style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <strong style="color: #999; font-size: 12px;">${event.memory_id}</strong>
                            <input type="text" value="${event.title}" onchange="updateEventTitle(${index}, this.value)" placeholder="事件主题" style="flex: 1; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-weight: 500;">
                        </div>
                        <div style="font-size: 12px; color: #999; white-space: nowrap;">
                            提及 ${event.mention_count} 次
                        </div>
                    </div>
                    <div class="event-item-header">
                        <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                            <div>
                                <label style="font-size: 12px; color: #666;">类型：</label>
                                <select onchange="updateEventType(${index}, this.value)" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                                    <option value="personal" ${eventType === 'personal' ? 'selected' : ''}>👤 个人</option>
                                    <option value="relationship" ${eventType === 'relationship' ? 'selected' : ''}>❤️ 感情</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">创建：</label>
                                <span style="font-size: 12px;">${createdDate}</span>
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">最后提及：</label>
                                <span style="font-size: 12px;">${lastMentioned}</span>
                            </div>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <div class="event-item-importance">
                                <label>重要度：</label>
                                <input type="number" min="1" max="10" value="${event.importance}" onchange="updateEventImportance(${index}, this.value)">
                            </div>
                            <button class="event-item-delete" onclick="deleteEvent(${index})">删除</button>
                        </div>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">内容：</label>
                        <textarea rows="3" placeholder="记忆内容（带日期标注）" onchange="updateEventContent(${index}, this.value)" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; box-sizing: border-box;">${event.content || ''}</textarea>
                    </div>
                    <div style="margin-top: 8px;">
                        <label style="font-size: 12px; color: #666; display: block; margin-bottom: 4px;">AI态度：</label>
                        <input type="text" value="${event.assistant_attitude || ''}" onchange="updateEventAttitude(${index}, this.value)" placeholder="例如：关心、担心" style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; box-sizing: border-box;">
                    </div>
                </div>
            `;
            }).join('');
        }
        
        /**
         * 更新事件类型
         */
        function updateEventType(index, type) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].type = type;
            }
        }
        
        /**
         * 更新事件标题
         */
        function updateEventTitle(index, title) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].title = title;
            }
        }
        
        /**
         * 更新事件重要度
         */
        function updateEventImportance(index, importance) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].importance = parseInt(importance) || 5;
            }
        }
        
        /**
         * 更新事件内容
         */
        function updateEventContent(index, content) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].content = content;
            }
        }
        
        /**
         * 更新事件AI态度
         */
        function updateEventAttitude(index, attitude) {
            if (longTermMemory.important_events[index]) {
                longTermMemory.important_events[index].assistant_attitude = attitude;
            }
        }
        
        /**
         * 删除事件
         */
        function deleteEvent(index) {
            if (confirm('确定要删除这个事件吗？')) {
                longTermMemory.important_events.splice(index, 1);
                renderEventsEditor();
            }
        }
        
        /**
         * 添加新事件
         */
        function addNewEvent() {
            const now = new Date().toISOString();
            const newEvent = {
                memory_id: "mem_" + String(longTermMemory.metadata.next_memory_id).padStart(3, '0'),
                type: 'personal',
                title: '新事件',
                created_at: now,
                last_mentioned: now,
                mention_count: 1,
                content: '',
                assistant_attitude: '',
                importance: 5
            };
            
            if (!longTermMemory.important_events) {
                longTermMemory.important_events = [];
            }
            
            longTermMemory.important_events.push(newEvent);
            longTermMemory.metadata.next_memory_id++;
            renderEventsEditor();
        }
        
        /**
         * 保存记忆编辑
         */
        function saveMemoryEdit() {
            // 保存基本信息
            const basicInfoInputs = document.querySelectorAll('#basic-info-editor input');
            basicInfoInputs.forEach(input => {
                const key = input.getAttribute('data-key');
                const value = input.value.trim();
                if (value) {
                    longTermMemory.basic_info[key] = value;
                } else {
                    delete longTermMemory.basic_info[key];
                }
            });
            
            // 保存情感倾向
            longTermMemory.emotional_profile = document.getElementById('emotional-profile-editor').value.trim();
            
            // 更新元数据
            longTermMemory.metadata.last_updated = new Date().toISOString();
            
            // 保存到本地存储
            saveChatHistory();
            updateMemoryStatus();
            
            // 关闭模态窗口
            closeMemoryEdit();
            
            showToast('✅ 记忆已保存');
        }
        
        /**
         * 关闭记忆编辑模态窗口
         */
        function closeMemoryEdit() {
            const modal = document.getElementById('memory-edit-modal');
            modal.style.display = 'none';
        }
        
        /**
         * 清空记忆
         */
        function clearMemory() {
            if (!confirm('确定要清空所有长期记忆吗？此操作不可恢复！')) {
                return;
            }
            
            longTermMemory = {
                basic_info: {},
                emotional_profile: "",
                important_events: [],
                metadata: {
                    total_messages: 0,
                    last_summary_at: 0,
                    last_updated: null,
                    version: 2,
                    next_memory_id: 1
                }
            };
            
            pendingSummaryBubbles = [];
            
            saveChatHistory();
            updateMemoryStatus();
            
            alert('✅ 长期记忆已清空！');
        }
        
        // ========== 批量生成功能 ==========
        
        /**
         * 显示批量生成对话框
         */
        function showBatchGenerateDialog() {
            const dialog = document.getElementById('batch-generate-dialog');
            const totalBubbles = chatHistory.length;
            const alreadySummarized = longTermMemory.metadata?.last_summary_at || 0;
            const pendingBubbles = pendingSummaryBubbles.length;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 更新统计信息
            document.getElementById('batch-total-bubbles').textContent = totalBubbles;
            document.getElementById('batch-already-summarized').textContent = alreadySummarized;
            document.getElementById('batch-pending-bubbles').textContent = pendingBubbles;
            document.getElementById('batch-interval').textContent = interval;
            
            // 计算默认的API调用次数（仅待总结部分）
            const defaultApiCalls = Math.ceil(pendingBubbles / interval);
            document.getElementById('batch-api-calls').textContent = defaultApiCalls;
            document.getElementById('batch-estimated-time').textContent = Math.ceil(defaultApiCalls * 0.5); // 假设每次30秒
            
            // 监听单选按钮变化
            const radios = document.querySelectorAll('input[name="batch-mode"]');
            radios.forEach(radio => {
                radio.onchange = () => updateBatchEstimate();
            });
            
            // 监听最近N条输入框变化
            const recentCountInput = document.getElementById('batch-recent-count');
            recentCountInput.oninput = () => {
                if (document.querySelector('input[name="batch-mode"]:checked').value === 'recent') {
                    updateBatchEstimate();
                }
            };
            
            // 重置进度
            document.getElementById('batch-progress').style.display = 'none';
            document.getElementById('batch-start-btn').disabled = false;
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 更新批量生成估算
         */
        function updateBatchEstimate() {
            const mode = document.querySelector('input[name="batch-mode"]:checked').value;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            const totalBubbles = chatHistory.length;
            const alreadySummarized = longTermMemory.metadata?.last_summary_at || 0;
            const pendingBubbles = pendingSummaryBubbles.length;
            
            let bubblesCount = 0;
            
            switch (mode) {
                case 'pending':
                    bubblesCount = pendingBubbles;
                    break;
                case 'all':
                    bubblesCount = totalBubbles;
                    break;
                case 'recent':
                    const recentCount = parseInt(document.getElementById('batch-recent-count').value) || 500;
                    bubblesCount = Math.min(recentCount, totalBubbles);
                    break;
            }
            
            const apiCalls = Math.ceil(bubblesCount / interval);
            const estimatedMinutes = Math.ceil(apiCalls * 0.5);
            
            document.getElementById('batch-api-calls').textContent = apiCalls;
            document.getElementById('batch-estimated-time').textContent = estimatedMinutes;
        }
        
        /**
         * 关闭批量生成对话框
         */
        function closeBatchGenerateDialog() {
            const dialog = document.getElementById('batch-generate-dialog');
            dialog.style.display = 'none';
        }
        
        /**
         * 开始批量生成
         */
        async function startBatchGenerate() {
            const mode = document.querySelector('input[name="batch-mode"]:checked').value;
            const interval = parseInt(localStorage.getItem('autoSummaryInterval')) || 50;
            
            // 确定要处理的气泡范围
            let bubblesToProcess = [];
            let shouldClearMemory = false; // 是否清空现有记忆
            
            switch (mode) {
                case 'pending':
                    // 仅处理待总结的
                    bubblesToProcess = [...pendingSummaryBubbles];
                    break;
                    
                case 'all':
                    // 从头开始 - 显示选择对话框
                    const allModeChoice = await showBatchGenerateModeDialog('all', chatHistory.length);
                    if (!allModeChoice) return; // 用户取消
                    
                    shouldClearMemory = (allModeChoice === 'replace');
                    if (shouldClearMemory) {
                        longTermMemory = {
                            basic_info: {},
                            emotional_profile: "",
                            important_events: [],
                            metadata: {
                                total_messages: 0,
                                last_summary_at: 0,
                                last_updated: null,
                                version: 2,
                                next_memory_id: 1
                            }
                        };
                    }
                    bubblesToProcess = [...chatHistory];
                    break;
                    
                case 'recent':
                    // 从最近N条开始
                    const recentCount = parseInt(document.getElementById('batch-recent-count').value) || 500;
                    const startIndex = Math.max(0, chatHistory.length - recentCount);
                    
                    // 显示选择对话框
                    const recentModeChoice = await showBatchGenerateModeDialog('recent', recentCount);
                    if (!recentModeChoice) return; // 用户取消
                    
                    shouldClearMemory = (recentModeChoice === 'replace');
                    if (shouldClearMemory) {
                        longTermMemory = {
                            basic_info: {},
                            emotional_profile: "",
                            important_events: [],
                            metadata: {
                                total_messages: 0,
                                last_summary_at: 0,
                                last_updated: null,
                                version: 2,
                                next_memory_id: 1
                            }
                        };
                    }
                    bubblesToProcess = chatHistory.slice(startIndex);
                    break;
            }
            
            if (bubblesToProcess.length === 0) {
                alert('没有需要处理的气泡！');
                return;
            }
            
            // 显示进度
            const progressDiv = document.getElementById('batch-progress');
            const progressBar = document.getElementById('batch-progress-bar');
            const progressText = document.getElementById('batch-progress-text');
            const statusText = document.getElementById('batch-current-status');
            const startBtn = document.getElementById('batch-start-btn');
            
            progressDiv.style.display = 'block';
            startBtn.disabled = true;
            startBtn.textContent = '生成中...';
            
            // 分批处理
            const totalBatches = Math.ceil(bubblesToProcess.length / interval);
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < totalBatches; i++) {
                const start = i * interval;
                const end = Math.min(start + interval, bubblesToProcess.length);
                const batch = bubblesToProcess.slice(start, end);
                
                // 更新进度
                const progress = ((i + 1) / totalBatches * 100).toFixed(1);
                progressBar.style.width = progress + '%';
                progressText.textContent = `${i + 1} / ${totalBatches}`;
                statusText.textContent = `正在处理第 ${start + 1}-${end} 个气泡...`;
                
                try {
                    // 临时将batch放入pendingSummaryBubbles
                    pendingSummaryBubbles = batch;
                    
                    // 调用生成函数
                    await generateMemorySummary(false);
                    
                    successCount++;
                    
                    // 短暂延迟，避免API限流
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`❌ 批次 ${i + 1} 生成失败:`, error);
                    failCount++;
                }
            }
            
            // 完成
            progressBar.style.width = '100%';
            statusText.textContent = `完成！成功: ${successCount}，失败: ${failCount}`;
            startBtn.textContent = '✅ 生成完成';
            
            // 清空待总结缓冲区（因为已经全部处理）
            pendingSummaryBubbles = [];
            saveChatHistory();
            updateMemoryStatus();
            fillBasicInfoInputs();
            
            // 3秒后自动关闭
            setTimeout(() => {
                closeBatchGenerateDialog();
                if (failCount === 0) {
                    showToast('✅ 批量生成完成！');
                } else {
                    alert(`批量生成完成！\n成功: ${successCount}\n失败: ${failCount}`);
                }
            }, 3000);
        }
        
        /**
         * 显示批量生成模式选择对话框
         * @param {string} batchMode - 'all' 或 'recent'
         * @param {number} count - 处理的消息数量
         * @returns {Promise<string|null>} - 'replace'(覆盖) 或 'continue'(继续) 或 null(取消)
         */
        function showBatchGenerateModeDialog(batchMode, count) {
            return new Promise((resolve) => {
                const dialog = document.getElementById('batch-mode-dialog');
                const titleEl = document.getElementById('batch-mode-title');
                const descEl = document.getElementById('batch-mode-desc');
                
                // 更新对话框内容
                if (batchMode === 'all') {
                    titleEl.textContent = '从头生成所有记忆';
                    descEl.textContent = `将处理全部 ${count} 条消息`;
                } else if (batchMode === 'recent') {
                    titleEl.textContent = `从最近 ${count} 条生成记忆`;
                    descEl.textContent = `将处理最近 ${count} 条消息`;
                }
                
                // 设置按钮事件
                const replaceBtn = document.getElementById('batch-mode-replace-btn');
                const continueBtn = document.getElementById('batch-mode-continue-btn');
                const cancelBtn = document.getElementById('batch-mode-cancel-btn');
                
                // 移除旧的事件监听器并添加新的
                const newReplaceBtn = replaceBtn.cloneNode(true);
                const newContinueBtn = continueBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                
                replaceBtn.parentNode.replaceChild(newReplaceBtn, replaceBtn);
                continueBtn.parentNode.replaceChild(newContinueBtn, continueBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
                
                newReplaceBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve('replace');
                };
                
                newContinueBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve('continue');
                };
                
                newCancelBtn.onclick = () => {
                    dialog.style.display = 'none';
                    resolve(null);
                };
                
                dialog.style.display = 'flex';
            });
        }
        
        // ========== 长期记忆导入导出 ==========
        
        /**
         * 导出长期记忆
         * 改进版本：支持小米浏览器等多种浏览器
         */
        async function exportMemory() {
            if (!longTermMemory.metadata?.last_updated) {
                alert('当前还没有生成长期记忆！');
                return;
            }
            
            const memoryData = {
                version: '1.0',
                exported_at: new Date().toISOString(),
                memory: longTermMemory
            };
            
            const dataStr = JSON.stringify(memoryData, null, 2);
            const fileName = `long_term_memory_${new Date().toISOString().split('T')[0]}.json`;
            const dataSize = new Blob([dataStr]).size;
            const dataSizeMB = (dataSize / 1024 / 1024).toFixed(2);

            // 检测是否为小米浏览器
            const isMiuiBrowser = /MiuiBrowser/i.test(navigator.userAgent);
            
            // 给用户选择导出方式
            let exportMethod = '';
            if (isMiuiBrowser) {
                const choice = confirm(`🧠 记忆大小：${dataSizeMB} MB\n\n检测到小米浏览器\n\n点击"确定"复制到剪贴板\n点击"取消"尝试直接下载`);
                exportMethod = choice ? 'clipboard' : 'download';
            } else {
                const choice = confirm(`🧠 记忆大小：${dataSizeMB} MB\n\n点击"确定"直接下载\n点击"取消"复制到剪贴板`);
                exportMethod = choice ? 'download' : 'clipboard';
            }
            
            if (exportMethod === 'clipboard') {
                // 复制到剪贴板
                try {
                    await navigator.clipboard.writeText(dataStr);
                    alert(`✅ 长期记忆已复制到剪贴板！\n\n大小：${dataSizeMB} MB\n\n请立即：\n1. 打开"备忘录"或"WPS"\n2. 新建文档\n3. 粘贴\n4. 保存为：${fileName}`);
                    showToast('✅ 已复制到剪贴板');
                    return;
                } catch (error) {
                    console.error('❌ 剪贴板复制失败:', error);
                    alert(`复制失败：${error.message}\n\n建议切换到"直接下载"方式`);
                    return;
                }
            }

            // 标准下载方案
            // 方案1: 使用 Blob + URL.createObjectURL（推荐）
            try {
                const blob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = fileName;
                link.style.display = 'none';
                document.body.appendChild(link);
                
                // 强制触发点击
                link.dispatchEvent(new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                }));
                
                // 延迟清理
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }, 100);
                
                showToast('✅ 记忆已导出');
                console.log('✅ 记忆导出完成（Blob方案）');
            } catch (error) {
                console.warn('Blob方案失败，尝试data URI方案:', error);
                
                // 方案2: 降级使用 data URI
                try {
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    const link = document.createElement('a');
                    link.href = dataUri;
                    link.download = fileName;
                    link.style.display = 'none';
                    document.body.appendChild(link);
                    
                    link.dispatchEvent(new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    }));
                    
                    setTimeout(() => {
                        document.body.removeChild(link);
                    }, 100);
                    
                    showToast('✅ 记忆已导出');
                    console.log('✅ 记忆导出完成（data URI方案）');
                } catch (error2) {
                    // 方案3: window.open 降级
                    console.warn('data URI方案也失败，使用window.open:', error2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                    window.open(dataUri, '_blank');
                    showToast('已在新标签页打开，请长按保存或复制');
                    console.log('✅ 记忆导出完成（window.open方案）');
                }
            }
        }
        
        /**
         * 导入记忆文件选择处理
         */
        let importedMemoryData = null;
        
        document.getElementById('import-memory-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type !== "application/json") {
                alert('请选择JSON文件！');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // 验证文件格式
                    if (!data.memory || !data.memory.metadata) {
                        alert('文件格式不正确，请选择有效的长期记忆文件！');
                        return;
                    }
                    
                    importedMemoryData = data.memory;
                    showImportMemoryDialog(data.memory);
                    
                } catch (error) {
                    alert('文件解析失败：' + error.message);
                }
            };
            
            reader.readAsText(file);
            
            // 重置文件选择，允许重复选择同一文件
            event.target.value = '';
        });
        
        /**
         * 显示导入记忆对话框
         */
        function showImportMemoryDialog(memory) {
            const dialog = document.getElementById('import-memory-dialog');
            
            // 填充文件信息
            const basicInfoCount = Object.keys(memory.basic_info || {}).length;
            const eventsCount = (memory.important_events || []).length;
            const lastUpdated = memory.metadata?.last_updated 
                ? new Date(memory.metadata.last_updated).toLocaleString('zh-CN')
                : '未知';
            
            document.getElementById('import-basic-info-count').textContent = basicInfoCount;
            document.getElementById('import-events-count').textContent = eventsCount;
            document.getElementById('import-last-updated').textContent = lastUpdated;
            
            // 监听导入模式变化
            const radios = document.querySelectorAll('input[name="import-mode"]');
            const mergeWarning = document.getElementById('merge-warning');
            
            radios.forEach(radio => {
                radio.onchange = () => {
                    if (radio.value === 'merge') {
                        mergeWarning.style.display = 'block';
                    } else {
                        mergeWarning.style.display = 'none';
                    }
                };
            });
            
            // 初始状态
            mergeWarning.style.display = 'none';
            
            dialog.style.display = 'flex';
        }
        
        /**
         * 关闭导入记忆对话框
         */
        function closeImportMemoryDialog() {
            const dialog = document.getElementById('import-memory-dialog');
            dialog.style.display = 'none';
            importedMemoryData = null;
        }
        
        /**
         * 确认导入记忆
         */
        async function confirmImportMemory() {
            if (!importedMemoryData) {
                alert('没有可导入的数据！');
                return;
            }
            
            const mode = document.querySelector('input[name="import-mode"]:checked').value;
            const confirmBtn = document.getElementById('import-memory-confirm-btn');
            
            if (mode === 'replace') {
                // 覆盖模式：直接替换
                if (!confirm('确定要用导入的记忆覆盖当前记忆吗？当前记忆将丢失！')) {
                    return;
                }
                
                longTermMemory = importedMemoryData;
                saveChatHistory();
                updateMemoryStatus();
                fillBasicInfoInputs();
                
                closeImportMemoryDialog();
                showToast('✅ 记忆已导入');
                
            } else if (mode === 'merge') {
                // 合并模式：调用API智能合并
                if (!config.baseurl || !config.apikey) {
                    alert('请先配置API！');
                    return;
                }
                
                confirmBtn.disabled = true;
                confirmBtn.textContent = '合并中...';
                
                try {
                    const mergePrompt = `请智能合并以下两份长期记忆，去除重复信息，保留所有有价值的内容：

【当前记忆】
${JSON.stringify(longTermMemory, null, 2)}

【导入的记忆】
${JSON.stringify(importedMemoryData, null, 2)}

要求：
1. basic_info: 合并基本信息，优先保留更完整的信息
2. emotional_profile: 合并两份情感倾向描述，形成更全面的总结（100-300字）
3. important_events: 合并重要事件列表，去除重复，按重要度排序，保留最重要的${localStorage.getItem('maxImportantEvents') || 10}条

输出格式（纯JSON，不要markdown代码块）：
{
  "basic_info": {...},
  "emotional_profile": "...",
  "important_events": [...]
}`;

                    const response = await fetch(config.baseurl + '/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${config.apikey}`
                        },
                        body: JSON.stringify({
                            model: config.modelname,
                            messages: [
                                { role: 'system', content: '你是一个专业的记忆整理助手。' },
                                { role: 'user', content: mergePrompt }
                            ],
                            temperature: 0.3
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.choices && data.choices[0]) {
                        let aiResponse = data.choices[0].message.content.trim();
                        
                        // 移除可能的markdown代码块标记
                        aiResponse = aiResponse.replace(/^```json\n?/i, '').replace(/\n?```$/i, '');
                        
                        // 解析JSON
                        const mergedMemory = JSON.parse(aiResponse);
                        
                        // 更新长期记忆
                        longTermMemory.basic_info = mergedMemory.basic_info || longTermMemory.basic_info;
                        longTermMemory.emotional_profile = mergedMemory.emotional_profile || longTermMemory.emotional_profile;
                        longTermMemory.important_events = mergedMemory.important_events || longTermMemory.important_events;
                        longTermMemory.metadata.last_updated = new Date().toISOString();
                        
                        saveChatHistory();
                        updateMemoryStatus();
                        fillBasicInfoInputs();
                        
                        closeImportMemoryDialog();
                        showToast('✅ 记忆已智能合并');
                        
                    } else {
                        throw new Error('API返回格式错误');
                    }
                    
                } catch (error) {
                    console.error('❌ 合并失败:', error);
                    alert('合并失败：' + error.message);
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = '✅ 确认导入';
                }
            }
        }
        
        // ====================================

        /**
         * 在界面上显示一条消息
         * @param {string} text - 消息内容
         * @param {string} role - 消息角色 ('user' 或 'ai')
         * @param {number} status - 消息状态 (1=单勾, 2=双勾, 0=无勾)
         * @param {string} timestamp - 可选的时间戳，如果不提供则使用当前时间
         * @returns {string} 返回使用的时间戳
         */
        /**
         * 显示一条消息（气泡）
         * @param {string} text - 消息内容
         * @param {string} role - 'user' 或 'ai' / 'assistant'
         * @param {number} status - 对勾状态 (0=无, 1=单勾, 2=双勾)
         * @param {string} timestamp - 时间戳（可选）
         * @param {boolean} saveToHistory - 是否保存到chatHistory（默认true）
         * @returns {object} 返回创建的气泡对象
         */
        function displayMessage(text, role, status = 0, timestamp = null, saveToHistory = true, existingId = null, skipScroll = false, quoteInfo = null, targetContainer = null) {
            // 生成时间戳
            const fullTimestamp = timestamp || new Date().toISOString();
            // 生成唯一ID
            const bubbleId = existingId || ('bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            
            // 处理引用信息
            let quotedText = null;
            let quotedSender = null;
            let mainText = text;
            
            // 如果传入了quoteInfo参数,使用它
            if (quoteInfo) {
                quotedSender = quoteInfo.sender;
                quotedText = quoteInfo.content;
                mainText = text;
                
                // 为了保持向后兼容,也保存引用格式到文本中(用于API和历史记录)
                text = `[引用: "${quotedSender}: ${quotedText.substring(0, 50)}${quotedText.length > 50 ? '...' : ''}"]\n\n${text}`;
            } else {
                // 如果没有quoteInfo,检测文本中是否包含旧格式的引用
                const quoteMatch = text.match(/^\[引用: "(.+?): (.+?)"\]\n\n([\s\S]+)$/);
                if (quoteMatch) {
                    quotedSender = quoteMatch[1];
                    quotedText = quoteMatch[2];
                    mainText = quoteMatch[3];
                }
            }
            
            // 创建气泡对象 (保存原始带引用的文本)
            const bubble = {
                id: bubbleId,
                role: role,
                content: text, // 保存原始文本
                timestamp: fullTimestamp
            };
            
            // 保存到chatHistory
            if (saveToHistory) {
                chatHistory.push(bubble);
                pendingSummaryBubbles.push(bubble); // 同时加入待总结队列
                saveChatHistory();
            }
            
            // === 渲染UI ===
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);
            messageDiv.dataset.bubbleId = bubble.id; // 保存气泡ID
            
            // 添加头像
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'message-avatar';
            if (role === 'user') {
                if (config.userAvatar) {
                    const img = document.createElement('img');
                    img.src = config.userAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarDiv.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar user';
                    defaultDiv.textContent = config.userNickname.substring(0, 1);
                    avatarDiv.appendChild(defaultDiv);
                }
            } else {
                if (config.aiAvatar) {
                    const img = document.createElement('img');
                    img.src = config.aiAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarDiv.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar ai';
                    defaultDiv.textContent = config.aiNickname.substring(0, 1);
                    avatarDiv.appendChild(defaultDiv);
                }
            }

            // 创建内容容器(包含引用和气泡)
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';
            
            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bubble');
            
            // 添加主要文本(不包含引用)
            const mainTextNode = document.createTextNode(mainText);
            bubbleDiv.appendChild(mainTextNode);
            
            const metaDiv = document.createElement('div');
            metaDiv.classList.add('message-meta');
            
            // 格式化时间显示
            const time = new Date(fullTimestamp);
            const timeStr = time.getHours().toString().padStart(2, '0') + ':' + 
                         time.getMinutes().toString().padStart(2, '0');
            
            const timeSpan = document.createElement('span');
            timeSpan.textContent = timeStr;
            metaDiv.appendChild(timeSpan);
            
            // 用户消息显示对勾
            if (role === 'user') {
                const checkmark = document.createElement('span');
                checkmark.classList.add('checkmark');
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = '✓✓';
                } else if (status === 1) {
                    checkmark.textContent = '✓';
                }
                metaDiv.appendChild(checkmark);
                messageDiv.dataset.status = status;
            }
            
            bubbleDiv.appendChild(metaDiv);
            contentWrapper.appendChild(bubbleDiv);
            
            // 【修改】如果有引用，添加到contentWrapper（气泡外下方）
            if (quotedText && quotedSender) {
                const quotedDiv = document.createElement('div');
                quotedDiv.classList.add('quoted-message');
                
                const senderSpan = document.createElement('span');
                senderSpan.classList.add('quote-sender');
                senderSpan.textContent = quotedSender + '：';
                
                quotedDiv.appendChild(senderSpan);
                quotedDiv.appendChild(document.createTextNode(quotedText));
                
                contentWrapper.appendChild(quotedDiv); // 添加到contentWrapper，在bubbleDiv外
            }
            
            messageDiv.appendChild(avatarDiv);
            messageDiv.appendChild(contentWrapper);
            
            // 使用传入的容器或默认的chatContainer
            const container = targetContainer || chatContainer;
            container.appendChild(messageDiv);
            
            // 添加长按菜单
            setupLongPressMenu(bubbleDiv, bubble);
            
            // 如果处于多选模式，添加复选框
            if (isMultiSelectMode) {
                addMultiSelectCheckbox(messageDiv, bubble.id);
            }
            
            // 除非skipScroll=true，否则每条消息都滚动（这样AI消息跳出来时能看到）
            if (!skipScroll && !targetContainer) { // 如果是临时容器，不滚动
                scrollToBottom();
            }
            
            return bubble;
        }
        
        /**
         * 更新最后一条用户消息的对勾状态
         * @param {number} status - 1=单勾, 2=双勾
         */
        function updateLastMessageStatus(status) {
            const userMessages = chatContainer.querySelectorAll('.message.user');
            if (userMessages.length === 0) return;
            
            const lastMessage = userMessages[userMessages.length - 1];
            const checkmark = lastMessage.querySelector('.checkmark');
            
            if (checkmark) {
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = '✓✓';
                } else if (status === 1) {
                    checkmark.textContent = '✓';
                }
                lastMessage.dataset.status = status;
            }
        }
        
        /**
         * 显示"对方正在输入中..."
         */
        function showTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement) {
                chatNameElement.dataset.originalName = chatNameElement.textContent;
                chatNameElement.innerHTML = '<span class="typing-indicator">对方正在输入中...</span>';
            }
        }
        
        /**
         * 隐藏"对方正在输入中..."，恢复聊天对象名称
         */
        function hideTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && chatNameElement.dataset.originalName) {
                chatNameElement.textContent = chatNameElement.dataset.originalName;
            }
        }
        /**
         * 清理 API 响应文本，去除时间戳等多余信息
         * @param {string} text - 原始文本
         * @returns {string} 清理后的文本
         */
        function cleanApiResponse(text) {
            if (!text) return "";
            
            // 移除开头的时间戳：[2024/12/20 21:39] 或 [2024/12/20 21:39 星期五]
            // 匹配格式：[年/月/日 时:分] 或 [年/月/日 时:分 星期X]
            const timestampRegex = /^\s*\[\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}(?:\s+星期[一二三四五六日])?\]\s*/;
            
            // 移除时间戳
            let cleaned = text.replace(timestampRegex, '');
            
            // 如果还有多余的空白，再清理一次
            cleaned = cleaned.trim();
            
            //console.log('🧹 清理前:', text.substring(0, 50));
            //console.log('🧹 清理后:', cleaned.substring(0, 50));
            
            return cleaned;
        }
        /**
         * 处理 AI 的完整响应，并根据 '\n\n' 逐条显示消息。
         * 同时将完整的AI回复计入 chatHistory。
         * @param {string} fullAiText - 从 AI API 接收到的完整文本。
         */
        function processAndDisplaySegments(fullAiText) {
            // 1. 定义消息分隔符和间隔时间
            const separator = '\n\n';
            const delay = 500; // 每条消息之间的间隔，单位：毫秒 (0.5 秒)
            
            // 生成AI消息的时间戳（所有分段使用同一个时间）
            const aiTimestamp = new Date().toISOString();

            // 2. 根据 '\n\n' 分割完整的响应文本
            const messageSegments = fullAiText.split(separator).filter(seg => seg.trim());

            // 3. 【关键修改】先同步将所有分段加入chatHistory
            const bubbles = []; // 保存所有气泡对象，用于后续UI显示
            messageSegments.forEach((segment, index) => {
                // 清理可能的时间戳
                let cleanSegment = cleanApiResponse(segment);
                cleanSegment = cleanSegment.trim();

                if (cleanSegment.length > 0) {
                    // 立即加入chatHistory，但跳过UI渲染（saveToHistory=true, skipScroll=true）
                    // 并且不立即渲染到页面（我们稍后异步渲染）
                    const bubble = {
                        content: cleanSegment,
                        timestamp: aiTimestamp,
                        index: index
                    };
                    bubbles.push(bubble);
                    
                    // 只加入chatHistory，不渲染UI
                    chatHistory.push({
                        id: 'bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                        role: 'assistant',
                        content: cleanSegment,
                        timestamp: aiTimestamp
                    });
                    pendingSummaryBubbles.push(chatHistory[chatHistory.length - 1]);
                }
            });
            
            // 保存到localStorage
            saveChatHistory();
            
            console.log('✅ 所有AI分段已加入chatHistory，共', bubbles.length, '条');

            // 4. 【关键修改】chatHistory已完整，立即重置状态并处理下一批
            isWaitingForAI = false;
            
            // 检查是否需要自动生成记忆
            checkAutoSummary();
            
            // 立即检查是否有待发送的消息
            if (pendingUserMessages.length > 0) {
                if (hasReachedWaitTime) {
                    // 队列中的消息已经等够7秒 → 立即发送
                    console.log('📬 发现待发送消息', pendingUserMessages.length, '条，且已到时间，立即发送');
                    hasReachedWaitTime = false;
                    sendBatchMessages();
                } else {
                    // 队列中的消息还未到7秒 → 继续计时
                    console.log('📬 发现待发送消息', pendingUserMessages.length, '条，但未到时间，继续计时');
                    startBatchTimer();
                }
            } else {
                hasReachedWaitTime = false;
            }

            // 5. 【UI显示】异步逐条显示消息（纯视觉效果，不影响逻辑）
            bubbles.forEach((bubble, index) => {
                setTimeout(() => {
                    // 创建并显示消息UI（不再修改chatHistory）
                    displayMessageUI(bubble.content, 'assistant', aiTimestamp);
                    
                    // 触发消息通知（只在第一条消息时触发，且不在聊天页面时）
                    if (index === 0) {
                        const currentPage = document.querySelector('.page.active');
                        if (currentPage && currentPage.id !== 'chat-page') {
                            const characterName = config.aiNickname || 'AI 聊天对象';
                            const avatarData = config.aiAvatar || null;
                            showMessageNotification(currentCharacterId, characterName, bubble.content, avatarData);
                        }
                    }
                }, index * delay);
            });
        }
        
        /**
         * 仅显示消息UI，不修改chatHistory
         * 用于分段显示AI消息时的视觉效果
         */
        function displayMessageUI(text, role, timestamp) {
            const fullTimestamp = timestamp || new Date().toISOString();
            
            // 查找对应的bubble（从chatHistory中找到匹配的）
            const bubble = chatHistory.find(b => 
                b.content === text && 
                b.role === role && 
                b.timestamp === fullTimestamp &&
                !document.querySelector(`[data-bubble-id="${b.id}"]`) // 还没渲染过
            );
            
            if (!bubble) {
                console.error('❌ 找不到对应的bubble');
                return;
            }
            
            // 渲染UI（复用displayMessage的UI渲染逻辑，但不保存到chatHistory）
            displayMessage(text, role, 0, timestamp, false, bubble.id, false);
        }
        
        // ========== 批量发送功能 ==========
        /**
         * 开始批量发送计时器
         */
        function startBatchTimer() {
            // 清除之前的计时器
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
            }
            
            // 重置"已到时间"标记
            hasReachedWaitTime = false;
            
            // 获取等待时间（秒）
            const waitTime = parseInt(localStorage.getItem('batchWaitTime')) || 7;
            
            console.log('⏰ 启动计时器，等待', waitTime, '秒...');
            
            // 启动新计时器
            batchSendTimer = setTimeout(() => {
                console.log('⏰ 计时器到期');
                sendBatchMessages();
            }, waitTime * 1000);
        }
        
        /**
         * 取消批量发送计时器
         */
        function cancelBatchTimer() {
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
                batchSendTimer = null;
                console.log('⏰ 计时器已取消');
            }
        }
        
        /**
         * 发送批量消息（计时器到期时调用）
         */
        async function sendBatchMessages() {
            // 标记已到达等待时间
            hasReachedWaitTime = true;
            
            if (pendingUserMessages.length === 0) {
                console.log('📭 没有待发送的消息');
                hasReachedWaitTime = false;
                return;
            }
            
            // 检查是否正在等待AI回复
            if (isWaitingForAI) {
                console.log('⏳ 已到7秒但正在等待AI回复，保持hasReachedWaitTime=true');
                // 不重启计时器，保持hasReachedWaitTime=true
                // 等AI回复完成后会检查这个标记
                return;
            }
            
            // 两个条件都满足：已到时间 AND 不在等待AI
            console.log('📤 发送批量消息，共', pendingUserMessages.length, '条');
            
            // 重置标记
            hasReachedWaitTime = false;
            
            // 标记正在等待AI
            isWaitingForAI = true;
            
            // 将所有待发送消息的状态更新为双勾
            pendingUserMessages.forEach(bubbleId => {
                const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubbleId}"]`);
                if (messageDiv) {
                    const checkmark = messageDiv.querySelector('.checkmark');
                    if (checkmark) {
                        checkmark.classList.add('double');
                        checkmark.textContent = '✓✓';
                    }
                    messageDiv.dataset.status = '2';
                }
            });
            
            // 显示"对方正在输入中..."
            showTypingIndicator();
            
            // 【关键修复】保存待发送队列的副本，用于API调用时识别等待期间的消息
            const currentBatchIds = [...pendingUserMessages];
            
            // 清空待发送队列
            pendingUserMessages = [];
            
            // 调用API，传入当前批次的消息ID
            await callAPIToGenerate(currentBatchIds);
        }
        
        /**
         * 智能提取相关记忆
         * @param {Array} memories - 所有记忆
         * @param {string} userMessage - 用户消息
         * @param {Array} recentBubbles - 最近的对话气泡
         * @returns {Array} 相关记忆列表（1-5条）
         */
        function extractRelevantMemories(memories, userMessage, recentBubbles) {
            if (!memories || memories.length === 0) return [];
            
            console.log('🧠 开始智能记忆提取');
            console.log('📊 总记忆数:', memories.length);
            console.log('💬 用户消息:', userMessage.substring(0, 50));
            
            const result = [];
            const now = Date.now();
            
            // 检测用户情绪（是否在抱怨记忆不准确）
            const isComplaining = /我都说了|你记不得|忘了吗|不记得|刚才说过/.test(userMessage);
            const hasEmphasis = /！|!/.test(userMessage);
            const isEmotional = isComplaining || hasEmphasis;
            
            if (isEmotional) {
                console.log('😤 检测到情绪强度，扩大搜索范围');
            }
            
            // 解析用户提到的时间
            const timeRange = parseTimeReference(userMessage, now);
            if (timeRange) {
                console.log('📅 检测到时间引用:', timeRange.description);
            }
            
            // ===== 第一层：时间筛选 =====
            let candidates = [];
            
            if (timeRange && !isEmotional) {
                // 用户明确提到时间，筛选该时间段的记忆
                candidates = memories.filter(m => {
                    const created = new Date(m.created_at).getTime();
                    const lastMentioned = new Date(m.last_mentioned).getTime();
                    // 创建时间或最后提及时间在范围内
                    return (created >= timeRange.start && created <= timeRange.end) ||
                           (lastMentioned >= timeRange.start && lastMentioned <= timeRange.end);
                });
                console.log(`📅 时间段筛选: ${candidates.length}条记忆`);
            } else if (isEmotional && timeRange) {
                // 情绪强，扩大时间范围（前后各延长50%）
                const duration = timeRange.end - timeRange.start;
                const expandedStart = timeRange.start - duration * 0.5;
                const expandedEnd = timeRange.end + duration * 0.5;
                
                candidates = memories.filter(m => {
                    const created = new Date(m.created_at).getTime();
                    const lastMentioned = new Date(m.last_mentioned).getTime();
                    return (created >= expandedStart && created <= expandedEnd) ||
                           (lastMentioned >= expandedStart && lastMentioned <= expandedEnd);
                });
                console.log(`😤 情绪模式：扩大时间范围，筛选到 ${candidates.length}条`);
            } else {
                // 没有时间引用，按最近时间筛选
                const threeDaysAgo = now - 3 * 24 * 60 * 60 * 1000;
                const sevenDaysAgo = now - 7 * 24 * 60 * 60 * 1000;
                
                // 最近3天必选
                const veryRecent = memories.filter(m => 
                    new Date(m.last_mentioned).getTime() >= threeDaysAgo
                );
                candidates.push(...veryRecent);
                console.log(`⏰ 最近3天: ${veryRecent.length}条`);
                
                // 如果不够5条，加入3-7天的
                if (candidates.length < 5) {
                    const recent = memories.filter(m => {
                        const time = new Date(m.last_mentioned).getTime();
                        return time >= sevenDaysAgo && time < threeDaysAgo;
                    });
                    candidates.push(...recent);
                    console.log(`⏰ 3-7天: ${recent.length}条`);
                }
            }
            
            // ===== 第二层：内容匹配 =====
            // 提取关键词
            const keywords = extractKeywords(userMessage, recentBubbles);
            console.log(`🔍 提取关键词: ${keywords.join(', ')}`);
            
            if (keywords.length > 0) {
                // 对候选记忆进行内容匹配评分
                const scored = candidates.map(m => {
                    let matchScore = 0;
                    const titleLower = m.title.toLowerCase();
                    const contentLower = m.content.toLowerCase();
                    
                    keywords.forEach(kw => {
                        const kwLower = kw.toLowerCase();
                        // title匹配 → 必选
                        if (titleLower.includes(kwLower)) {
                            matchScore += 100;  // 极高分，保证被选中
                        }
                        // content匹配
                        if (contentLower.includes(kwLower)) {
                            matchScore += 1;
                        }
                    });
                    
                    return { memory: m, matchScore };
                });
                
                // 分离：title命中的（必选）和 content命中的
                const titleMatched = scored.filter(x => x.matchScore >= 100);
                const contentMatched = scored.filter(x => x.matchScore > 0 && x.matchScore < 100);
                
                console.log(`✅ Title匹配（必选）: ${titleMatched.length}条`);
                console.log(`📝 Content匹配: ${contentMatched.length}条`);
                
                // 先加入title匹配的
                result.push(...titleMatched.map(x => x.memory));
                
                // 再加入content匹配度高的（按分数排序）
                contentMatched.sort((a, b) => b.matchScore - a.matchScore);
                
                // 补充到3-5条（但不超过5条）
                const remaining = Math.min(5 - result.length, contentMatched.length);
                if (remaining > 0) {
                    result.push(...contentMatched.slice(0, remaining).map(x => x.memory));
                }
                
                // 如果在非时间筛选模式下，还要搜索所有记忆的content
                if (!timeRange && result.length < 3) {
                    console.log('🔍 候选不足，搜索全部记忆...');
                    const allMemoriesMatched = memories
                        .filter(m => !result.find(r => r.memory_id === m.memory_id))  // 排除已选
                        .map(m => {
                            let score = 0;
                            const titleLower = m.title.toLowerCase();
                            const contentLower = m.content.toLowerCase();
                            
                            keywords.forEach(kw => {
                                const kwLower = kw.toLowerCase();
                                if (titleLower.includes(kwLower)) score += 100;
                                if (contentLower.includes(kwLower)) score += 1;
                            });
                            
                            return { memory: m, score };
                        })
                        .filter(x => x.score > 0)
                        .sort((a, b) => b.score - a.score);
                    
                    const toAdd = Math.min(3 - result.length, allMemoriesMatched.length);
                    if (toAdd > 0) {
                        result.push(...allMemoriesMatched.slice(0, toAdd).map(x => x.memory));
                        console.log(`📚 全库搜索：+${toAdd}条`);
                    }
                }
            }
            
            // ===== 第三层：鲁棒性兜底 =====
            // 修复3: 如果完全没有匹配到，返回所有记忆（按时间排序）
            if (result.length === 0) {
                console.log('⚠️ 关键词无匹配，返回全部记忆（按时间排序）');
                const allByTime = [...memories].sort((a, b) => 
                    new Date(b.last_mentioned) - new Date(a.last_mentioned)
                );
                result.push(...allByTime);
            }
            
            // 去重并按时间排序
            const unique = [...new Map(result.map(m => [m.memory_id, m])).values()];
            unique.sort((a, b) => new Date(b.last_mentioned) - new Date(a.last_mentioned));
            
            // 如果是兜底情况（返回了全部记忆），不限制数量；否则最多5条
            const maxReturn = result.length === memories.length ? memories.length : 5;
            const final = unique.slice(0, maxReturn);
            
            console.log(`✅ 最终返回 ${final.length} 条记忆:`);
            final.forEach((m, i) => {
                console.log(`   ${i + 1}. ${m.title}`);
            });
            
            return final;
        }
        
        /**
         * 解析时间引用
         */
        function parseTimeReference(text, now) {
            const today = new Date(now);
            today.setHours(0, 0, 0, 0);
            
            // 昨天
            if (/昨天|昨日/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 1);
                const end = new Date(start);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '昨天' };
            }
            
            // 前天
            if (/前天/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 2);
                const end = new Date(start);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '前天' };
            }
            
            // 上周/上星期
            if (/上周|上星期|上礼拜/.test(text)) {
                const start = new Date(today);
                start.setDate(start.getDate() - 14);  // 2周前
                const end = new Date(today);
                end.setDate(end.getDate() - 7);  // 1周前
                return { start: start.getTime(), end: end.getTime(), description: '上周' };
            }
            
            // 上个月
            if (/上个月|上月/.test(text)) {
                const start = new Date(today);
                start.setMonth(start.getMonth() - 1);
                start.setDate(1);
                const end = new Date(start);
                end.setMonth(end.getMonth() + 1);
                end.setDate(0);
                end.setHours(23, 59, 59, 999);
                return { start: start.getTime(), end: end.getTime(), description: '上个月' };
            }
            
            // 今年X月
            const monthMatch = text.match(/今年\s*([0-9一二三四五六七八九十]+)\s*月/);
            if (monthMatch) {
                const monthNum = parseChineseNumber(monthMatch[1]);
                if (monthNum >= 1 && monthNum <= 12) {
                    const start = new Date(today.getFullYear(), monthNum - 1, 1);
                    const end = new Date(today.getFullYear(), monthNum, 0, 23, 59, 59, 999);
                    return { start: start.getTime(), end: end.getTime(), description: `今年${monthNum}月` };
                }
            }
            
            // 具体日期 XX/XX 或 XX月XX日
            const dateMatch = text.match(/(\d{1,2})[\/月](\d{1,2})/);
            if (dateMatch) {
                const month = parseInt(dateMatch[1]);
                const day = parseInt(dateMatch[2]);
                if (month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                    const year = today.getFullYear();
                    const start = new Date(year, month - 1, day, 0, 0, 0, 0);
                    const end = new Date(year, month - 1, day, 23, 59, 59, 999);
                    return { start: start.getTime(), end: end.getTime(), description: `${month}月${day}日` };
                }
            }
            
            return null;
        }
        
        /**
         * 解析中文数字
         */
        function parseChineseNumber(str) {
            const map = {
                '一': 1, '二': 2, '三': 3, '四': 4, '五': 5,
                '六': 6, '七': 7, '八': 8, '九': 9, '十': 10,
                '十一': 11, '十二': 12
            };
            return map[str] || parseInt(str) || 0;
        }
        
        /**
         * 提取关键词（综合版 - 多策略融合）
         */
        function extractKeywords(userMessage, recentBubbles) {
            // 修复1: 使用最近5条用户消息（而不是3条）
            const recentUserMsgs = recentBubbles
                .filter(b => b.role === 'user')
                .slice(-5)  // 改为5条
                .map(b => b.content)
                .join(' ');
            
            const text = userMessage + ' ' + recentUserMsgs;
            const keywords = [];
            
            console.log('📝 提取关键词的文本长度:', text.length, '字');
            
            // === 策略1：名词后缀模式 ===
            const nounPattern = /([\u4e00-\u9fa5]{1,3}[子儿者人师生员长家手物品料纸书笔机器虫]+)/g;
            const nouns = text.match(nounPattern) || [];
            keywords.push(...nouns);
            
            // === 策略2：专有名词（英文） ===
            const properNouns = text.match(/[A-Z][a-zA-Z]+/g) || [];
            keywords.push(...properNouns);
            
            // === 策略3：简单分词（按标点和空格） ===
            const segments = text.split(/[\s，。！？、；：""''（）【】《》]+/);
            segments.forEach(seg => {
                if (seg.length >= 2 && seg.length <= 6) {
                    // 排除纯时间词和虚词
                    if (/^(今天|明天|昨天|今晚|现在|刚才|之后|以前|上次|下次|最近|一直|没有|可以|应该|这个|那个|什么|怎么)$/.test(seg)) {
                        return;
                    }
                    keywords.push(seg);
                }
            });
            
            // === 策略4：高价值单字（名词性） ===
            const valuableChars = text.match(/[信纸书笔机器车房钱金银铜铁钢木水火土山石玉宝珠贝币票卡证照片画图章印台灯椅桌柜架箱包袋盒瓶罐壶杯碗盘碟勺筷]/g) || [];
            keywords.push(...valuableChars);
            
            // === 策略5：连续2-3字的中文词（补充） ===
            const chineseWords = text.match(/[\u4e00-\u9fa5]{2,3}/g) || [];
            chineseWords.forEach(w => {
                // 只保留不在停用词列表的
                if (!/^(我们|你们|他们|今天|明天|昨天|今晚|现在|刚才|之后|以前|上次|下次|最近|一直|没有|可以|应该|这个|那个|什么|怎么|为什么|不是|觉得|知道|继续|之前)$/.test(w)) {
                    keywords.push(w);
                }
            });
            
            // 去重并统计频率
            const freq = {};
            keywords.forEach(k => {
                const clean = k.trim();
                if (clean.length > 0 && clean.length <= 6) {
                    freq[clean] = (freq[clean] || 0) + 1;
                }
            });
            
            // 修复2: 去除重叠词（只保留最长的）
            const allWords = Object.keys(freq);
            const filtered = allWords.filter(word => {
                // 检查是否被其他更长的词包含
                return !allWords.some(other => 
                    other !== word && 
                    other.length > word.length && 
                    other.includes(word)
                );
            });
            
            console.log(`🔍 去重叠前: ${allWords.length}个词`);
            console.log(`✂️ 去重叠后: ${filtered.length}个词`);
            
            // 重新排序：先按频率，再按长度
            const sorted = filtered.sort((a, b) => {
                if (freq[b] !== freq[a]) return freq[b] - freq[a];
                return b.length - a.length;
            });
            
            const result = sorted.slice(0, 8);
            console.log('🎯 最终关键词:', result.join(', '));
            
            return result;
        }
        
        /**
         * 调用API生成回复（从generateBtn.onclick中提取）
         * @param {Array} currentBatchIds - 当前批次的消息ID数组，用于识别等待期间发送的消息
         */
        async function callAPIToGenerate(currentBatchIds = []) {
            // 启动API超时计时器
            const timeoutSeconds = parseInt(localStorage.getItem('apiTimeout')) || 60;
            console.log('⏰ 启动API超时计时器:', timeoutSeconds, '秒');
            
            apiTimeoutTimer = setTimeout(() => {
                console.error('⏰ API请求超时（', timeoutSeconds, '秒）');
                
                // 重置状态
                isWaitingForAI = false;
                hasReachedWaitTime = false;
                hideTypingIndicator();
                
                // 显示超时消息
                const errorBubble = document.createElement('div');
                errorBubble.classList.add('message', 'ai');
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                bubble.style.color = '#d32f2f';
                bubble.textContent = `⏰ API 请求超时（${timeoutSeconds}秒未响应）。请检查网络连接或稍后重试。`;
                errorBubble.appendChild(bubble);
                chatContainer.appendChild(errorBubble);
                scrollToBottom();
                
                // 检查队列，如果有消息可能需要重试
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('📬 超时后发现待发送消息，准备重试');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('📬 超时后发现待发送消息，重启计时器');
                        startBatchTimer();
                    }
                }
            }, timeoutSeconds * 1000);

            // B. 获取用户设置的上下文窗口大小 (N)
            const contextSizeKey = 'contextWindowSize'; 
            const N = parseInt(localStorage.getItem(contextSizeKey)) || 50; 
            
            // C. 截取最后N个气泡
            let recentBubbles = chatHistory.slice(-N);
            
            // 【关键优化】向前回溯，确保第一条消息是完整的
            recentBubbles = extendBackward(recentBubbles, chatHistory);
            
            console.log('📊 准备发送的气泡数量:', recentBubbles.length);
            console.log('📊 当前批次ID:', currentBatchIds);
            console.log('📊 完整chatHistory长度:', chatHistory.length);
            console.log('📊 chatHistory最后5条ID:', chatHistory.slice(-5).map(b => b.id));
            console.log('📊 recentBubbles的ID:', recentBubbles.map(b => b.id));
            
            // 【关键修改】在合并前，标记等待期间的user消息（但不加前缀，留到合并时处理）
            const pendingBubbleIds = new Set(currentBatchIds);
            console.log('🔍 pendingBubbleIds:', Array.from(pendingBubbleIds));
            
            recentBubbles = recentBubbles.map(bubble => {
                if (bubble.role === 'user' && pendingBubbleIds.has(bubble.id)) {
                    // 这是等待期间发送的消息，加标记（但不修改content）
                    console.log('✅ 标记为isPending:', bubble.id, bubble.content.substring(0, 20));
                    return {
                        ...bubble,
                        isPending: true
                    };
                }
                return bubble;
            });
            
            console.log('📊 最后5个气泡:', recentBubbles.slice(-5).map(b => ({
                role: b.role,
                isPending: b.isPending,
                content: b.content.substring(0, 50) + '...'
            })));
            
            // D. 转换为API格式（修改合并逻辑，不合并带isPending标记的消息）
            let apiMessages = convertToAPIFormatWithPending(recentBubbles);
            console.log('💰 Token优化:', recentBubbles.length, '个气泡 →', apiMessages.length, '条API消息');
            console.log('📊 合并后的消息:', apiMessages.map(m => ({
                role: m.role,
                content: m.content.substring(0, 50) + '...'
            })));
            
            // E. 确保最后一条是user（应该已经是了，因为等待期间的消息被移到了后面）
            if (apiMessages.length > 0 && apiMessages[apiMessages.length - 1].role !== 'user') {
                console.error('❌ 警告：最后一条消息不是user！');
            }

            // E. 构建最终的 Messages 列表
            let finalSystemPrompt = config.systemPrompt;
            
            // 添加长期记忆到系统提示
            if (longTermMemory && longTermMemory.metadata) {
                let memoryPrompt = '\n\n=== 长期记忆 ===\n\n';
                
                // 添加基本信息
                if (longTermMemory.basic_info && Object.keys(longTermMemory.basic_info).length > 0) {
                    memoryPrompt += '以下是用户的基本信息，你作为用户的爱人应该深深牢记，并且贴近用户的喜好，照顾用户所有需求：\n';
                    for (const [key, value] of Object.entries(longTermMemory.basic_info)) {
                        memoryPrompt += `${key}: ${value}\n`;
                    }
                    memoryPrompt += '\n';
                }
                
                // 添加情感倾向
                if (longTermMemory.emotional_profile) {
                    memoryPrompt += `性格: ${longTermMemory.emotional_profile}\n\n`;
                }
                
                // 添加人际关系
                if (longTermMemory.relationships) {
                    memoryPrompt += `人际关系: ${longTermMemory.relationships}\n\n`;
                }
                
                // 添加所有记忆（按last_mentioned倒序）
                if (longTermMemory.important_events && longTermMemory.important_events.length > 0) {
                    // 按last_mentioned倒序排序（最近的在前）
                    const sortedMemories = [...longTermMemory.important_events].sort((a, b) => 
                        new Date(b.last_mentioned) - new Date(a.last_mentioned)
                    );
                    
                    memoryPrompt += '以下是你和用户交互时，你产生的记忆片段和你对于事件的情绪，你应该深深记住并且基于以上事实对用户的最新消息进行回复（越靠前的记忆越重要）：\n\n';
                    
                    sortedMemories.forEach((m, i) => {
                        const date = new Date(m.last_mentioned).toLocaleDateString('zh-CN');
                        memoryPrompt += `${i + 1}. ${m.title}（${date}`;
                        if (m.mention_count) {
                            memoryPrompt += `，提及${m.mention_count}次`;
                        }
                        memoryPrompt += `）\n`;
                        memoryPrompt += `${m.content}\n`;
                        if (m.assistant_attitude) {
                            memoryPrompt += `你的态度: ${m.assistant_attitude}\n`;
                        }
                        memoryPrompt += '\n';
                    });
                }
                
                memoryPrompt += '=== 记忆结束 ===\n';
                finalSystemPrompt += memoryPrompt;
            }
            
            // 添加当前时间信息到系统提示
            const now = new Date();
            const currentTimeStr = now.toLocaleString('zh-CN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
            });
            finalSystemPrompt += `\n\n[当前时间]: ${currentTimeStr}`;
            
            // 为每条消息添加时间信息
            const messagesWithTime = apiMessages.map(msg => {
                if (msg.timestamp) {
                    const time = new Date(msg.timestamp);
                    const timeStr = time.toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    });
                    return {
                        role: msg.role,
                        content: `[${timeStr}] ${msg.content}`
                    };
                } else {
                    return {
                        role: msg.role,
                        content: msg.content
                    };
                }
            });
            
            const messages = [
                { role: "system", content: finalSystemPrompt },
                ...messagesWithTime 
            ];
            
            // 【调试日志】输出发送给API的消息
            console.log('📤 准备发送API请求');
            console.log('📊 消息数量:', messages.length);
            console.log('🔍 第一条消息角色:', messages[1]?.role);
            console.log('🔍 最后一条消息角色:', messages[messages.length - 1]?.role);
            console.log('📋 最后5条消息:', messages.slice(-5).map(m => ({
                role: m.role,
                content: m.content.substring(0, 50) + '...'
            })));
            console.log('📝 完整chatHistory长度:', chatHistory.length);
            console.log('📝 最后3条chatHistory:', chatHistory.slice(-3).map(b => ({
                role: b.role,
                content: b.content.substring(0, 30) + '...',
                timestamp: b.timestamp
            })));
            
            // 【关键检查】API要求最后一条消息必须是user
            const lastMessage = messages[messages.length - 1];
            if (lastMessage.role !== 'user') {
                console.error('❌ 错误：最后一条消息不是user角色！role =', lastMessage.role);
                console.error('这会导致API返回空的choices数组');
            }
            
            const requestBody = {
                model: config.modelname,
                messages: messages,
                max_tokens: 5000,
                temperature: 1.2
            };

            const apiUrl = config.baseurl.endsWith('/v1') ? 
                           `${config.baseurl}/chat/completions` : 
                           `${config.baseurl}/v1/chat/completions`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 请求失败: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                
                // 清除超时计时器
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('✅ API响应成功，已清除超时计时器');
                }
                
                // 安全访问API数据
                if (!data || !data.choices || !data.choices[0] || 
                    !data.choices[0].message || !data.choices[0].message.content) {
                    throw new Error('API返回数据格式不正确: ' + JSON.stringify(data).substring(0, 200));
                }
                
                let aiResponseText = data.choices[0].message.content.trim();
                console.log("【API原始输出】:", encodeURI(aiResponseText).substring(0, 50));
                aiResponseText = cleanApiResponse(aiResponseText);
                console.log("【API清理后输出】:", encodeURI(aiResponseText).substring(0, 50));
                
                // 隐藏"对方正在输入中..."
                hideTypingIndicator();
                
                // 调用函数来处理并逐条显示消息
                processAndDisplaySegments(aiResponseText);

            } catch (error) {
                console.error("API 调用出错:", error);
                
                // 清除超时计时器
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('❌ API调用出错，已清除超时计时器');
                }
                
                // 显示错误消息
                const errorMessage = document.createElement('div');
                errorMessage.classList.add('message', 'assistant');
                const errorBubble = document.createElement('div');
                errorBubble.classList.add('bubble');
                errorBubble.textContent = `[错误] 无法获取回复。请检查您的设置和网络连接。详细错误：${error.message}`;
                errorMessage.appendChild(errorBubble);
                chatContainer.appendChild(errorMessage);
                scrollToBottom();
                
                hideTypingIndicator();
                isWaitingForAI = false;
                
                // 检查队列，如果有消息可能需要重试
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('📬 错误后发现待发送消息，准备重试');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('📬 错误后发现待发送消息，重启计时器');
                        startBatchTimer();
                    }
                }
            }
        }
        // ====================================

        /**
         * 点击生成按钮，调用 API
         */
        /**
         * 点击发送按钮
         */
        /**
         * 发送消息
         */
        async function generateResponse() {
            let userMessage = userInput.value.trim();
            if (!userMessage) return;

            // 检查配置
            if (!config.baseurl || !config.apikey) {
                showConfigReminder();
                return;
            }
            
            // 保存引用信息
            let quoteInfo = null;
            if (currentQuote) {
                const senderName = currentQuote.role === 'user' ? config.userNickname : config.aiNickname;
                quoteInfo = {
                    sender: senderName,
                    content: currentQuote.content
                };
            }

            // 1. 显示用户消息(如果有引用,传递引用信息)
            const bubble = displayMessage(userMessage, 'user', 1, null, true, null, false, quoteInfo);
            
            // 2. 清除引用预览
            if (currentQuote) {
                clearQuote();
            }
            
            // 3. 清空输入框
            userInput.value = '';
            
            // 4. 将此气泡ID加入待发送队列
            pendingUserMessages.push(bubble.id);
            console.log('📝 添加到队列:', bubble.id, '当前队列长度:', pendingUserMessages.length);
            
            // 5. 启动/重启计时器
            startBatchTimer();
        }
        
        /**
         *滚动到聊天内容底部（双 requestAnimationFrame 确保渲染完成）
         
        /**
         * 滚动到聊天内容底部
         */
        function scrollToBottom() {
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            
            if (contentArea && contentArea.scrollHeight > 0) {
                // 使用requestAnimationFrame确保DOM已渲染，然后立即滚动
                requestAnimationFrame(() => {
                    contentArea.scrollTop = contentArea.scrollHeight;
                });
            }
        }
        
        /**
         * 全局诊断函数 - 在console中调用来检查布局
         */
        window.debugLayout = function() {
            console.log('========== 布局诊断报告 ==========');
            
            const body = document.body;
            const appContainer = document.getElementById('app-container');
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            const chatContainer = document.getElementById('chat-container');
            
            console.log('📱 Body:', {
                height: body.style.height,
                computedHeight: window.getComputedStyle(body).height,
                overflow: window.getComputedStyle(body).overflow
            });
            
            console.log('📦 App容器:', {
                height: appContainer.style.height,
                width: appContainer.style.width,
                computedHeight: window.getComputedStyle(appContainer).height,
                display: window.getComputedStyle(appContainer).display
            });
            
            console.log('📄 活跃页面:', {
                id: activePage ? activePage.id : '无',
                height: activePage ? window.getComputedStyle(activePage).height : '无',
                display: activePage ? window.getComputedStyle(activePage).display : '无',
                flexGrow: activePage ? window.getComputedStyle(activePage).flexGrow : '无'
            });
            
            console.log('📋 Content容器:', {
                found: !!contentArea,
                height: contentArea ? window.getComputedStyle(contentArea).height : '无',
                scrollHeight: contentArea ? contentArea.scrollHeight : '无',
                clientHeight: contentArea ? contentArea.clientHeight : '无',
                offsetHeight: contentArea ? contentArea.offsetHeight : '无',
                display: contentArea ? window.getComputedStyle(contentArea).display : '无',
                overflow: contentArea ? window.getComputedStyle(contentArea).overflow : '无',
                flexGrow: contentArea ? window.getComputedStyle(contentArea).flexGrow : '无',
                minHeight: contentArea ? window.getComputedStyle(contentArea).minHeight : '无'
            });
            
            console.log('💬 Chat容器:', {
                height: chatContainer ? window.getComputedStyle(chatContainer).height : '无',
                scrollHeight: chatContainer ? chatContainer.scrollHeight : '无',
                childCount: chatContainer ? chatContainer.children.length : '无'
            });
            
            console.log('================================');
            console.log('💡 提示: 调用 window.scrollToBottom() 来手动滚动');
        };
        
        console.log('✅ 调试工具已加载，在console中输入 debugLayout() 来检查布局');
        
        
        // ==================== 多角色聊天列表功能 ====================
        
        let charactersList = [];  // 角色列表
        let currentCharacterId = null;  // 当前活跃的角色ID
        
        // 加载角色列表
        function loadCharactersList() {
            const saved = localStorage.getItem('charactersList');
            if (saved) {
                try {
                    charactersList = JSON.parse(saved);
                } catch (e) {
                    console.error('加载角色列表失败:', e);
                    charactersList = [];
                }
            }
        }
        
        // 保存角色列表
        function saveCharactersList() {
            localStorage.setItem('charactersList', JSON.stringify(charactersList));
        }
        
        // 更新聊天页面的头像显示
        function updateChatPageAvatars() {
            // 更新聊天页面头像区域(如果有的话)
            const chatAvatarElements = document.querySelectorAll('#chat-page .message-avatar');
            // 这个函数主要是为了保持一致性,实际头像在displayMessage中渲染
            console.log('💡 聊天页面头像将在下次发送消息时更新');
        }
        
        // 获取默认的长期记忆对象
        function getDefaultLongTermMemory() {
            return {
                basic_info: {},
                emotional_profile: "",
                relationships: "",  // 新增：人际关系
                important_events: [],
                metadata: {
                    total_messages: 0,
                    last_summary_at: 0,
                    last_updated: null,
                    version: 3,  // 版本号升级到3
                    next_memory_id: 1
                }
            };
        }
        
        // 获取默认配置
        function getDefaultCharacterConfig(isFirst) {
            if (isFirst || charactersList.length === 0) {
                // 第一个角色使用硬编码默认值
                return {
                    systemPrompt: '',
                    aiNickname: 'AI助手',
                    userNickname: '我',
                    aiAvatar: null,
                    userAvatar: null,
                    maxContextMessages: 50,
                    batchWaitTime: 7,
                    autoSummaryInterval: 50,
                    maxImportantEvents: 10
                };
            } else {
                // 从第一个角色复制配置
                const firstCharId = charactersList[0].id;
                const firstConfig = localStorage.getItem(`char_${firstCharId}_config`);
                if (firstConfig) {
                    const parsed = JSON.parse(firstConfig);
                    return {
                        systemPrompt: '',  // 系统提示词需要用户填写
                        aiNickname: '',    // 角色昵称需要用户填写
                        userNickname: '',  // 用户昵称需要用户填写
                        aiAvatar: null,    // 头像需要用户上传
                        userAvatar: null,  // 头像需要用户上传
                        maxContextMessages: parsed.maxContextMessages,
                        batchWaitTime: parsed.batchWaitTime,
                        autoSummaryInterval: parsed.autoSummaryInterval,
                        maxImportantEvents: parsed.maxImportantEvents
                    };
                }
                return getDefaultCharacterConfig(true);
            }
        }
        
        // 保存当前角色的所有数据
        function saveCurrentCharacterData() {
            if (!currentCharacterId) return;
            
            console.log('💾 保存角色数据:', currentCharacterId);
            
            // 保存配置
            const currentConfig = {
                systemPrompt: config.systemPrompt,
                aiNickname: config.aiNickname,
                userNickname: config.userNickname,
                aiAvatar: config.aiAvatar,
                userAvatar: config.userAvatar,
                maxContextMessages: config.maxContextMessages,
                batchWaitTime: config.batchWaitTime,
                autoSummaryInterval: config.autoSummaryInterval,
                maxImportantEvents: config.maxImportantEvents
            };
            localStorage.setItem(`char_${currentCharacterId}_config`, JSON.stringify(currentConfig));
            
            // 保存聊天记录
            localStorage.setItem(`char_${currentCharacterId}_chatHistory`, JSON.stringify(chatHistory));
            
            // 保存长期记忆
            localStorage.setItem(`char_${currentCharacterId}_longTermMemory`, JSON.stringify(longTermMemory));
            
            // 保存待总结消息
            localStorage.setItem(`char_${currentCharacterId}_pendingSummaryBubbles`, JSON.stringify(pendingSummaryBubbles));
        }
        
        // 清除当前角色的运行时状态
        function clearRuntimeState() {
            console.log('🧹 清除运行时状态');
            
            // 清除计时器
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
                batchSendTimer = null;
            }
            if (apiTimeoutTimer) {
                clearTimeout(apiTimeoutTimer);
                apiTimeoutTimer = null;
            }
            
            // 重置状态
            pendingUserMessages = [];
            isWaitingForAI = false;
            hasReachedWaitTime = false;
            
            // 【修复】重置懒加载状态
            currentLoadedStart = 0;
            isLoadingMore = false;
            
            // 【修复】清除滚动监听标记，允许新角色重新绑定
            const chatPage = document.getElementById('chat-page');
            if (chatPage) {
                const scrollContainer = chatPage.querySelector('.content');
                if (scrollContainer) {
                    scrollContainer.dataset.scrollListenerBound = 'false';
                }
            }
            
            // 清除输入中提示
            const typingIndicator = document.getElementById('typing-indicator');
            if (typingIndicator) {
                typingIndicator.remove();
            }
        }
        
        // 加载角色的所有数据
        function loadCharacterData(characterId) {
            console.log('📂 加载角色数据:', characterId);
            
            const character = charactersList.find(c => c.id === characterId);
            if (!character) {
                console.error('角色不存在:', characterId);
                return;
            }
            
            currentCharacterId = characterId;
            
            // 加载配置
            const savedConfig = localStorage.getItem(`char_${characterId}_config`);
            if (savedConfig) {
                const charConfig = JSON.parse(savedConfig);
                config.systemPrompt = charConfig.systemPrompt || '';
                config.aiNickname = charConfig.aiNickname || 'AI助手';
                config.userNickname = charConfig.userNickname || '我';
                config.aiAvatar = charConfig.aiAvatar || null;
                config.userAvatar = charConfig.userAvatar || null;
                config.maxContextMessages = charConfig.maxContextMessages || 50;
                config.batchWaitTime = charConfig.batchWaitTime || 7;
                config.autoSummaryInterval = charConfig.autoSummaryInterval || 50;
                config.maxImportantEvents = charConfig.maxImportantEvents || 10;
                
                console.log('📝 已加载配置 - AI昵称:', config.aiNickname, '用户昵称:', config.userNickname);
                
                // 更新设置页面的头像预览
                renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname.substring(0, 1));
                renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname.substring(0, 1));
                document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
                document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            } else {
                // 如果没有配置,使用默认配置
                console.warn('⚠️ 未找到角色配置,使用默认值:', characterId);
                const defaultConfig = getDefaultCharacterConfig(false);
                config.systemPrompt = defaultConfig.systemPrompt;
                config.aiNickname = defaultConfig.aiNickname;
                config.userNickname = defaultConfig.userNickname;
                config.aiAvatar = defaultConfig.aiAvatar;
                config.userAvatar = defaultConfig.userAvatar;
                config.maxContextMessages = defaultConfig.maxContextMessages;
                config.batchWaitTime = defaultConfig.batchWaitTime;
                config.autoSummaryInterval = defaultConfig.autoSummaryInterval;
                config.maxImportantEvents = defaultConfig.maxImportantEvents;
                
                // 更新设置页面的头像预览
                renderAvatar(document.getElementById('ai-avatar-preview-settings'), config.aiAvatar, 'ai', config.aiNickname.substring(0, 1));
                renderAvatar(document.getElementById('user-avatar-preview-settings'), config.userAvatar, 'user', config.userNickname.substring(0, 1));
                document.getElementById('ai-avatar-remove-btn-settings').style.display = config.aiAvatar ? 'inline-block' : 'none';
                document.getElementById('user-avatar-remove-btn-settings').style.display = config.userAvatar ? 'inline-block' : 'none';
            }
            
            // 加载聊天记录
            const savedHistory = localStorage.getItem(`char_${characterId}_chatHistory`);
            chatHistory = savedHistory ? JSON.parse(savedHistory) : [];
            
            // 加载长期记忆
            const savedMemory = localStorage.getItem(`char_${characterId}_longTermMemory`);
            longTermMemory = savedMemory ? JSON.parse(savedMemory) : getDefaultLongTermMemory();
            
            // 加载待总结消息
            const savedPending = localStorage.getItem(`char_${characterId}_pendingSummaryBubbles`);
            pendingSummaryBubbles = savedPending ? JSON.parse(savedPending) : [];
            
            // 更新聊天页面UI
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement) {
                chatNameElement.textContent = config.aiNickname;
                console.log('✅ 聊天框标题已更新为:', config.aiNickname);
            }
            
            // 更新聊天页面的头像
            updateChatPageAvatars();
            
            console.log('✅ 角色数据加载完成');
        }
        
        // 切换到指定角色
        function switchToCharacter(characterId) {
            console.log('🔄 切换角色:', currentCharacterId, '->', characterId);
            
            // 1. 保存当前角色数据
            if (currentCharacterId && currentCharacterId !== characterId) {
                saveCurrentCharacterData();
                clearRuntimeState();
            }
            
            // 2. 加载新角色数据
            loadCharacterData(characterId);
            
            // 3. 【修复】使用懒加载重新渲染聊天界面
            loadHistoryUI();
        }
        
        // 渲染角色列表
        function renderCharactersList() {
            const container = document.getElementById('characters-list-container');
            
            if (charactersList.length === 0) {
                container.innerHTML = `
                    <div class="character-empty-list">
                        <div style="font-size: 64px; margin-bottom: 16px; opacity: 0.3;">💬</div>
                        <div>暂无聊天</div>
                        <div style="font-size: 13px; margin-top: 8px;">点击右上角"+"添加角色</div>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = '';
            
            charactersList.forEach(character => {
                const savedHistory = localStorage.getItem(`char_${character.id}_chatHistory`);
                const history = savedHistory ? JSON.parse(savedHistory) : [];
                const lastMsg = history.length > 0 ? history[history.length - 1] : null;
                
                const savedConfig = localStorage.getItem(`char_${character.id}_config`);
                const charConfig = savedConfig ? JSON.parse(savedConfig) : {};
                const userNick = charConfig.userNickname || '我';
                const aiAvatar = charConfig.aiAvatar;
                const aiNickname = charConfig.aiNickname || 'AI';
                
                const preview = lastMsg 
                    ? (lastMsg.role === 'user' ? `${userNick}: ` : '') + lastMsg.content.substring(0, 30)
                    : '开始聊天...';
                
                const item = document.createElement('div');
                item.className = 'character-list-item';
                item.onclick = () => openCharacterChat(character.id);
                
                // 创建头像容器
                const avatarContainer = document.createElement('div');
                avatarContainer.className = 'character-list-avatar';
                
                if (aiAvatar) {
                    const img = document.createElement('img');
                    img.src = aiAvatar;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    avatarContainer.appendChild(img);
                } else {
                    const defaultDiv = document.createElement('div');
                    defaultDiv.className = 'default-avatar ai';
                    defaultDiv.textContent = aiNickname.substring(0, 1);
                    avatarContainer.appendChild(defaultDiv);
                }
                
                const infoDiv = document.createElement('div');
                infoDiv.className = 'character-list-info';
                infoDiv.innerHTML = `
                    <div class="character-list-name">${aiNickname}</div>
                    <div class="character-list-preview">${preview}</div>
                `;
                
                item.appendChild(avatarContainer);
                item.appendChild(infoDiv);
                container.appendChild(item);
            });
        }
        
        // 打开角色聊天
        function openCharacterChat(characterId) {
            switchToCharacter(characterId);
            showPage('chat-page');
        }
        
        // 返回聊天列表
        document.getElementById('back-to-chat-list-btn').onclick = function() {
            if (currentCharacterId) {
                saveCurrentCharacterData();
                clearRuntimeState();
            }
            renderCharactersList();
            showPage('chat-list-page');
        };
        
        // 加号菜单
        document.getElementById('add-character-menu-btn').onclick = function(e) {
            e.stopPropagation();
            document.getElementById('character-add-menu').classList.toggle('active');
        };
        
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('character-add-menu');
            const btn = document.getElementById('add-character-menu-btn');
            if (menu && !menu.contains(e.target) && e.target !== btn) {
                menu.classList.remove('active');
            }
        });
        
        // 新建角色模态框
        function openNewCharacterModal() {
            document.getElementById('character-add-menu').classList.remove('active');
            document.getElementById('new-character-modal').classList.add('active');
        }
        
        function closeNewCharacterModal() {
            document.getElementById('new-character-modal').classList.remove('active');
            document.getElementById('new-character-name').value = '';
            document.getElementById('new-character-ai-nickname').value = '';
            document.getElementById('new-character-user-nickname').value = '';
            document.getElementById('new-character-prompt').value = '';
            
            // 清除临时头像
            tempNewCharacterAvatar = null;
            const preview = document.getElementById('new-character-avatar-preview');
            preview.innerHTML = '<div class="default-avatar ai">AI</div>';
        }
        
        function confirmCreateCharacter() {
            const characterName = document.getElementById('new-character-name').value.trim();
            const aiNickname = document.getElementById('new-character-ai-nickname').value.trim();
            const userNickname = document.getElementById('new-character-user-nickname').value.trim();
            const systemPrompt = document.getElementById('new-character-prompt').value.trim();
            
            // 验证必填字段
            if (!characterName) {
                alert('❌ 请输入角色姓名');
                return;
            }
            if (!aiNickname) {
                alert('❌ 请输入角色昵称');
                return;
            }
            if (!userNickname) {
                alert('❌ 请输入用户昵称');
                return;
            }
            
            const newId = `char_${Date.now()}`;
            const isFirst = charactersList.length === 0;
            
            // 创建角色基本信息
            const character = {
                id: newId,
                name: characterName,
                createdAt: new Date().toISOString()
            };
            
            // 获取默认配置
            const defaultConfig = getDefaultCharacterConfig(isFirst);
            defaultConfig.systemPrompt = systemPrompt;
            defaultConfig.aiNickname = aiNickname;
            defaultConfig.userNickname = userNickname;
            defaultConfig.aiAvatar = tempNewCharacterAvatar; // 使用上传的头像
            
            console.log('💾 保存角色配置:', defaultConfig);
            
            // 保存到localStorage
            charactersList.push(character);
            saveCharactersList();
            localStorage.setItem(`char_${newId}_config`, JSON.stringify(defaultConfig));
            localStorage.setItem(`char_${newId}_chatHistory`, JSON.stringify([]));
            localStorage.setItem(`char_${newId}_longTermMemory`, JSON.stringify(getDefaultLongTermMemory()));
            localStorage.setItem(`char_${newId}_pendingSummaryBubbles`, JSON.stringify([]));
            
            closeNewCharacterModal();
            renderCharactersList();
            
            // 立即切换到新创建的角色
            switchToCharacter(newId);
            showPage('chat-page');
            
            console.log('✅ 角色创建成功并已切换:', newId, '姓名:', characterName, '昵称:', aiNickname);
        }
        
        // 导入角色模态框
        function openImportCharacterModal() {
            document.getElementById('character-add-menu').classList.remove('active');
            document.getElementById('import-character-modal').classList.add('active');
        }
        
        function closeImportCharacterModal() {
            document.getElementById('import-character-modal').classList.remove('active');
            document.getElementById('import-character-data').value = '';
        }
        
        function confirmImportCharacter() {
            const data = document.getElementById('import-character-data').value.trim();
            
            if (!data) {
                alert('请输入角色数据');
                return;
            }
            
            try {
                const imported = JSON.parse(data);
                
                if (!imported.name || !imported.aiNickname || !imported.userNickname) {
                    throw new Error('缺少必要字段: name, aiNickname, userNickname');
                }
                
                const newId = `char_${Date.now()}`;
                const isFirst = charactersList.length === 0;
                
                const character = {
                    id: newId,
                    name: imported.name,
                    avatar: imported.avatar || '🤖',
                    createdAt: new Date().toISOString()
                };
                
                const defaultConfig = getDefaultCharacterConfig(isFirst);
                defaultConfig.systemPrompt = imported.systemPrompt || '';
                defaultConfig.aiNickname = imported.aiNickname;
                defaultConfig.userNickname = imported.userNickname;
                
                charactersList.push(character);
                saveCharactersList();
                localStorage.setItem(`char_${newId}_config`, JSON.stringify(defaultConfig));
                localStorage.setItem(`char_${newId}_chatHistory`, JSON.stringify([]));
                localStorage.setItem(`char_${newId}_longTermMemory`, JSON.stringify(getDefaultLongTermMemory()));
                localStorage.setItem(`char_${newId}_pendingSummaryBubbles`, JSON.stringify([]));
                
                closeImportCharacterModal();
                renderCharactersList();
                
                // 立即切换到导入的角色
                switchToCharacter(newId);
                showPage('chat-page');
                
                console.log('✅ 角色导入成功并已切换:', newId);
            } catch (e) {
                alert('导入失败: ' + e.message);
            }
        }
        
        document.getElementById('import-character-file').onchange = function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    document.getElementById('import-character-data').value = event.target.result;
                };
                reader.readAsText(file);
            }
        };
        
        // 搜索功能
        document.getElementById('character-search-input').oninput = function(e) {
            const keyword = e.target.value.toLowerCase();
            document.querySelectorAll('.character-list-item').forEach(item => {
                const name = item.querySelector('.character-list-name').textContent.toLowerCase();
                item.style.display = name.includes(keyword) ? 'flex' : 'none';
            });
        };
        
        // 重写saveChatHistory,使其保存到当前角色
        const originalSaveChatHistory = saveChatHistory;
        saveChatHistory = function() {
            if (currentCharacterId) {
                saveCurrentCharacterData();
            } else {
                originalSaveChatHistory();
            }
        };
        
        // 初始化
        loadCharactersList();
        
        // ==================== 头像上传功能 ====================
        
        // 新建角色的头像上传
        document.getElementById('new-character-avatar-input').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    tempNewCharacterAvatar = avatarData;
                    
                    const preview = document.getElementById('new-character-avatar-preview');
                    const img = document.createElement('img');
                    img.src = avatarData;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.borderRadius = '6px';
                    preview.innerHTML = '';
                    preview.appendChild(img);
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 设置页面 - AI头像上传
        document.getElementById('ai-avatar-input-settings').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    config.aiAvatar = avatarData;
                    
                    renderAvatar(document.getElementById('ai-avatar-preview-settings'), avatarData, 'ai', config.aiNickname.substring(0, 1));
                    document.getElementById('ai-avatar-remove-btn-settings').style.display = 'inline-block';
                    
                    // 保存到当前角色
                    if (currentCharacterId) {
                        saveCurrentCharacterData();
                    }
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 设置页面 - 用户头像上传
        document.getElementById('user-avatar-input-settings').onchange = async function(e) {
            const file = e.target.files[0];
            if (file) {
                try {
                    const avatarData = await processAvatarImage(file);
                    config.userAvatar = avatarData;
                    
                    renderAvatar(document.getElementById('user-avatar-preview-settings'), avatarData, 'user', config.userNickname.substring(0, 1));
                    document.getElementById('user-avatar-remove-btn-settings').style.display = 'inline-block';
                    
                    // 保存到当前角色
                    if (currentCharacterId) {
                        saveCurrentCharacterData();
                    }
                } catch (error) {
                    alert(error);
                }
            }
        };
        
        // 移除AI头像
        function removeAIAvatar() {
            config.aiAvatar = null;
            renderAvatar(document.getElementById('ai-avatar-preview-settings'), null, 'ai', config.aiNickname.substring(0, 1));
            document.getElementById('ai-avatar-remove-btn-settings').style.display = 'none';
            if (currentCharacterId) {
                saveCurrentCharacterData();
            }
        }
        
        // 移除用户头像
        function removeUserAvatar() {
            config.userAvatar = null;
            renderAvatar(document.getElementById('user-avatar-preview-settings'), null, 'user', config.userNickname.substring(0, 1));
            document.getElementById('user-avatar-remove-btn-settings').style.display = 'none';
            if (currentCharacterId) {
                saveCurrentCharacterData();
            }
        }
        
        // 拉黑好友(暂未实现)
        function blockCharacter() {
            alert('拉黑功能暂未开放');
        }
        
        // 删除好友
        function deleteCharacter() {
            if (!currentCharacterId) {
                alert('未选择角色');
                return;
            }
            
            const character = charactersList.find(c => c.id === currentCharacterId);
            if (!character) {
                alert('角色不存在');
                return;
            }
            
            const characterName = character.name || config.aiNickname || '该角色';
            
            // 二次确认
            const confirmed = confirm(
                `确定要删除"${characterName}"吗?\n\n` +
                `此操作将永久删除:\n` +
                `• 所有聊天记录\n` +
                `• 长期记忆数据\n` +
                `• 角色配置信息\n\n` +
                `此操作无法撤销!`
            );
            
            if (!confirmed) {
                return;
            }
            
            // 再次确认
            const doubleConfirmed = confirm(`最后确认:真的要删除"${characterName}"的所有数据吗?`);
            if (!doubleConfirmed) {
                return;
            }
            
            console.log('🗑️ 开始删除角色:', currentCharacterId);
            
            // 从角色列表中移除
            charactersList = charactersList.filter(c => c.id !== currentCharacterId);
            saveCharactersList();
            
            // 删除localStorage中的所有数据
            localStorage.removeItem(`char_${currentCharacterId}_config`);
            localStorage.removeItem(`char_${currentCharacterId}_chatHistory`);
            localStorage.removeItem(`char_${currentCharacterId}_longTermMemory`);
            localStorage.removeItem(`char_${currentCharacterId}_pendingSummaryBubbles`);
            
            console.log('✅ 角色已删除:', currentCharacterId);
            
            // 清空当前状态
            currentCharacterId = null;
            chatHistory = [];
            longTermMemory = getDefaultLongTermMemory();
            pendingSummaryBubbles = [];
            clearRuntimeState();
            
            // 返回角色列表页面
            showPage('chat-list-page');
            renderCharactersList();
            
            alert(`已删除"${characterName}"的所有数据`);
        }
        
        // ==================== 底部导航栏功能 ====================
        
        /**
         * 初始化底部导航栏
         */
        function initializeBottomNav() {
            const navItems = document.querySelectorAll('.nav-item');
            
            navItems.forEach(item => {
                item.addEventListener('click', () => {
                    const targetPage = item.getAttribute('data-page');
                    switchBottomNavPage(targetPage);
                });
            });
        }
        
        /**
         * 切换底部导航页面
         */
        function switchBottomNavPage(pageName) {
            const pageMap = {
                'chat-list': 'chat-list-page',
                'contacts': 'contacts-page',
                'discover': 'discover-page',
                'me': 'me-page'
            };
            
            const targetPageId = pageMap[pageName];
            if (!targetPageId) return;
            
            // 显示目标页面
            showPage(targetPageId);
            
            // 更新所有底部导航栏的active状态
            document.querySelectorAll('.bottom-nav').forEach(nav => {
                nav.querySelectorAll('.nav-item').forEach(item => {
                    if (item.getAttribute('data-page') === pageName) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });
            });
        }
        
        // ==================== 全局消息通知功能 ====================
        
        let notificationTimeout = null;
        
        /**
         * 初始化消息通知
         */
        function initializeMessageNotification() {
            const notification = document.getElementById('message-notification');
            
            // 点击通知跳转到对应聊天
            notification.addEventListener('click', function(e) {
                // 如果点击的是关闭按钮，只关闭通知
                if (e.target.classList.contains('message-notification-close')) {
                    hideMessageNotification();
                    return;
                }
                
                // 否则跳转到聊天页面
                if (currentCharacterId) {
                    showPage('chat-page');
                    hideMessageNotification();
                }
            });
        }
        
        /**
         * 显示消息通知
         * @param {string} characterId - 角色ID
         * @param {string} characterName - 角色名称
         * @param {string} message - 消息内容
         * @param {string} avatarData - 头像数据
         */
        function showMessageNotification(characterId, characterName, message, avatarData) {
            // 如果当前在聊天页面，不显示通知
            const currentPage = document.querySelector('.page.active');
            if (currentPage && currentPage.id === 'chat-page') {
                return;
            }
            
            const notification = document.getElementById('message-notification');
            const avatarEl = document.getElementById('notification-avatar');
            const nameEl = document.getElementById('notification-name');
            const textEl = document.getElementById('notification-text');
            
            // 设置头像
            if (avatarData) {
                avatarEl.innerHTML = `<img src="${avatarData}" style="width: 40px; height: 40px; border-radius: 6px; object-fit: cover;">`;
            } else {
                const firstLetter = characterName.substring(0, 1);
                avatarEl.innerHTML = `<div class="default-avatar ai" style="width: 40px; height: 40px; border-radius: 6px; font-size: 16px;">${firstLetter}</div>`;
            }
            
            // 设置内容
            nameEl.textContent = characterName;
            textEl.textContent = message;
            
            // 显示通知
            notification.classList.remove('hiding');
            notification.classList.add('show');
            
            // 清除之前的定时器
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
            
            // 3秒后自动隐藏
            notificationTimeout = setTimeout(() => {
                hideMessageNotification();
            }, 3000);
        }
        
        /**
         * 隐藏消息通知
         */
        function hideMessageNotification() {
            const notification = document.getElementById('message-notification');
            notification.classList.add('hiding');
            
            setTimeout(() => {
                notification.classList.remove('show', 'hiding');
            }, 300);
            
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null;
            }
        }
        
        // ==================== 收藏功能 ====================
        
        /**
         * 获取收藏列表
         */
        function getFavorites() {
            try {
                if (!currentCharacterId) return [];
                const key = `char_${currentCharacterId}_favorites`;
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : [];
            } catch (error) {
                console.error('❌ 获取收藏列表失败:', error);
                return [];
            }
        }
        
        /**
         * 保存收藏列表
         */
        function saveFavorites(favorites) {
            try {
                if (!currentCharacterId) return;
                const key = `char_${currentCharacterId}_favorites`;
                localStorage.setItem(key, JSON.stringify(favorites));
                console.log('✅ 收藏列表已保存');
            } catch (error) {
                console.error('❌ 保存收藏列表失败:', error);
            }
        }
        
        /**
         * 收藏单条消息
         */
        function favoriteSingleMessage(bubble) {
            const favorites = getFavorites();
            
            // 检查是否已收藏
            const exists = favorites.find(fav => fav.id === bubble.id);
            if (exists) {
                showToast('该消息已在收藏中');
                return;
            }
            
            // 添加到收藏
            const favoriteItem = {
                id: bubble.id,
                content: bubble.content,
                role: bubble.role,
                timestamp: bubble.timestamp || new Date().toISOString(),
                favoritedAt: new Date().toISOString(),
                senderName: bubble.role === 'user' ? config.userNickname : config.aiNickname
            };
            
            favorites.unshift(favoriteItem); // 新收藏放在最前面
            saveFavorites(favorites);
            showToast('已添加到收藏');
            console.log('⭐ 收藏消息:', bubble.id);
        }
        
        /**
         * 批量收藏消息
         */
        function favoriteMultipleMessages(bubbles) {
            const favorites = getFavorites();
            let addedCount = 0;
            
            bubbles.forEach(bubble => {
                // 检查是否已收藏
                const exists = favorites.find(fav => fav.id === bubble.id);
                if (!exists) {
                    const favoriteItem = {
                        id: bubble.id,
                        content: bubble.content,
                        role: bubble.role,
                        timestamp: bubble.timestamp || new Date().toISOString(),
                        favoritedAt: new Date().toISOString(),
                        senderName: bubble.role === 'user' ? config.userNickname : config.aiNickname
                    };
                    favorites.unshift(favoriteItem);
                    addedCount++;
                }
            });
            
            if (addedCount > 0) {
                saveFavorites(favorites);
                showToast(`已添加 ${addedCount} 条消息到收藏`);
                console.log('⭐ 批量收藏:', addedCount, '条消息');
            } else {
                showToast('所有消息已在收藏中');
            }
        }
        
        // ==================== 多选模式功能 ====================
        
        /**
         * 进入多选模式
         */
        function enterMultiSelectMode(initialBubble = null) {
            console.log('🎯 进入多选模式，初始气泡:', initialBubble);
            
            isMultiSelectMode = true;
            selectedBubbles.clear();
            
            // 如果有初始选中的气泡，添加到选中列表
            if (initialBubble) {
                selectedBubbles.add(initialBubble.id);
                console.log('✅ 添加初始选中气泡:', initialBubble.id);
            }
            
            // 添加多选模式样式
            document.body.classList.add('multi-select-mode-active');
            console.log('✅ 添加body样式类');
            
            // 显示顶部工具栏
            const header = document.getElementById('multi-select-header');
            if (header) {
                header.classList.add('active');
                console.log('✅ 显示顶部工具栏');
            } else {
                console.error('❌ 未找到顶部工具栏元素');
            }
            
            // 显示搜索框
            const search = document.getElementById('multi-select-search');
            if (search) {
                search.classList.add('active');
                console.log('✅ 显示搜索框');
            }
            
            // 显示Select按钮
            const btnContainer = document.getElementById('multi-select-btn-container');
            if (btnContainer) {
                btnContainer.classList.add('active');
                console.log('✅ 显示Select按钮');
            }
            
            // 显示底部工具栏
            const toolbar = document.getElementById('multi-select-toolbar');
            if (toolbar) {
                toolbar.classList.add('active');
                console.log('✅ 显示底部工具栏');
            } else {
                console.error('❌ 未找到底部工具栏元素');
            }
            
            // 隐藏聊天页面的header
            const chatHeader = document.querySelector('#chat-page .header');
            if (chatHeader) {
                chatHeader.style.display = 'none';
            }
            
            // 为所有消息添加复选框
            renderMultiSelectCheckboxes();
            
            // 更新选中数量显示
            updateMultiSelectInfo();
            
            console.log('✅ 进入多选模式完成');
        }
        
        /**
         * 退出多选模式
         */
        function exitMultiSelectMode() {
            isMultiSelectMode = false;
            selectedBubbles.clear();
            
            // 移除多选模式样式
            document.body.classList.remove('multi-select-mode-active');
            
            // 隐藏顶部工具栏
            const header = document.getElementById('multi-select-header');
            if (header) {
                header.classList.remove('active');
            }
            
            // 隐藏搜索框
            const search = document.getElementById('multi-select-search');
            if (search) {
                search.classList.remove('active');
            }
            
            // 隐藏Select按钮
            const btnContainer = document.getElementById('multi-select-btn-container');
            if (btnContainer) {
                btnContainer.classList.remove('active');
            }
            
            // 隐藏底部工具栏
            const toolbar = document.getElementById('multi-select-toolbar');
            if (toolbar) {
                toolbar.classList.remove('active');
            }
            
            // 显示聊天页面的header
            const chatHeader = document.querySelector('#chat-page .header');
            if (chatHeader) {
                chatHeader.style.display = 'flex';
            }
            
            // 移除所有消息的左margin
            const messages = document.querySelectorAll('#chat-container .message');
            messages.forEach(messageEl => {
                messageEl.style.marginLeft = '';
                
                // 移除点击事件监听器
                if (messageEl._multiSelectClickHandler) {
                    messageEl.removeEventListener('click', messageEl._multiSelectClickHandler);
                    delete messageEl._multiSelectClickHandler;
                }
            });
            
            // 移除所有复选框
            document.querySelectorAll('.multi-select-checkbox').forEach(checkbox => {
                checkbox.remove();
            });
            
            console.log('✅ 退出多选模式');
        }
        
        /**
         * 为单个消息添加多选复选框
         */
        function addMultiSelectCheckbox(messageEl, bubbleId) {
            // 如果已有复选框，跳过
            if (messageEl.querySelector('.multi-select-checkbox')) {
                console.log('⏭️ 跳过已有复选框的消息:', bubbleId);
                return;
            }
            
            // 创建复选框
            const checkbox = document.createElement('div');
            checkbox.className = 'multi-select-checkbox';
            if (selectedBubbles.has(bubbleId)) {
                checkbox.classList.add('checked');
            }
            
            // 点击复选框切换选中状态
            checkbox.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('🖱️ 点击复选框:', bubbleId);
                toggleBubbleSelection(bubbleId);
            });
            
            // 添加到消息元素
            messageEl.style.position = 'relative';
            messageEl.appendChild(checkbox);
            
            // 为整条消息添加点击事件（点击消息也可以选中）
            const messageClickHandler = (e) => {
                // 如果点击的是复选框，不处理（已经在复选框的事件里处理了）
                if (e.target.classList.contains('multi-select-checkbox')) {
                    return;
                }
                
                // 如果点击的是长按菜单、链接等，不处理
                if (e.target.closest('.bubble-menu') || 
                    e.target.tagName === 'A' || 
                    e.target.closest('a')) {
                    return;
                }
                
                console.log('🖱️ 点击消息:', bubbleId);
                toggleBubbleSelection(bubbleId);
            };
            
            messageEl.addEventListener('click', messageClickHandler);
            
            // 保存事件处理器引用，以便之后移除
            messageEl._multiSelectClickHandler = messageClickHandler;
            
            console.log('✅ 添加复选框和点击事件:', bubbleId);
        }
        
        /**
         * 渲染多选复选框
         */
        function renderMultiSelectCheckboxes() {
            const messages = document.querySelectorAll('#chat-container .message');
            console.log('📋 开始渲染复选框，找到消息数:', messages.length);
            console.log('📋 多选模式状态:', isMultiSelectMode);
            console.log('📋 body是否有multi-select-mode-active类:', document.body.classList.contains('multi-select-mode-active'));
            
            let addedCount = 0;
            messages.forEach((messageEl, index) => {
                // data-bubble-id 直接在 message 元素上
                const bubbleId = messageEl.dataset.bubbleId;
                if (!bubbleId) {
                    console.warn('⚠️ 消息元素没有bubble-id, 索引:', index);
                    return;
                }
                
                addMultiSelectCheckbox(messageEl, bubbleId);
                addedCount++;
            });
            
            console.log(`✅ 完成渲染复选框，共添加 ${addedCount} 个`);
            
            // 验证复选框是否真的在DOM中
            const checkboxes = document.querySelectorAll('.multi-select-checkbox');
            console.log('✅ DOM中实际的复选框数量:', checkboxes.length);
            if (checkboxes.length > 0) {
                const firstCheckbox = checkboxes[0];
                console.log('✅ 第一个复选框的display样式:', window.getComputedStyle(firstCheckbox).display);
                console.log('✅ 第一个复选框的位置:', firstCheckbox.style.position || window.getComputedStyle(firstCheckbox).position);
            }
        }
        
        /**
         * 切换气泡选中状态
         */
        function toggleBubbleSelection(bubbleId) {
            if (selectedBubbles.has(bubbleId)) {
                selectedBubbles.delete(bubbleId);
                console.log('➖ 取消选中:', bubbleId);
            } else {
                selectedBubbles.add(bubbleId);
                console.log('➕ 选中:', bubbleId);
            }
            
            // 更新复选框状态 - 直接通过dataset查找message元素
            const messages = document.querySelectorAll('#chat-container .message');
            let foundMessage = null;
            messages.forEach(msg => {
                if (msg.dataset.bubbleId === bubbleId) {
                    foundMessage = msg;
                }
            });
            
            if (foundMessage) {
                const checkbox = foundMessage.querySelector('.multi-select-checkbox');
                if (checkbox) {
                    if (selectedBubbles.has(bubbleId)) {
                        checkbox.classList.add('checked');
                    } else {
                        checkbox.classList.remove('checked');
                    }
                    console.log('✅ 更新复选框状态:', bubbleId, selectedBubbles.has(bubbleId));
                } else {
                    console.warn('⚠️ 未找到复选框元素:', bubbleId);
                }
            } else {
                console.warn('⚠️ 未找到消息元素:', bubbleId);
            }
            
            // 更新选中数量显示
            updateMultiSelectInfo();
            console.log('📊 当前选中数量:', selectedBubbles.size);
        }
        
        /**
         * 更新多选信息显示
         */
        function updateMultiSelectInfo() {
            const count = selectedBubbles.size;
            const countEl = document.getElementById('multi-select-count');
            if (countEl) {
                countEl.textContent = `已选择${count}条`;
            }
            
            // 更新Select按钮文字
            const selectBtnText = document.getElementById('select-btn-text');
            const selectBtnIcon = document.getElementById('select-btn-icon');
            if (selectBtnText && selectBtnIcon) {
                const totalMessages = document.querySelectorAll('#chat-container .message').length;
                if (count === totalMessages && count > 0) {
                    selectBtnText.textContent = '取消选择';
                    selectBtnIcon.textContent = '▲';
                } else {
                    selectBtnText.textContent = '选择';
                    selectBtnIcon.textContent = '▼';
                }
            }
            
            // 更新底部按钮状态
            const toolbarBtns = document.querySelectorAll('.multi-select-toolbar-btn');
            toolbarBtns.forEach(btn => {
                if (count === 0) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
            });
        }
        
        /**
         * 全选/取消全选
         */
        /**
         * 选择功能（开发中）
         */
        function toggleSelectAll() {
            showToast('选择功能开发中');
        }
        
        /**
         * 确认转发类型（从按钮调用的入口）
         */
        function confirmForwardType() {
            forwardSelectedMessages();
        }
        
        /**
         * 转发选中的消息
         */
        function forwardSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要转发的消息');
                return;
            }
            
            // 获取选中的气泡
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 如果只选择了1条消息，直接转发
            if (bubbles.length === 1) {
                window.pendingForwardMessages = bubbles;
                exitMultiSelectMode();
                showForwardSelectPage();
                return;
            }
            
            // 多条消息时，询问转发方式
            const choice = confirm('选择转发方式:\n\n点击"确定"进行【逐条转发】\n点击"取消"进行【合并转发】');
            
            if (choice) {
                // 逐条转发
                window.pendingForwardMessages = bubbles;
            } else {
                // 合并转发
                const mergedContent = bubbles.map(b => {
                    const sender = b.role === 'user' ? config.userNickname : config.aiNickname;
                    return `${sender}：${b.content}`;
                }).join('\n\n');
                
                const mergedMessage = {
                    id: generateUniqueId(),
                    role: 'user',
                    content: `[合并转发 ${bubbles.length}条消息]\n\n${mergedContent}`,
                    timestamp: new Date().toISOString()
                };
                
                window.pendingForwardMessages = [mergedMessage];
            }
            
            // 退出多选模式
            exitMultiSelectMode();
            
            // 显示转发选择页面
            showForwardSelectPage();
        }
        
        /**
         * 合并转发选中的消息
         */
        function mergeForwardSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要转发的消息');
                return;
            }
            
            // 获取选中的气泡
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 合并成一条消息
            const mergedContent = bubbles.map(b => {
                const sender = b.role === 'user' ? config.userNickname : config.aiNickname;
                return `${sender}：${b.content}`;
            }).join('\n\n');
            
            // 创建合并后的消息对象
            const mergedMessage = {
                id: generateUniqueId(),
                role: 'user',
                content: `[合并转发 ${bubbles.length}条消息]\n\n${mergedContent}`,
                timestamp: new Date().toISOString()
            };
            
            // 保存要转发的消息
            window.pendingForwardMessages = [mergedMessage];
            
            // 退出多选模式
            exitMultiSelectMode();
            
            // 显示转发选择页面
            showForwardSelectPage();
        }
        
        /**
         * 显示更多选项（占位）
         */
        function showMoreOptions() {
            showToast('更多功能开发中');
        }
        
        /**
         * 多选模式下的更多选项
         */
        function showMoreMultiSelectOptions() {
            showToast('更多功能开发中');
        }
        
        /**
         * 收藏选中的消息
         */
        function favoriteSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要收藏的消息');
                return;
            }
            
            // 获取选中的气泡
            const bubbles = chatHistory.filter(b => selectedBubbles.has(b.id));
            
            if (bubbles.length === 0) {
                showToast('未找到选中的消息');
                return;
            }
            
            // 批量收藏
            favoriteMultipleMessages(bubbles);
            
            // 退出多选模式
            exitMultiSelectMode();
        }
        
        /**
         * 删除选中的消息
         */
        function deleteSelectedMessages() {
            if (selectedBubbles.size === 0) {
                showToast('请先选择要删除的消息');
                return;
            }
            
            const selectedCount = selectedBubbles.size;
            
            // 二次确认
            if (!confirm(`确定要删除选中的 ${selectedCount} 条消息吗？`)) {
                return;
            }
            
            console.log('🗑️ 准备删除消息:', Array.from(selectedBubbles));
            
            // 删除选中的气泡
            let deletedCount = 0;
            selectedBubbles.forEach(bubbleId => {
                // 从聊天记录中删除
                const beforeLength = chatHistory.length;
                chatHistory = chatHistory.filter(b => b.id !== bubbleId);
                pendingSummaryBubbles = pendingSummaryBubbles.filter(b => b.id !== bubbleId);
                
                if (chatHistory.length < beforeLength) {
                    deletedCount++;
                }
                
                // 从UI中删除 - 使用更精确的选择器
                const bubbleElement = document.querySelector(`[data-bubble-id="${bubbleId}"]`);
                if (bubbleElement) {
                    const messageDiv = bubbleElement.closest('.message');
                    if (messageDiv) {
                        messageDiv.remove();
                        console.log('✅ 删除UI元素:', bubbleId);
                    }
                } else {
                    console.warn('⚠️ 未找到气泡元素:', bubbleId);
                }
            });
            
            // 保存更改
            saveChatHistory();
            
            showToast(`已删除 ${deletedCount} 条消息`);
            console.log('🗑️ 批量删除完成:', deletedCount, '条消息');
            
            // 退出多选模式
            exitMultiSelectMode();
        }
        
        /**
         * 转发单条消息
         */
        function forwardSingleMessage(bubble) {
            // 保存要转发的消息
            window.pendingForwardMessages = [bubble];
            // 显示转发选择页面
            showForwardSelectPage();
        }
        
        // ==================== 转发功能 ====================
        
        /**
         * 显示转发选择页面
         */
        function showForwardSelectPage() {
            console.log('📤 显示转发选择页面');
            
            // 渲染角色列表
            renderForwardCharactersList();
            
            // 显示页面
            showPage('forward-select-page');
        }
        
        /**
         * 渲染转发目标角色列表
         */
        function renderForwardCharactersList() {
            const container = document.getElementById('forward-characters-list');
            const emptyEl = document.getElementById('forward-empty');
            
            if (!container) return;
            
            // 过滤掉当前角色
            const availableCharacters = charactersList.filter(c => c.id !== currentCharacterId);
            
            if (availableCharacters.length === 0) {
                container.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }
            
            if (emptyEl) emptyEl.style.display = 'none';
            
            container.innerHTML = availableCharacters.map(character => {
                const avatar = character.aiAvatar || '';
                const name = character.aiNickname || character.name || '未命名';
                const desc = `与 ${character.userNickname || '我'} 的对话`;
                
                return `
                    <div class="forward-character-item" onclick="confirmForward('${character.id}')">
                        <div class="forward-character-avatar">
                            ${avatar ? 
                                `<img src="${avatar}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">` :
                                `<div class="default-avatar ai" style="width: 100%; height: 100%; border-radius: 6px; font-size: 20px;">${name.substring(0, 1)}</div>`
                            }
                        </div>
                        <div class="forward-character-info">
                            <div class="forward-character-name">${escapeHtml(name)}</div>
                            <div class="forward-character-desc">${escapeHtml(desc)}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            console.log('✅ 渲染转发列表完成，共', availableCharacters.length, '个角色');
        }
        
        /**
         * 确认转发到指定角色
         */
        function confirmForward(targetCharacterId) {
            if (!window.pendingForwardMessages || window.pendingForwardMessages.length === 0) {
                showToast('没有要转发的消息');
                return;
            }
            
            const targetCharacter = charactersList.find(c => c.id === targetCharacterId);
            if (!targetCharacter) {
                showToast('目标角色不存在');
                return;
            }
            
            const messageCount = window.pendingForwardMessages.length;
            const targetName = targetCharacter.aiNickname || targetCharacter.name || '该角色';
            
            if (!confirm(`确定要转发 ${messageCount} 条消息到「${targetName}」吗？`)) {
                return;
            }
            
            console.log('📤 开始转发消息到角色:', targetCharacterId);
            
            // 加载目标角色的数据
            const targetConfigKey = `char_${targetCharacterId}_config`;
            const targetHistoryKey = `char_${targetCharacterId}_chatHistory`;
            
            let targetConfig = localStorage.getItem(targetConfigKey);
            let targetHistory = localStorage.getItem(targetHistoryKey);
            
            if (!targetConfig) {
                showToast('目标角色配置不存在');
                return;
            }
            
            targetConfig = JSON.parse(targetConfig);
            targetHistory = targetHistory ? JSON.parse(targetHistory) : [];
            
            // 将消息添加到目标角色的聊天记录
            const currentTime = new Date().toISOString();
            window.pendingForwardMessages.forEach(msg => {
                const forwardedMessage = {
                    id: generateUniqueId(),
                    role: 'user', // 转发的消息作为用户消息
                    content: `[转发] ${msg.content}`,
                    timestamp: currentTime,
                    status: 2
                };
                targetHistory.push(forwardedMessage);
            });
            
            // 保存到目标角色
            localStorage.setItem(targetHistoryKey, JSON.stringify(targetHistory));
            
            showToast(`已转发 ${messageCount} 条消息到「${targetName}」`);
            console.log('✅ 转发完成');
            
            // 清理并返回
            window.pendingForwardMessages = null;
            
            // 返回之前的页面
            if (currentCharacterId) {
                showPage('chat-page');
            } else {
                showPage('chat-list-page');
            }
        }
        
        /**
         * 取消转发
         */
        function cancelForward() {
            window.pendingForwardMessages = null;
            
            // 返回之前的页面
            if (currentCharacterId) {
                showPage('chat-page');
            } else {
                showPage('chat-list-page');
            }
        }
        
        // ==================== 收藏查看功能 ====================
        
        /**
         * 显示收藏页面
         */
        function showFavoritesPage() {
            console.log('⭐ 显示收藏页面');
            renderFavoritesPage();
            showPage('favorites-page');
        }
        
        /**
         * 渲染收藏页面
         */
        function renderFavoritesPage() {
            const favorites = getFavorites();
            const container = document.getElementById('favorites-container');
            const emptyEl = document.getElementById('favorites-empty');
            
            if (!container) return;
            
            if (favorites.length === 0) {
                container.innerHTML = '';
                if (emptyEl) emptyEl.style.display = 'block';
                return;
            }
            
            if (emptyEl) emptyEl.style.display = 'none';
            
            container.innerHTML = favorites.map(fav => {
                const time = new Date(fav.favoritedAt);
                const timeStr = `${time.getMonth() + 1}/${time.getDate()} ${time.getHours()}:${time.getMinutes().toString().padStart(2, '0')}`;
                
                return `
                    <div class="favorite-item" data-favorite-id="${fav.id}">
                        <div class="favorite-header">
                            <span class="favorite-sender">${escapeHtml(fav.senderName)}</span>
                            <span class="favorite-time">${timeStr}</span>
                        </div>
                        <div class="favorite-content">${escapeHtml(fav.content)}</div>
                        <div class="favorite-actions">
                            <button class="favorite-action-btn" onclick="sendFavoriteToChat('${fav.id}')">发送到聊天</button>
                            <button class="favorite-action-btn delete" onclick="removeFavorite('${fav.id}')">删除</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            console.log('✅ 渲染收藏完成，共', favorites.length, '条');
        }
        
        /**
         * 从收藏中删除
         */
        function removeFavorite(favoriteId) {
            if (!confirm('确定要取消收藏这条消息吗？')) {
                return;
            }
            
            let favorites = getFavorites();
            favorites = favorites.filter(fav => fav.id !== favoriteId);
            saveFavorites(favorites);
            
            // 重新渲染
            renderFavoritesPage();
            
            // 更新收藏数量
            updateFavoritesCount();
            
            showToast('已取消收藏');
            console.log('🗑️ 删除收藏:', favoriteId);
        }
        
        /**
         * 发送收藏到当前聊天
         */
        function sendFavoriteToChat(favoriteId) {
            if (!currentCharacterId) {
                showToast('请先选择一个聊天对象');
                return;
            }
            
            const favorites = getFavorites();
            const favorite = favorites.find(fav => fav.id === favoriteId);
            
            if (!favorite) {
                showToast('收藏不存在');
                return;
            }
            
            // 返回聊天页面
            showPage('chat-page');
            
            // 将收藏内容填入输入框
            const userInput = document.getElementById('user-input');
            if (userInput) {
                userInput.value = `[收藏] ${favorite.content}`;
                userInput.focus();
            }
            
            showToast('已填入输入框');
        }
        
        /**
         * 清空所有收藏
         */
        function clearAllFavorites() {
            const favorites = getFavorites();
            if (favorites.length === 0) {
                showToast('收藏为空');
                return;
            }
            
            if (!confirm(`确定要清空所有 ${favorites.length} 条收藏吗？此操作不可恢复！`)) {
                return;
            }
            
            saveFavorites([]);
            renderFavoritesPage();
            updateFavoritesCount();
            
            showToast('已清空收藏');
            console.log('🗑️ 清空所有收藏');
        }
        
        /**
         * 更新收藏数量显示
         */
        function updateFavoritesCount() {
            const favorites = getFavorites();
            const countEl = document.getElementById('favorites-count');
            if (countEl) {
                countEl.textContent = favorites.length.toString();
            }
        }
        
        /**
         * 更新"我"页面的用户信息
         */
        function updateMePageInfo() {
            // 更新头像
            const avatarEl = document.getElementById('me-page-avatar');
            if (avatarEl && config.userAvatar) {
                avatarEl.innerHTML = `<img src="${config.userAvatar}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;">`;
            } else if (avatarEl) {
                avatarEl.textContent = config.userNickname ? config.userNickname.substring(0, 1) : '我';
            }
            
            // 更新昵称
            const nicknameEl = document.getElementById('me-page-nickname');
            if (nicknameEl) {
                nicknameEl.textContent = config.userNickname || '用户昵称';
            }
            
            // 更新收藏数量
            updateFavoritesCount();
        }
        
        
    </script>

</body>
</html>
