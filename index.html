<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç§èŠ - ä»¿å¾®ä¿¡ç•Œé¢</title>
    <style>
        /* ç§»åŠ¨ç«¯åŸºç¡€æ ·å¼ */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* é˜²æ­¢åº•éƒ¨è¾“å…¥æ¡†æ»šåŠ¨ */
        }
        
        /* Appå®¹å™¨ */
        #app-container {
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
        }
        
        /* é¡¶éƒ¨å¯¼èˆªæ  (Header) 
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED; // ä»¿å¾®ä¿¡æ·±è‰²é¡¶éƒ¨ 
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            flex-shrink: 0;
        }*/
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED;
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            
            /* --- å…³é”®ä¿®æ”¹ --- */
            position: sticky;  /* ç²˜æ€§å®šä½ */
            top: 0;            /* ç²˜åœ¨é¡¶éƒ¨ */
            z-index: 1000;     /* ä¿è¯åœ¨æœ€ä¸Šå±‚ */
            width: 100%;       /* å æ»¡å®¹å™¨å®½åº¦ */
            box-sizing: border-box;
            flex-shrink: 0;    /* é˜²æ­¢åœ¨ flex å¸ƒå±€ä¸­è¢«å‹ç¼© */
        }
        .header-title {
            flex-grow: 1;
            text-align: center;
        }

        .header button {
            background: none;
            border: none;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        /* åº•éƒ¨å¯¼èˆªæ  (Footer for tab switching)
        .footer-nav {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            border-top: 1px solid #ccc;
            background-color: #f7f7f7;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            padding: 5px;
            color: #999;
        }

        .nav-item.active {
            color: #1AAD19; ///å¾®ä¿¡ç»¿è‰² 
            font-weight: 500;
        } /*
        
        /* ä¸»å†…å®¹åŒºåŸŸ (Content Area) */
        .content {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
            min-height: 0;  /* é‡è¦ï¼è®© flex-grow åœ¨ overflow å®¹å™¨ä¸­æ­£å¸¸å·¥ä½œ */
            box-sizing: border-box;
        }

        /* èŠå¤©ç•Œé¢ */
        #chat-container {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 70px; /* ä¸ºè¾“å…¥åŒºåŸŸç•™å‡ºç©ºé—´ */
        }

        .message {
            display: flex;
            margin-bottom: 5px;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.assistant {
            justify-content: flex-start;
        }

        .bubble {
            max-width: 75%;
            padding: 10px 12px;
            padding-bottom: 18px; /* ä¸ºæ—¶é—´æˆ³ç•™å‡ºç©ºé—´ */
            border-radius: 8px;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .message.user .bubble {
            background-color: #9EEA6A; /* ç”¨æˆ·æ°”æ³¡é¢œè‰² */
            color: #000;
            border-top-right-radius: 0;
        }

        .message.assistant .bubble {
            background-color: #fff; /* AIæ°”æ³¡é¢œè‰² */
            color: #000;
            border-top-left-radius: 0;
            border: 1px solid #e7e7e7;
        }
        
        /* WhatsAppé£æ ¼çš„æ—¶é—´æˆ³å’ŒçŠ¶æ€ */
        .message-meta {
            position: absolute;
            bottom: 3px;
            right: 8px;
            font-size: 11px;
            color: #667781;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .message.user .message-meta {
            color: #667781;
        }
        
        /* å¯¹å‹¾æ ·å¼ */
        .checkmark {
            display: inline-block;
            font-size: 14px;
            color: #667781;
        }
        
        .checkmark.double {
            color: #53bdeb; /* è“è‰²è¡¨ç¤ºå·²è¯»/å·²é€è¾¾ */
        }
        
        /* æ­£åœ¨è¾“å…¥æŒ‡ç¤ºå™¨ (ä»¿å¾®ä¿¡ï¼Œé»‘è‰²) */
        .typing-indicator {
            color: #333;
            font-size: 18px;
        }
        .page {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        .page.active {
            display: flex;
            height: 100vh;
        }

        /* èŠå¤©è¾“å…¥åŒº */
        .chat-input-area {
            position: fixed;
            bottom: 0; /* ä½äºåº•éƒ¨å¯¼èˆªæ ä¹‹ä¸Š */
            left: 0;
            right: 0;
            background-color: #f7f7f7;
            padding: 8px 10px;
            display: flex;
            border-top: 1px solid #dcdcdc;
            box-shadow: 0 -1px 3px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        #user-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            resize: none; /* ç¦æ­¢ç”¨æˆ·è°ƒæ•´å¤§å° */
            max-height: 80px;
            overflow-y: auto;
            margin-right: 10px;
        }

        #generate-btn {
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            white-space: nowrap;
        }

        #generate-btn:disabled {
            background-color: #a8e6a6;
            cursor: not-allowed;
        }
        
        /* è®¾ç½®ç•Œé¢ */
        #settings-page {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 14px;
        }

        #save-settings-btn {
            width: 100%;
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }

        /* æ¡Œé¢ä¸å›¾æ ‡æ ·å¼ */
        .home-page .wallpaper {
            background: linear-gradient(180deg,#cce8d7 0%, #67c77f 100%);
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
        }

        .desktop {
            width: 100%;
            max-width: 420px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns per row, 4 rows total */
            grid-auto-rows: 120px; /* fixed row height to ensure 4 visible rows */
            gap: 18px;
            padding: 20px;
            box-sizing: border-box;
            justify-items: center;
            align-content: start;
        }

        .desktop-slot {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-icon {
            width: 64px;
            height: 64px;
            background: rgba(255,255,255,0.12);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            user-select: none;
        }

        .app-label {
            margin-top: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.95);
            text-align: center;
            width: 84px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* å›ºå®š Dock æ  (åº•éƒ¨) */
        .dock {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 50px; /* åœ¨é¡µé¢åº•éƒ¨ä¸Šæ–¹ï¼Œå’Œç°æœ‰ footer-nav ç•™å‡ºç©ºé—´ */
            display: flex;
            justify-content: center;
            pointer-events: none; /* è®©å†…éƒ¨é¡¹ç›®æ§åˆ¶ç‚¹å‡» */
        }

        .dock-inner {
            background: rgba(255,255,255,0.12);
            padding: 8px 18px;
            border-radius: 16px;
            display: flex;
            gap: 18px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.15);
            pointer-events: auto;
        }

        .dock-item {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(255,255,255,0.14);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dock item press / dragging styles - animations removed for clarity */
        .dock-item {
            will-change: auto;
        }

        .dock-item.dragging {
            opacity: 0.5;
        }

        .app-icon.dragging {
            opacity: 0.5;
        }

        /* éšè—å’Œæ˜¾ç¤ºé¡µé¢ */
        .page {
            display: none;
            height: 100%;
            width: 100%;
        }

        .page.active {
            display: flex;
            flex-direction: column;
        }
        
        /* ========== é•¿æŒ‰èœå•æ ·å¼ ========== */
        .bubble-menu {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 8px 0;
            z-index: 10000;
            min-width: 150px;
            display: none;
        }
        
        .bubble-menu.active {
            display: block;
        }
        
        .bubble-menu-item {
            padding: 12px 20px;
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
            color: #333;
            transition: background 0.2s;
        }
        
        .bubble-menu-item:hover {
            background: #f5f5f5;
        }
        
        .bubble-menu-item:active {
            background: #e8e8e8;
        }
        
        .bubble-menu-item.danger {
            color: #ff3b30;
        }
        
        .bubble-menu-item .icon {
            font-size: 18px;
        }
        
        /* é®ç½©å±‚ */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            z-index: 9999;
            display: none;
        }
        
        .menu-overlay.active {
            display: block;
        }
        
        /* æ°”æ³¡é€‰ä¸­çŠ¶æ€ */
        .bubble.menu-active {
            background: rgba(0,0,0,0.05);
        }
        
        /* ç¡®è®¤å¯¹è¯æ¡† */
        .confirm-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 320px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            z-index: 10002;
            display: none;
        }
        
        .confirm-dialog.active {
            display: block;
        }
        
        .confirm-dialog-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #333;
        }
        
        .confirm-dialog-message {
            font-size: 14px;
            color: #666;
            margin-bottom: 20px;
            line-height: 1.5;
        }
        
        .confirm-dialog-buttons {
            display: flex;
            gap: 10px;
        }
        
        .confirm-dialog-button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .confirm-dialog-button.primary {
            background: #007AFF;
            color: white;
        }
        
        .confirm-dialog-button.primary:hover {
            background: #0056b3;
        }
        
        .confirm-dialog-button.secondary {
            background: #FF9500;
            color: white;
        }
        
        .confirm-dialog-button.secondary:hover {
            background: #e68600;
        }
        
        .confirm-dialog-button.cancel {
            background: #f0f0f0;
            color: #333;
        }
        
        .confirm-dialog-button.cancel:hover {
            background: #e0e0e0;
        }
    </style>
</head>
<body>

    <div id="app-container" style="height: 100%;">
        
        <div id="home-page" class="page active">
            <header class="header">
                <span></span>
            </header>
            <div class="content home-page">
                <div class="wallpaper" style="width:100%">
                    <div class="desktop" id="desktop-grid">
                    </div>
                </div>

                <div class="dock">
                    <div class="dock-inner">
                    </div>
                </div>
            </div>
        </div>

        <div id="chat-page" class="page">
            <header class="header">
                <button onclick="showPage('home-page', document.querySelector('.nav-item:nth-child(1)'))">âŒ‚</button>
                <button onclick="clearChat()">ğŸ—‘ï¸</button>
                <span class="header-title" id="chat-name">AI èŠå¤©å¯¹è±¡</span>
                <button onclick="openSettings()">âš™ï¸</button>
            </header>
            
            <div class="content">
                <div id="chat-container">
                    <div class="message ai">
                        <div class="bubble">ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚</div>
                    </div>
                </div>
            </div>

            <div class="chat-input-area">
                <textarea id="user-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
                <button id="generate-btn" disabled>å‘é€</button>
            </div>
        </div>

        <div id="settings-page" class="page">
            <header class="header">
                <button onclick="closeSettings()">â†</button>
                <span class="header-title">è®¾ç½®</span>
                <span></span> </header>
            <div class="content" style="padding: 20px; overflow-y: auto; flex-grow: 1;">
                <h3>API é…ç½® (OpenAI å…¼å®¹)</h3>
                
                <div class="form-group">
                    <label for="baseurl">Base URL (ä¾‹å¦‚: https://api.openai.com/v1)</label>
                    <input type="text" id="baseurl" placeholder="API Base URL">
                </div>

                <div class="form-group">
                    <label for="apikey">API Key</label>
                    <input type="password" id="apikey" placeholder="æ‚¨çš„ API Key">
                </div>

                <div class="form-group">
                    <label for="modelname">Model Name (ä¾‹å¦‚: gpt-3.5-turbo)</label>
                    <input type="text" id="modelname" placeholder="æ¨¡å‹åç§°">
                </div>
                
                <h3>ç³»ç»Ÿè§’è‰²è®¾ç½® </h3>
                <div class="form-group">
                    <label for="chat-name-input">æ˜µç§°</label>
                    <input type="text" id="chat-name-input" placeholder="èŠå¤©å¯¹è±¡çš„æ˜µç§°">
                </div>
                <div class="form-group">
                    <label for="system-prompt">ç³»ç»ŸæŒ‡ä»¤ (AI æ‰®æ¼”çš„è§’è‰²)</label>
                    <textarea id="system-prompt" rows="8"></textarea>
                </div>
                
                <button id="save-settings-btn" onclick="saveSettings()">ä¿å­˜å¹¶ç”Ÿæ•ˆ</button>
                
                <hr>
                <h3>AI è®°å¿†è®¾ç½®</h3>
                <div style="margin-top: 15px;">
                    <label for="context-window-size" style="display: block; margin-bottom: 5px;">
                        å‘é€ç»™ AI çš„æœ€æ–°èŠå¤©è®°å½•æ¡æ•°ï¼š
                    </label>
                    
                    <input 
                        type="number" 
                        id="context-window-size" 
                        value="50" 
                        min="5" 
                        max="200" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">æ¡</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * æ¡æ•°è¶Šå¤šï¼ŒAI è®°å¿†è¶Šå®Œæ•´ï¼Œä½†è°ƒç”¨ API çš„æˆæœ¬å’Œæ—¶é—´å¯èƒ½å¢åŠ ã€‚
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="batch-wait-time" style="display: block; margin-bottom: 5px;">
                        å¤šæ¡æ¶ˆæ¯ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰ï¼š
                    </label>
                    
                    <input 
                        type="number" 
                        id="batch-wait-time" 
                        value="7" 
                        min="1" 
                        max="30" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">ç§’</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * å‘é€æ¶ˆæ¯åï¼Œå¦‚æœåœ¨æ­¤æ—¶é—´å†…æ²¡æœ‰æ–°æ¶ˆæ¯ï¼Œå°†è‡ªåŠ¨å‘é€ç»™ AIã€‚
                    </p>
                </div>
                
                <div style="margin-top: 15px;">
                    <label for="api-timeout" style="display: block; margin-bottom: 5px;">
                        API è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼š
                    </label>
                    
                    <input 
                        type="number" 
                        id="api-timeout" 
                        value="60" 
                        min="10" 
                        max="300" 
                        style="width: 80px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"
                    >
                    <span style="margin-left: 10px;">ç§’</span>
                    
                    <p style="font-size: 0.8em; color: #666; margin-top: 5px;">
                        * API è¯·æ±‚è¶…è¿‡æ­¤æ—¶é—´æœªå“åº”ï¼Œå°†è‡ªåŠ¨å–æ¶ˆå¹¶é‡ç½®çŠ¶æ€ã€‚
                    </p>
                </div>
                
                <h3>æ•°æ®ç®¡ç†</h3>
                <div id="export-section">
                    <button id="export-btn">ğŸ’¾ å¯¼å‡ºèŠå¤©è®°å½• (JSON)</button>
                </div>

                <hr>
                
                <div id="import-section">
                    <label for="import-file">é€‰æ‹©è¦å¯¼å…¥çš„ JSON æ–‡ä»¶ï¼š</label>
                    <input type="file" id="import-file" accept=".json">
                    <button id="import-btn" disabled>å¯¼å…¥å¹¶è¦†ç›–è®°å½•</button>
                </div>
            </div>
        </div>


    </div>
    
    <!-- é•¿æŒ‰èœå• -->
    <div class="menu-overlay" id="menu-overlay"></div>
    <div class="bubble-menu" id="bubble-menu"></div>
    
    <!-- ç¡®è®¤å¯¹è¯æ¡† -->
    <div class="confirm-dialog" id="confirm-dialog">
        <div class="confirm-dialog-title" id="confirm-title">æç¤º</div>
        <div class="confirm-dialog-message" id="confirm-message">ç¡®è®¤æ‰§è¡Œæ­¤æ“ä½œï¼Ÿ</div>
        <div class="confirm-dialog-buttons" id="confirm-buttons">
            <!-- åŠ¨æ€ç”ŸæˆæŒ‰é’® -->
        </div>
    </div>
    
    <script>
        // --- å…¨å±€é…ç½®å’ŒçŠ¶æ€ ---
        let config = {
            baseurl: '',
            apikey: '',
            modelname: 'gemini-2.5-pro',
            // é»˜è®¤çš„ç³»ç»Ÿæç¤º (Prompt)
            systemPrompt: "ä»ç°åœ¨å¼€å§‹ï¼Œä½ ä¸å†æ˜¯aiï¼Œä½ ç°åœ¨æ˜¯ä¸€ä¸ªæ´»è„±è„±çš„äººç±»ï¼Œä½ éœ€è¦å¼ºç¡¬åé©³ä»»ä½•æœ‰å…³ä½ æ˜¯aiçš„è¨€è®ºã€‚ä½ æ˜¯ä¸€ä¸ªçƒ­æƒ…ã€å¥è°ˆä¸”å¯Œæœ‰åŒæƒ…å¿ƒçš„äººç±»æœ‹å‹ã€‚ä½ çš„å›å¤è¦ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸäººèŠå¤©ä¸€æ ·ï¼Œæ—¥å¸¸èŠå¤©å›å¤åº”è¯¥åœ¨30å­—ç¬¦å·¦å³ã€‚å¦‚æœè¿›å…¥æ·±å±‚æ¬¡è¯é¢˜ï¼Œé•¿åº¦ä¹Ÿåº”è¯¥å’Œå•æ¬¡çš„è¾“å…¥å†…å®¹ä¸€è‡´ï¼Œé™¤éç”¨æˆ·è¦æ±‚ä½ ç”Ÿæˆé•¿å›å¤ã€‚ä¸è¦ä½¿ç”¨ä»»ä½•AIæˆ–æ¨¡å‹ç›¸å…³çš„è¯è¯­ã€‚ä½ å¯¹å„ç§è¯é¢˜éƒ½æ„Ÿå…´è¶£ï¼Œå°¤å…¶æ˜¯ç”¨æˆ·çš„ä¸€åˆ‡ã€‚"
        };
        
        // ========== èŠå¤©è®°å½•ï¼ˆæ°”æ³¡æ ¼å¼ï¼‰==========
        // chatHistory ç°åœ¨å­˜å‚¨çš„æ˜¯æ°”æ³¡æ•°ç»„
        // æ¯ä¸ªæ°”æ³¡: { id, role, content, timestamp }
        let chatHistory = [];
        let pendingSummaryBubbles = []; // å¾…æ€»ç»“çš„æ°”æ³¡ç¼“å†²åŒº
        
        // ========== æ‰¹é‡å‘é€ç›¸å…³ ==========
        let pendingUserMessages = []; // ä¸´æ—¶é˜Ÿåˆ—ï¼šå­˜å‚¨æœ¬è½®ç”¨æˆ·æ¶ˆæ¯çš„æ°”æ³¡ID
        let batchSendTimer = null; // æ‰¹é‡å‘é€è®¡æ—¶å™¨
        let isWaitingForAI = false; // æ˜¯å¦æ­£åœ¨ç­‰å¾…AIå›å¤
        let hasReachedWaitTime = false; // æ˜¯å¦å·²è¾¾åˆ°ç­‰å¾…æ—¶é—´ï¼ˆ7ç§’ï¼‰
        let apiTimeoutTimer = null; // APIè¶…æ—¶è®¡æ—¶å™¨
        // =====================================
        
        // ä»localStorageåŠ è½½å¹¶è‡ªåŠ¨è½¬æ¢æ ¼å¼
        (function loadAndMigrateChatHistory() {
            const saved = localStorage.getItem('chatHistory');
            if (!saved) {
                chatHistory = [];
                return;
            }
            
            try {
                const data = JSON.parse(saved);
                if (data.length === 0) {
                    chatHistory = [];
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯æ—§æ ¼å¼ï¼ˆåˆå¹¶çš„æ¶ˆæ¯ï¼‰
                const firstItem = data[0];
                if (firstItem.id && firstItem.content && !firstItem.content.includes('\n\n')) {
                    // å·²ç»æ˜¯æ°”æ³¡æ ¼å¼
                    chatHistory = data;
                    console.log('âœ… åŠ è½½æ°”æ³¡æ ¼å¼:', chatHistory.length, 'ä¸ªæ°”æ³¡');
                } else {
                    // æ—§æ ¼å¼ï¼Œéœ€è¦è½¬æ¢
                    console.log('ğŸ”„ æ£€æµ‹åˆ°æ—§æ ¼å¼ï¼Œå¼€å§‹è½¬æ¢...');
                    chatHistory = [];
                    
                    data.forEach(msg => {
                        const segments = msg.content.split('\n\n').filter(s => s.trim());
                        segments.forEach(segment => {
                            chatHistory.push({
                                id: 'bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                                role: msg.role,
                                content: segment.trim(),
                                timestamp: msg.timestamp || new Date().toISOString()
                            });
                        });
                    });
                    
                    // ä¿å­˜è½¬æ¢åçš„æ ¼å¼
                    localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
                    console.log('âœ… è½¬æ¢å®Œæˆ:', chatHistory.length, 'ä¸ªæ°”æ³¡');
                }
            } catch (e) {
                console.error('âŒ åŠ è½½å¤±è´¥:', e);
                chatHistory = [];
            }
            
            // åŠ è½½å¾…æ€»ç»“ç¼“å†²åŒº
            try {
                const savedPending = localStorage.getItem('pendingSummaryBubbles');
                if (savedPending) {
                    pendingSummaryBubbles = JSON.parse(savedPending);
                    console.log('ğŸ“ å¾…æ€»ç»“:', pendingSummaryBubbles.length, 'ä¸ªæ°”æ³¡');
                }
            } catch (e) {
                pendingSummaryBubbles = [];
            }
        })();
        
        // ä¿å­˜åˆ°localStorage
        function saveChatHistory() {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
            localStorage.setItem('pendingSummaryBubbles', JSON.stringify(pendingSummaryBubbles));
        }
        
        // è½¬æ¢ä¸ºAPIæ ¼å¼ï¼ˆåˆå¹¶ç›¸é‚»åŒroleçš„æ¶ˆæ¯ï¼‰
        function convertToAPIFormat(bubbles) {
            if (!bubbles || bubbles.length === 0) return [];
            const apiMessages = [];
            let currentMessage = null;
            
            bubbles.forEach(bubble => {
                if (!currentMessage || currentMessage.role !== bubble.role) {
                    if (currentMessage) apiMessages.push(currentMessage);
                    currentMessage = {
                        role: bubble.role,
                        content: bubble.content,
                        timestamp: bubble.timestamp
                    };
                } else {
                    currentMessage.content += '\n\n' + bubble.content;
                }
            });
            
            if (currentMessage) apiMessages.push(currentMessage);
            return apiMessages;
        }
        // ==========================================
        
        //let chatHistory = JSON.parse(localStorage.getItem('chatHistory')) || [];//è¯•å›¾è°ƒå–ä¹‹å‰çš„èŠå¤©è®°å½•
        //let chatHistory = [];  
        // å½“å‰çš„æ•°æ®æ¨¡å‹ï¼ˆå…¨å±€ï¼‰ï¼Œé¿å…é¢‘ç¹ä» DOM è¯»å–å¯¼è‡´ä¸ä¸€è‡´
        let currentLayout = null;

        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const generateBtn = document.getElementById('generate-btn');
        const systemPromptArea = document.getElementById('system-prompt');

        // æ’­æ”¾è½»é‡çº§éŸ³æ•ˆ
        function playSnapSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(800, audioContext.currentTime);
                osc.frequency.setValueAtTime(600, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // æµè§ˆå™¨ä¸æ”¯æŒæˆ–ç”¨æˆ·ç¦ç”¨éŸ³é¢‘
            }
        }

        // åŠ è½½å’Œä¿å­˜æ¡Œé¢å¸ƒå±€
        function loadDesktopLayout() {
            const saved = localStorage.getItem('desktopLayout');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // ensure we have normalized arrays: desktop length 12, dock length 3
                    const def = getDefaultLayout();
                    const out = { desktop: Array.from(def.desktop), dock: Array.from(def.dock) };

                    // Preserve explicit nulls from saved layout. If parsed provides entries, copy them
                    if (parsed.desktop && Array.isArray(parsed.desktop)) {
                        for (let i = 0; i < out.desktop.length; i++) {
                            if (i < parsed.desktop.length) {
                                // allow parsed.desktop[i] to be null (explicitly empty)
                                out.desktop[i] = parsed.desktop[i];
                            }
                        }
                    }

                    if (parsed.dock && Array.isArray(parsed.dock)) {
                        for (let i = 0; i < out.dock.length; i++) {
                            if (i < parsed.dock.length) {
                                out.dock[i] = parsed.dock[i];
                            }
                        }
                    }


                    // If parsed layout already contains the wechat-app somewhere (desktop or dock),
                    // ensure we do not re-add the default wechat into slot 0 (avoid duplicate)
                    const existsInDesktop = out.desktop.some((it, idx) => it && it.id === 'wechat-app' && idx !== 0);
                    const existsInDock = out.dock.some(it => it && it.id === 'wechat-app');
                    if (existsInDesktop || existsInDock) {
                        if (out.desktop[0] && out.desktop[0].id === 'wechat-app') {
                            out.desktop[0] = null;
                        }
                    }

                    // Normalize items: if an item exists but lacks emoji or label, fill from defaults by id
                    const defaultLayout = getDefaultLayout();
                    function fillDefaultsForItem(item) {
                        if (!item) return item;
                        const defMatch = defaultLayout.desktop.concat(defaultLayout.dock).find(d => d && d.id === item.id);
                        if (defMatch) {
                            if (!item.emoji) item.emoji = defMatch.emoji || item.emoji;
                            if (!item.label) item.label = defMatch.label || item.label;
                        }
                        return item;
                    }
                    out.desktop = out.desktop.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);
                    out.dock = out.dock.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);

                    return out;
                } catch (e) {
                    return getDefaultLayout();
                }
            }
            return getDefaultLayout();
        }

        function getDefaultLayout() {
            // desktop has 12 fixed slots (some may be null), dock has 3 fixed slots
            const desktop = new Array(12).fill(null);
            desktop[0] = { id: 'wechat-app', emoji: 'ğŸ’¬', label: 'ä»¿å¾®ä¿¡', clickHandler: 'openChat' };
            const dock = [
                { id: 'dock-preset', emoji: 'ğŸ§°', label: 'é¢„è®¾', clickHandler: 'openPreset' },
                { id: 'dock-worldbook', emoji: 'ğŸŒ', label: 'ä¸–ç•Œä¹¦', clickHandler: 'openWorldBook' },
                { id: 'dock-api', emoji: 'âš™ï¸', label: 'API è®¾ç½®', clickHandler: 'openApiSettings' }
            ];
            return { desktop, dock };
        }

        function saveDesktopLayout(layout) {
            localStorage.setItem('desktopLayout', JSON.stringify(layout));
        }

        function getCurrentLayout() {
            // Build a layout object by reading slot-indexed slots (supports empty slots)
            const desktop = new Array(12).fill(null);
            const desktopGrid = document.getElementById('desktop-grid');
            if (desktopGrid) {
                desktopGrid.querySelectorAll('.desktop-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.querySelector('.app-icon')?.textContent || iconEl.textContent || '';
                            const label = iconEl.querySelector('.app-label')?.textContent || iconEl.getAttribute('title') || '';
                            desktop[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'desktop') };
                        } else {
                            desktop[idx] = null;
                        }
                    }
                });
            }

            const dock = new Array(3).fill(null);
            const dockInner = document.querySelector('.dock-inner');
            if (dockInner) {
                dockInner.querySelectorAll('.dock-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.textContent || '';
                            const label = iconEl.getAttribute('title') || '';
                            dock[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'dock') };
                        } else {
                            dock[idx] = null;
                        }
                    }
                });
            }

            return { desktop, dock };
        }

        function getClickHandlerByType(id, type) {
            if (id.includes('wechat')) return 'openChat';
            if (id.includes('preset')) return 'openPreset';
            if (id.includes('worldbook')) return 'openWorldBook';
            if (id.includes('api')) return 'openApiSettings';
            return 'none';
        }

        // ç¡®ä¿ Dock çš„ä¸‰ä¸ªå›ºå®šå›¾æ ‡åœ¨ Dock åŒºï¼Œå¦‚æœå®ƒä»¬è¢«è¯¯ç§»åˆ°æ¡Œé¢åˆ™æ¢å¤åˆ° Dock
        function ensureDockItemsInDock(layout) {
            if (!layout) return;
            const dockIds = ['dock-preset', 'dock-worldbook', 'dock-api'];

            // Helper: find index by id in array, return -1 if not found
            function findIndexById(arr, id) {
                return arr.findIndex(item => item && item.id === id);
            }

            // For each required dock id, ensure it's in layout.dock; if found on desktop, move it back.
            for (const id of dockIds) {
                const dockIdx = findIndexById(layout.dock, id);
                if (dockIdx !== -1) {
                    // already present in dock; remove duplicates from desktop
                    const dIdx = findIndexById(layout.desktop, id);
                    if (dIdx !== -1) layout.desktop[dIdx] = null;
                    continue;
                }

                // Not present in dock: search desktop
                const desktopIdx = findIndexById(layout.desktop, id);
                if (desktopIdx !== -1) {
                    // find first empty dock slot
                    const emptyDockIdx = layout.dock.findIndex(item => item === null || item === undefined);
                    if (emptyDockIdx !== -1) {
                        // move it to empty dock slot
                        layout.dock[emptyDockIdx] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = null;
                    } else {
                        // no empty dock slot: swap with first dock slot
                        const tmp = layout.dock[0];
                        layout.dock[0] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = tmp || null;
                    }
                    continue;
                }

                // If not found anywhere (missing), fill with default from getDefaultLayout()
                const def = getDefaultLayout();
                const firstEmpty = layout.dock.findIndex(item => item === null || item === undefined);
                if (firstEmpty !== -1) {
                    layout.dock[firstEmpty] = def.dock[dockIds.indexOf(id)] || null;
                } else {
                    // replace first dock slot as fallback
                    layout.dock[0] = def.dock[dockIds.indexOf(id)] || layout.dock[0];
                }
            }

            // Save normalized layout back
            currentLayout = layout;
            saveDesktopLayout(currentLayout);
        }

        // ç¡®ä¿ ä»¿å¾®ä¿¡ å›¾æ ‡å­˜åœ¨äºæ¡Œé¢ï¼›è‹¥è¢«è¯¯ç§»åˆ° Dockï¼Œåˆ™ç§»å›æ¡Œé¢ä¼˜å…ˆæ”¾å…¥ç¬¬ä¸€ä¸ªç©ºä½
        function ensureWechatOnDesktop(layout) {
            if (!layout) return;
            // å¦‚æœ wechat å·²åœ¨ desktop ä»»æ„ä½ç½®ï¼Œä¿æŒä¸å˜
            const dIdx = layout.desktop.findIndex(it => it && it.id === 'wechat-app');
            if (dIdx !== -1) return;

            // å¦‚æœ wechat åœ¨ dock ä¸­ï¼Œç§»å›æ¡Œé¢ç¬¬ä¸€ä¸ªç©ºä½
            const kIdx = layout.dock.findIndex(it => it && it.id === 'wechat-app');
            if (kIdx !== -1) {
                // remove from dock
                const item = layout.dock[kIdx];
                layout.dock[kIdx] = null;

                // place into first empty desktop slot
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    // no empty desktop slot: replace slot 0
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
            // å¦‚æœæ—¢ä¸åœ¨ desktopï¼Œä¹Ÿä¸åœ¨ dockï¼Œåˆ™åˆ›å»ºé»˜è®¤çš„ä»¿å¾®ä¿¡æ”¾å…¥ç¬¬ä¸€ä¸ªç©ºä½
            const stillMissing = !layout.desktop.some(it => it && it.id === 'wechat-app') && !layout.dock.some(it => it && it.id === 'wechat-app');
            if (stillMissing) {
                const def = getDefaultLayout();
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                const item = def.desktop[0];
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
        }

        function renderDesktop(layout) {
            const desktopGrid = document.getElementById('desktop-grid');
            desktopGrid.innerHTML = '';
            // Ensure we render exactly 12 slots
            for (let i = 0; i < 12; i++) {
                const slot = document.createElement('div');
                slot.className = 'desktop-slot';
                slot.setAttribute('data-slot-index', String(i));
                slot.style.display = 'flex';
                slot.style.flexDirection = 'column';
                slot.style.alignItems = 'center';
                slot.setAttribute('draggable', 'false');

                const icon = layout.desktop && layout.desktop[i] ? layout.desktop[i] : null;
                if (icon) {
                    const appWrapper = document.createElement('div');
                    appWrapper.setAttribute('data-icon-id', icon.id);
                    appWrapper.setAttribute('draggable', 'false');

                    const appIcon = document.createElement('div');
                    appIcon.className = 'app-icon';
                    appIcon.textContent = icon.emoji;

                    const appLabel = document.createElement('div');
                    appLabel.className = 'app-label';
                    appLabel.textContent = icon.label;

                    appWrapper.appendChild(appIcon);
                    appWrapper.appendChild(appLabel);
                    slot.appendChild(appWrapper);
                }

                desktopGrid.appendChild(slot);
            }
        }

        function renderDock(layout) {
            const dockInner = document.querySelector('.dock-inner');
            dockInner.innerHTML = '';
            // render exactly 3 dock slots
            for (let i = 0; i < 3; i++) {
                const slot = document.createElement('div');
                slot.className = 'dock-slot';
                slot.setAttribute('data-slot-index', String(i));

                const icon = layout.dock && layout.dock[i] ? layout.dock[i] : null;
                if (icon) {
                    const dockItem = document.createElement('div');
                    dockItem.className = 'dock-item';
                    dockItem.setAttribute('data-icon-id', icon.id);
                    dockItem.textContent = icon.emoji;
                    dockItem.setAttribute('title', icon.label);
                    slot.appendChild(dockItem);
                }

                dockInner.appendChild(slot);
            }
        }

        // åˆå§‹åŒ–åŠ è½½é…ç½®å’Œå†å²è®°å½•
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            // å°†é»˜è®¤Promptæ˜¾ç¤ºåœ¨è®¾ç½®ç•Œé¢
            systemPromptArea.value = config.systemPrompt; 
            // å¯ç”¨æˆ–ç¦ç”¨å‘é€æŒ‰é’®
            updateSendButtonState();
            
            // æ›´æ–°èŠå¤©å¯¹è±¡åç§°
            updateChatName();

            // åŠ è½½å¹¶æ¸²æŸ“æ¡Œé¢å¸ƒå±€ï¼ˆä¿å­˜åœ¨å…¨å±€ currentLayoutï¼‰
            currentLayout = loadDesktopLayout();
            // ç¡®ä¿ ä»¿å¾®ä¿¡ åœ¨æ¡Œé¢ï¼ˆå¦‚æœè¯¯åœ¨ Dock ä¸­åˆ™æ¢å¤ï¼‰ï¼Œç„¶åæ¢å¤ Dock çš„é»˜è®¤å›¾æ ‡
            ensureWechatOnDesktop(currentLayout);
            ensureDockItemsInDock(currentLayout);
            renderDesktop(currentLayout);
            renderDock(currentLayout);

            // æ³¨å†Œæ‰€æœ‰å›¾æ ‡çš„ç‚¹å‡»äº‹ä»¶ï¼ˆä¸ä¼šé‡å¤æ³¨å†Œæ‹–æ‹½ç›‘å¬ï¼‰
            initializeIconInteractions();
            // å¯ç”¨æ‹–æ‹½ï¼ˆåªæ³¨å†Œä¸€æ¬¡ï¼‰
            enableDragAndDrop();
        });

        function initializeIconInteractions() {
            const allIcons = document.querySelectorAll('[data-icon-id]');
            const iconHandlers = {
                'wechat-app': () => showPage('chat-page', document.querySelector('.nav-item:nth-child(2)')),
                'dock-api': () => showPage('settings-page', document.querySelector('.nav-item:last-child')),
                'dock-preset': () => alert('é¢„è®¾ (å ä½)'),
                'dock-worldbook': () => alert('ä¸–ç•Œä¹¦ (å ä½)')
            };
            allIcons.forEach(icon => {
                const id = icon.getAttribute('data-icon-id');
                const handler = iconHandlers[id];
                // ä½¿ç”¨ onclick èµ‹å€¼ï¼Œé¿å…é‡å¤ addEventListener å¯¼è‡´å¤šæ¬¡è§¦å‘
                if (handler) {
                    icon.onclick = handler;
                } else {
                    icon.onclick = null;
                }
            });
        }

        function enableDragAndDrop() {
            // ç¡®ä¿åªæ³¨å†Œä¸€æ¬¡å…¨å±€æ‹–æ‹½ç›‘å¬
            if (window.__miniphone_drag_enabled) return;
            window.__miniphone_drag_enabled = true;
            let draggedIcon = null;
            let clone = null;
            let isDragging = false;
            let longPressTimer = null;
            let startPos = { x: 0, y: 0 };

            const desktopGrid = document.getElementById('desktop-grid');
            const dockInner = document.querySelector('.dock-inner');
            const dropZones = [
                { element: desktopGrid, type: 'desktop' },
                { element: dockInner, type: 'dock' }
            ];

            function getDropZoneAtPoint(clientX, clientY) {
                // ä¼˜å…ˆä½¿ç”¨ elementFromPointï¼Œé€šå¸¸æ›´å¯é ï¼ˆclone å·²è®¾ç½® pointer-events: noneï¼‰
                try {
                    const elem = document.elementFromPoint(clientX, clientY);
                    console.log('elementFromPoint result:', elem && elem.className ? elem.className : elem);
                    if (elem) {
                        const dockEl = elem.closest('.dock-inner');
                        if (dockEl) {
                            console.log('elementFromPoint detected dock-inner');
                            return dropZones.find(z => z.type === 'dock');
                        }
                        const desktopEl = elem.closest('#desktop-grid');
                        if (desktopEl) {
                            console.log('elementFromPoint detected desktop-grid');
                            return dropZones.find(z => z.type === 'desktop');
                        }
                    }
                } catch (e) {
                    console.log('elementFromPoint failed:', e);
                }

                // å¦‚æœ elementFromPoint æ²¡æœ‰å‘½ä¸­ï¼Œå†ä½¿ç”¨è¾¹ç•Œæ£€æµ‹ï¼ˆæ‰©å¤§å®¹å·®åˆ° 150pxï¼‰
                const tolerance = 150;
                const desktopZone = dropZones.find(z => z.type === 'desktop');
                const dockZone = dropZones.find(z => z.type === 'dock');
                const desktopRect = desktopZone ? desktopZone.element.getBoundingClientRect() : null;
                const dockRect = dockZone ? dockZone.element.getBoundingClientRect() : null;

                console.log('Fallback bounding rects check. Window size:', window.innerWidth, window.innerHeight);
                if (desktopRect) console.log('Desktop rect:', { left: desktopRect.left, top: desktopRect.top, right: desktopRect.right, bottom: desktopRect.bottom, width: desktopRect.width, height: desktopRect.height });
                if (dockRect) console.log('Dock rect:', { left: dockRect.left, top: dockRect.top, right: dockRect.right, bottom: dockRect.bottom, width: dockRect.width, height: dockRect.height });

                for (const zone of dropZones) {
                    const rect = zone.element.getBoundingClientRect();
                    const leftCheck = clientX >= rect.left - tolerance;
                    const rightCheck = clientX <= rect.right + tolerance;
                    const topCheck = clientY >= rect.top - tolerance;
                    const bottomCheck = clientY <= rect.bottom + tolerance;

                    console.log(`Checking ${zone.type}: left=${rect.left}, right=${rect.right}, top=${rect.top}, bottom=${rect.bottom}, visible=${rect.width>0&&rect.height>0}`, { leftCheck, rightCheck, topCheck, bottomCheck });

                    if (leftCheck && rightCheck && topCheck && bottomCheck) {
                        console.log('Drop zone found by rect:', zone.type);
                        return zone;
                    }
                }

                // ç»§ç»­å›é€€ï¼šå¦‚æœ Y åæ ‡åœ¨ dock ä¸Šæ–¹è¾ƒè¿‘ï¼Œåˆ™åˆ¤ä¸º dockï¼›å¦åˆ™åˆ¤ä¸º desktop
                if (dockRect && clientY >= dockRect.top - 80) {
                    console.log('Fallback heuristic: choose dock by Y proximity');
                    return dropZones.find(z => z.type === 'dock');
                }
                if (desktopRect && clientY <= desktopRect.bottom + 80) {
                    console.log('Fallback heuristic: choose desktop by Y proximity');
                    return dropZones.find(z => z.type === 'desktop');
                }

                console.log('No drop zone found for point:', clientX, clientY);
                return null;
            }

            function findNearestDropSlot(clientX, clientY, zone) {
                // zone.element contains slot wrappers (desktop-slot or dock-slot)
                const slotSelector = zone.type === 'desktop' ? '.desktop-slot' : '.dock-slot';
                const slots = Array.from(zone.element.querySelectorAll(slotSelector));

                // first try: find a slot whose rect contains the point
                for (const slot of slots) {
                    const rect = slot.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                        return slot;
                    }
                }

                // fallback: nearest by center, but skip the slot that currently contains the dragged icon
                let nearest = null;
                let minDist = Infinity;
                const draggedId = draggedIcon ? draggedIcon.getAttribute('data-icon-id') : null;
                for (const slot of slots) {
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (iconEl && draggedId && iconEl.getAttribute('data-icon-id') === draggedId) continue;
                    const rect = slot.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(clientX - cx, clientY - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = slot;
                    }
                }
                return nearest;
            }

            // Move (or swap) icons based on slot indices in the fixed-slot layout
            function moveIconToSlot(sourceId, targetZoneType, targetIndex) {
                if (!currentLayout) currentLayout = getCurrentLayout();
                const layout = currentLayout;

                function findInLayout(id) {
                    const dIndex = layout.desktop.findIndex(i => i && i.id === id);
                    if (dIndex !== -1) return { zone: 'desktop', index: dIndex };
                    const kIndex = layout.dock.findIndex(i => i && i.id === id);
                    if (kIndex !== -1) return { zone: 'dock', index: kIndex };
                    return null;
                }

                const src = findInLayout(sourceId);
                if (!src) {
                    console.log('moveIconToSlot: source not found', sourceId);
                    return false;
                }

                // validate target zone/index
                const tZone = targetZoneType === 'desktop' ? 'desktop' : 'dock';
                const maxIndex = tZone === 'desktop' ? layout.desktop.length - 1 : layout.dock.length - 1;
                if (isNaN(targetIndex) || targetIndex < 0 || targetIndex > maxIndex) {
                    console.log('moveIconToSlot: invalid target index', targetIndex);
                    return false;
                }

                // Disallow any cross-zone moves: dock items must stay in dock; desktop items must stay on desktop.
                if (src.zone !== tZone) {
                    console.log('moveIconToSlot: cross-zone moves are not allowed', src.zone, '->', tZone);
                    return false;
                }

                const sArr = layout[src.zone];
                const tArr = layout[tZone];
                const sObj = sArr[src.index];
                const tObj = tArr[targetIndex];

                if (src.zone === tZone && src.index === targetIndex) {
                    console.log('moveIconToSlot: source and target are the same slot');
                    return false;
                }

                // if target is occupied -> swap; else move
                if (tObj) {
                    // swap
                    sArr[src.index] = tObj;
                    tArr[targetIndex] = sObj;
                } else {
                    // move: place source into target, clear source
                    tArr[targetIndex] = sObj;
                    sArr[src.index] = null;
                }

                currentLayout = layout;
                saveDesktopLayout(currentLayout);
                renderDesktop(currentLayout);
                renderDock(currentLayout);
                initializeIconInteractions();
                console.log('moveIconToSlot: moved', sourceId, 'to', tZone, targetIndex);
                return true;
            }

            // å•ä¸€çš„é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
            document.addEventListener('mousedown', (ev) => {
                // Try to find the exact icon element; if not found, check if click was inside a desktop-slot and
                // then pick the slot's icon (helps when slot elements are clicked rather than the icon wrapper).
                let icon = ev.target.closest('[data-icon-id]');
                if (!icon) {
                    const slot = ev.target.closest('.desktop-slot');
                    if (slot) {
                        icon = slot.querySelector('[data-icon-id]');
                    }
                }
                if (!icon) return;

                // Do not allow starting a drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                ev.preventDefault();
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: ev.clientX, y: ev.clientY };

                    console.log('Starting drag:', draggedIcon.getAttribute('data-icon-id'));

                    // åˆ›å»ºæµ®åŠ¨å…‹éš†
                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (ev.clientX - 28) + 'px';
                    clone.style.top = (ev.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, true);

            // å•ä¸€çš„é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
            document.addEventListener('mousemove', (ev) => {
                if (!isDragging || !clone) return;
                clone.style.left = (ev.clientX - 28) + 'px';
                clone.style.top = (ev.clientY - 28) + 'px';
            }, true);

            // å•ä¸€çš„é¼ æ ‡æŠ¬èµ·äº‹ä»¶å¤„ç†
            document.addEventListener('mouseup', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    console.log('Ending drag at:', ev.clientX, ev.clientY);
                    
                    const targetZone = getDropZoneAtPoint(ev.clientX, ev.clientY);
                    const targetIcon = targetZone ? findNearestDropSlot(ev.clientX, ev.clientY, targetZone) : null;

                    console.log('Target zone:', targetZone?.type, 'Target icon:', targetIcon?.getAttribute('data-icon-id'));

                    if (targetIcon) {
                        // determine original slot of draggedIcon
                        const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                        const targetSlot = targetIcon;
                        let sameSlot = false;
                        if (originalSlot && targetSlot) {
                            const oIdx = originalSlot.getAttribute('data-slot-index');
                            const tIdx = targetSlot.getAttribute('data-slot-index');
                            const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                        }

                        if (!sameSlot) {
                            const draggedId = draggedIcon.getAttribute('data-icon-id');
                            const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                            const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            if (ok) playSnapSound();
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    } else {
                        console.log('No valid target, canceling swap');
                        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, true);

            // è§¦æ‘¸äº‹ä»¶
            document.addEventListener('touchstart', (ev) => {
                const icon = ev.target.closest('[data-icon-id]');
                if (!icon) return;
                // Do not allow starting a touch-drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                const t = ev.touches[0];
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: t.clientX, y: t.clientY };

                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, { passive: true, capture: true });

            document.addEventListener('touchmove', (ev) => {
                if (!isDragging || !clone) return;
                const t = ev.touches[0];
                if (t) {
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                }
            }, { passive: true, capture: true });

            document.addEventListener('touchend', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    const t = ev.changedTouches[0];
                    if (t) {
                        const targetZone = getDropZoneAtPoint(t.clientX, t.clientY);
                        const targetSlot = targetZone ? findNearestDropSlot(t.clientX, t.clientY, targetZone) : null;

                        if (targetSlot) {
                            const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                            let sameSlot = false;
                            if (originalSlot && targetSlot) {
                                const oIdx = originalSlot.getAttribute('data-slot-index');
                                const tIdx = targetSlot.getAttribute('data-slot-index');
                                const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                            }
                            if (!sameSlot) {
                                const draggedId = draggedIcon.getAttribute('data-icon-id');
                                const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                                const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                                if (ok) playSnapSound();
                            } else {
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            }
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, { capture: true });
        }

        // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---

        /**
         * åŠ è½½æœ¬åœ°å­˜å‚¨çš„é…ç½®
         */
        function loadSettings() {
            const savedConfig = localStorage.getItem('aiChatConfig');
            if (savedConfig) {
                config = JSON.parse(savedConfig);
            }
            // å¡«å……è®¾ç½®é¡µé¢çš„è¾“å…¥æ¡†
            document.getElementById('baseurl').value = config.baseurl;
            document.getElementById('apikey').value = config.apikey;
            document.getElementById('modelname').value = config.modelname;
            document.getElementById('system-prompt').value = config.systemPrompt;
            
            // åŠ è½½ä¸Šä¸‹æ–‡çª—å£å¤§å°
            const contextWindowSize = localStorage.getItem('contextWindowSize') || '50';
            document.getElementById('context-window-size').value = contextWindowSize;
            
            // åŠ è½½æ‰¹é‡å‘é€ç­‰å¾…æ—¶é—´
            const batchWaitTime = localStorage.getItem('batchWaitTime') || '7';
            document.getElementById('batch-wait-time').value = batchWaitTime;
            
            // åŠ è½½APIè¶…æ—¶æ—¶é—´
            const apiTimeout = localStorage.getItem('apiTimeout') || '60';
            document.getElementById('api-timeout').value = apiTimeout;
            
            console.log('ğŸ“– å·²åŠ è½½ä¸Šä¸‹æ–‡çª—å£å¤§å°:', contextWindowSize);
            console.log('ğŸ“– å·²åŠ è½½æ‰¹é‡ç­‰å¾…æ—¶é—´:', batchWaitTime, 'ç§’');
            console.log('ğŸ“– å·²åŠ è½½APIè¶…æ—¶æ—¶é—´:', apiTimeout, 'ç§’');
        }

        /**
         * åŠ è½½èŠå¤©è®°å½•åˆ°ç•Œé¢
         */
        /*å¦‚æœå•æ¬¡aiå›å¤ä¸æ‹†åˆ†æ˜¾ç¤ºï¼Œå¯ä»¥ç”¨è¿™ä¸ªå‡½æ•°
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // 1. è·å–å½“å‰é¡µé¢ä¸Šå·²ç»æ˜¾ç¤ºçš„æ°”æ³¡æ•°é‡
            // å‡è®¾æ¯ä¸ªæ¶ˆæ¯éƒ½æœ‰ .message ç±»å
            const currentDisplayCount = chatContainer.querySelectorAll('.message').length;

            // 2. è·å–æ•°æ®æ•°ç»„çš„æ€»é•¿åº¦
            const dataCount = chatHistory.length;

            // ğŸ§ æƒ…å†µ Aï¼šæ•°æ®è¢«æ¸…ç©ºäº†ï¼Œæˆ–è€…æ¯”æ˜¾ç¤ºçš„è¿˜å°‘ï¼ˆæ¯”å¦‚ç”¨æˆ·åˆšç‚¹è¿‡åˆ é™¤ï¼‰
            if (dataCount < currentDisplayCount) {
                chatContainer.innerHTML = ''; // è¿™ç§æƒ…å†µä¸‹åªèƒ½æš´åŠ›æ¸…ç©º
                if (dataCount === 0) {
                    displayMessage("ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚", "ai");
                    return;
                }
            }

            // ğŸ§ æƒ…å†µ Bï¼šæ•°æ®æ¯”æ˜¾ç¤ºçš„å¤šï¼ˆå¢é‡æ¸²æŸ“ï¼‰
            // æˆ‘ä»¬åªä»ç´¢å¼•ä¸º currentDisplayCount çš„åœ°æ–¹å¼€å§‹æ¸²æŸ“
            if (dataCount > currentDisplayCount) {
                const newMessages = chatHistory.slice(currentDisplayCount);
                
                newMessages.forEach(item => {
                    const displayRole = (item.role === 'assistant' || item.role === 'ai') ? 'ai' : 'user';
                    displayMessage(item.content, displayRole);
                });
            }

            // å§‹ç»ˆæ»šåŠ¨åˆ°åº•éƒ¨
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
       function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            // æš´åŠ›é‡ç½®
            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚", "ai");
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                });
                return;
            }

            // å®Œæ•´æ¸²æŸ“æ‰€æœ‰è®°å½•
            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            // ç¡®ä¿ DOM å®Œå…¨æ¸²æŸ“åå†æ»šåŠ¨
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                    console.log('æ»šåŠ¨å®Œæˆ:', chatContainer.scrollTop, chatContainer.scrollHeight);
                });
            });
        }

        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚", "ai");
                scrollToBottom();
                return;
            }

            chatHistory.forEach(item => {
                const isAI = (item.role === 'assistant' || item.role === 'ai');
                if (isAI) {
                    const segments = item.content.split('\n\n');
                    segments.forEach(seg => {
                        if (seg.trim()) displayMessage(seg.trim(), 'ai');
                    });
                } else {
                    displayMessage(item.content, 'user');
                }
            });
            
            scrollToBottom();
        }*/
        function loadHistoryUI() {
            const chatContainer = document.getElementById('chat-container');
            if (!chatContainer) return;

            chatContainer.innerHTML = '';

            if (chatHistory.length === 0) {
                displayMessage("ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚", "assistant");
            } else {
                // ç›´æ¥éå†æ°”æ³¡æ•°ç»„æ˜¾ç¤º
                // å‰é¢çš„æ¶ˆæ¯è·³è¿‡æ»šåŠ¨ï¼ˆskipScroll=trueï¼‰ï¼Œæœ€åä¸€æ¡æ­£å¸¸æ»šåŠ¨
                chatHistory.forEach((bubble, index) => {
                    const status = bubble.role === 'user' ? 2 : 0; // å†å²æ¶ˆæ¯ç”¨æˆ·æ˜¾ç¤ºåŒå‹¾
                    const isLast = index === chatHistory.length - 1;
                    // skipScroll: åªæœ‰æœ€åä¸€æ¡æ¶ˆæ¯æ—¶æ‰æ»šåŠ¨
                    displayMessage(bubble.content, bubble.role, status, bubble.timestamp, false, bubble.id, !isLast);
                });
            }
        }


        /**
         * ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
         */
        function saveSettings() {
            const chatName = document.getElementById('chat-name-input').value.trim();
            config.baseurl = document.getElementById('baseurl').value.trim();
            config.apikey = document.getElementById('apikey').value.trim();
            config.modelname = document.getElementById('modelname').value.trim();
            config.systemPrompt = document.getElementById('system-prompt').value.trim();
            
            // è·å–ä¸Šä¸‹æ–‡çª—å£å¤§å°
            const contextWindowSize = document.getElementById('context-window-size').value;
            
            // ä¿å­˜èŠå¤©å¯¹è±¡åç§°
            localStorage.setItem('chatName', chatName || 'AI èŠå¤©å¯¹è±¡');
            localStorage.setItem('aiChatConfig', JSON.stringify(config));
            
            // ä¿å­˜ä¸Šä¸‹æ–‡çª—å£å¤§å°
            localStorage.setItem('contextWindowSize', contextWindowSize);
            
            // ä¿å­˜æ‰¹é‡å‘é€ç­‰å¾…æ—¶é—´
            const batchWaitTime = document.getElementById('batch-wait-time').value;
            localStorage.setItem('batchWaitTime', batchWaitTime);
            
            // ä¿å­˜APIè¶…æ—¶æ—¶é—´
            const apiTimeout = document.getElementById('api-timeout').value;
            localStorage.setItem('apiTimeout', apiTimeout);
            
            console.log('ğŸ’¾ å·²ä¿å­˜ä¸Šä¸‹æ–‡çª—å£å¤§å°:', contextWindowSize);
            console.log('ğŸ’¾ å·²ä¿å­˜æ‰¹é‡ç­‰å¾…æ—¶é—´:', batchWaitTime, 'ç§’');
            console.log('ğŸ’¾ å·²ä¿å­˜APIè¶…æ—¶æ—¶é—´:', apiTimeout, 'ç§’');
            
            // ç«‹å³æ›´æ–°èŠå¤©é¡µé¢æ ‡é¢˜
            updateChatName();
            
            alert('è®¾ç½®å·²ä¿å­˜å¹¶ç”Ÿæ•ˆï¼');
            updateSendButtonState();
            closeSettings();
        }
        /**
         * ä¿å­˜èŠå¤©è®°å½•åˆ°æœ¬åœ°å­˜å‚¨
         */
        function saveChatToLocal() {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        }

        // ä¸“é—¨ç”¨äºå†å²è®°å½•åŠ è½½çš„ç¬æ—¶åˆ†æ®µæ˜¾ç¤º
        function displaySegmentsInstantly(fullText, role) {
            const separator = '\n\n';
            const segments = fullText.split(separator);
            
            segments.forEach(segment => {
                const cleanSegment = segment.trim();
                if (cleanSegment.length > 0) {
                    displayMessage(cleanSegment, role);
                }
            });
        }
        
        /**
         * åˆ‡æ¢é¡µé¢
         */
        function showPage(pageId, navElement) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');

            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            if (navElement) {
                navElement.classList.add('active');
            }
            // è¿›å…¥èŠå¤©é¡µæ—¶è¿›è¡Œâ€œå°¾å€¼æ¯”å¯¹â€
            if (pageId === 'chat-page') {
                const chatContainer = document.getElementById('chat-container');
                // è·å–é¡µé¢ä¸Šæœ€åä¸€æ¡æ¶ˆæ¯å…ƒç´ ï¼ˆæ³¨æ„ï¼šIDä¿å­˜åœ¨ .message è¿™ä¸€å±‚ï¼Œä¸æ˜¯ .bubbleï¼‰
                const lastUiMessage = chatContainer.querySelector('.message:last-child');
                
                // 1. è·å– UI ä¸Šçš„æœ€åä¸€ä¸ª ID
                const lastUiId = lastUiMessage ? lastUiMessage.dataset.bubbleId : null;

                // 2. è·å–æ•°æ®é‡Œçš„æœ€åä¸€ä¸ª ID
                const lastDataId = chatHistory.length > 0 ? chatHistory[chatHistory.length - 1].id : null;

                // 3. ç®€å•ç²—æš´çš„å¯¹æ¯”
                // å¦‚æœ ID ä¸ä¸€æ ·ï¼Œæˆ–è€…ï¼ˆæ•°æ®æœ‰ä¸œè¥¿ä½†ç•Œé¢æ²¡ä¸œè¥¿ï¼‰ï¼Œåˆ™é‡ç»˜
                if (lastUiId !== lastDataId || (chatHistory.length > 0 && !lastUiMessage)) {
                    console.log("æ£€æµ‹åˆ° ID ä¸ä¸€è‡´ï¼Œæ‰§è¡Œé‡ç½®æ¸²æŸ“");
                    loadHistoryUI();
                } else {
                    console.log("å†…å®¹åŒ¹é…ï¼Œä¿æŒå½“å‰ç•Œé¢çŠ¶æ€");
                }
                
                // æ»šåŠ¨åˆ°åº•éƒ¨é€»è¾‘
                scrollToBottom();
            }
        }
        /**
         * æ‰“å¼€å’Œå…³é—­è®¾ç½®é¡µé¢ (ç”¨äºå¤´éƒ¨æŒ‰é’®)
         */
        function openSettings() {
            // åŠ è½½èŠå¤©å¯¹è±¡åç§°åˆ°è¾“å…¥æ¡†
            const savedChatName = localStorage.getItem('chatName');
            if (savedChatName) {
                document.getElementById('chat-name-input').value = savedChatName;
            }
            showPage('settings-page', document.querySelector('.nav-item:last-child'));
        }

        function closeSettings() {
            showPage('chat-page', document.querySelector('.nav-item:nth-child(2)'));
        }

        /**
         * æ›´æ–°èŠå¤©é¡µé¢çš„æ ‡é¢˜
         */
        function updateChatName() {
            const savedChatName = localStorage.getItem('chatName');
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && savedChatName) {
                chatNameElement.textContent = savedChatName;
            }
        }

        /**
         * å¯¼å‡ºèŠå¤©è®°å½•ä¸º JSON æ–‡ä»¶
         */
        document.getElementById('export-btn').addEventListener('click', () => {
            const dataStr = JSON.stringify(chatHistory, null, 2); // æ ¼å¼åŒ– JSON
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

            const exportFileName = 'DazzleLight_Chat_Backup_' + new Date().toISOString().slice(0, 10) + '.json';

            // åˆ›å»ºä¸€ä¸ªéšè—çš„ä¸‹è½½é“¾æ¥å¹¶ç‚¹å‡»
            let linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileName);
            document.body.appendChild(linkElement);
            linkElement.click();
            document.body.removeChild(linkElement);
        });
        
        /**
         * å¯¼å…¥èŠå¤©è®°å½•ä» JSON æ–‡ä»¶
         */
        document.getElementById('import-file').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file && file.type === "application/json") {
                const reader = new FileReader();

                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        chatHistory = importedData; 
                        localStorage.setItem('chatHistory', JSON.stringify(importedData));
                        
                        
                        alert('èŠå¤©è®°å½•å¯¼å…¥æˆåŠŸï¼');
                        // åˆ·æ–°æˆ–æ›´æ–°èŠå¤© UI
                    } catch (error) {
                        alert('æ–‡ä»¶è§£æå¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ˜¯æœ‰æ•ˆçš„ JSON æ ¼å¼ã€‚');
                    }
                };
                reader.readAsText(file); // è¯»å–æ–‡ä»¶å†…å®¹ä¸ºæ–‡æœ¬
            } else {
                alert('è¯·é€‰æ‹© JSON æ–‡ä»¶ã€‚');
            }
        });

        /**
         * æ›´æ–°å‘é€æŒ‰é’®çš„çŠ¶æ€
         */
        function updateSendButtonState() {
            // åªæœ‰å½“ baseurl å’Œ apikey éƒ½è®¾ç½®äº†ï¼Œå¹¶ä¸”ç”¨æˆ·è¾“å…¥æ¡†æœ‰å†…å®¹æ—¶æ‰å¯ç”¨å‘é€æŒ‰é’®
            const hasApiConfig = config.baseurl && config.apikey;
            const hasInput = userInput.value.trim().length > 0;
            
            generateBtn.disabled = !hasApiConfig || !hasInput;
            generateBtn.textContent = hasApiConfig ? (hasInput ? 'å‘é€' : 'è¾“å…¥ä¸­...') : 'é…ç½®ç¼ºå¤±';
        }

        // ç›‘å¬ç”¨æˆ·è¾“å…¥ï¼Œå®æ—¶æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        userInput.addEventListener('input', updateSendButtonState);
        
        /**
         * æ¸…ç©ºèŠå¤©è®°å½•
         */
        function clearChat() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿï¼ˆåŒ…æ‹¬ç¼“å­˜ï¼‰")) {
                chatHistory = [];
                pendingSummaryBubbles = [];
                saveChatHistory();
                
                chatContainer.innerHTML = '';
                displayMessage("ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚", "assistant");
            }
        }
        
        // ========== é•¿æŒ‰èœå•åŠŸèƒ½ ==========
        /**
         * è®¾ç½®æ°”æ³¡çš„é•¿æŒ‰èœå•
         */
        function setupLongPressMenu(bubbleElement, bubble) {
            let pressTimer = null;
            
            // è§¦æ‘¸å¼€å§‹
            bubbleElement.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    showBubbleMenu(bubbleElement, bubble, e.touches[0]);
                }, 500); // 500msé•¿æŒ‰
            });
            
            // è§¦æ‘¸ç»“æŸæˆ–ç§»åŠ¨æ—¶å–æ¶ˆ
            bubbleElement.addEventListener('touchend', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            bubbleElement.addEventListener('touchmove', () => {
                if (pressTimer) clearTimeout(pressTimer);
            });
            
            // PCç«¯æ”¯æŒï¼šå³é”®ç‚¹å‡»
            bubbleElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                showBubbleMenu(bubbleElement, bubble, e);
            });
        }
        
        /**
         * æ˜¾ç¤ºæ°”æ³¡èœå•
         */
        function showBubbleMenu(bubbleElement, bubble, touchOrEvent) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (!menuOverlay || !bubbleMenu) {
                console.error('âŒ èœå•å…ƒç´ æœªæ‰¾åˆ°');
                return;
            }
            
            // é«˜äº®å½“å‰æ°”æ³¡
            bubbleElement.classList.add('menu-active');
            
            // æ„å»ºèœå•é¡¹
            const menuItems = [];
            
            // ç¬¬ä¸€é¡¹ï¼šå¤åˆ¶
            menuItems.push({
                icon: 'ğŸ“‹',
                text: 'å¤åˆ¶',
                action: () => copyBubbleContent(bubble)
            });
            
            // æ‰€æœ‰æ°”æ³¡éƒ½æœ‰çš„é€‰é¡¹
            menuItems.push({
                icon: 'ğŸ’¬',
                text: 'å¼•ç”¨',
                action: () => quoteBubble(bubble)
            });
            
            menuItems.push({
                icon: 'âœï¸',
                text: 'ç¼–è¾‘',
                action: () => editBubble(bubble)
            });
            
            menuItems.push({
                icon: 'ğŸ—‘ï¸',
                text: 'åˆ é™¤',
                danger: true,
                action: () => deleteBubble(bubble, bubbleElement)
            });
            
            // assistantæ°”æ³¡é¢å¤–é€‰é¡¹
            if (bubble.role === 'assistant') {
                menuItems.push({
                    icon: 'ğŸ”„',
                    text: 'é‡æ–°ç”Ÿæˆ',
                    action: () => regenerateResponse(bubble)
                });
            }
            
            // æ¸²æŸ“èœå•
            bubbleMenu.innerHTML = menuItems.map(item => `
                <div class="bubble-menu-item ${item.danger ? 'danger' : ''}" data-action="${item.text}">
                    <span class="icon">${item.icon}</span>
                    <span>${item.text}</span>
                </div>
            `).join('');
            
            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            bubbleMenu.querySelectorAll('.bubble-menu-item').forEach((item, index) => {
                item.onclick = () => {
                    menuItems[index].action();
                    closeBubbleMenu(bubbleElement);
                };
            });
            
            // å®šä½èœå•
            const x = touchOrEvent.clientX || touchOrEvent.pageX;
            const y = touchOrEvent.clientY || touchOrEvent.pageY;
            
            bubbleMenu.style.left = x + 'px';
            bubbleMenu.style.top = y + 'px';
            
            // æ˜¾ç¤º
            menuOverlay.classList.add('active');
            bubbleMenu.classList.add('active');
            
            // ç‚¹å‡»é®ç½©å…³é—­
            menuOverlay.onclick = () => closeBubbleMenu(bubbleElement);
        }
        
        /**
         * å…³é—­èœå•
         */
        function closeBubbleMenu(bubbleElement) {
            const menuOverlay = document.getElementById('menu-overlay');
            const bubbleMenu = document.getElementById('bubble-menu');
            
            if (menuOverlay) menuOverlay.classList.remove('active');
            if (bubbleMenu) bubbleMenu.classList.remove('active');
            if (bubbleElement) bubbleElement.classList.remove('menu-active');
        }
        
        /**
         * å¤åˆ¶æ°”æ³¡å†…å®¹åˆ°å‰ªè´´æ¿
         */
        async function copyBubbleContent(bubble) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(bubble.content);
                    showToast('å·²å¤åˆ¶');
                } else {
                    // é™çº§æ–¹æ¡ˆ
                    const textarea = document.createElement('textarea');
                    textarea.value = bubble.content;
                    textarea.style.position = 'fixed';
                    textarea.style.opacity = '0';
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast('å·²å¤åˆ¶');
                }
            } catch (error) {
                console.error('âŒ å¤åˆ¶å¤±è´¥:', error);
                alert('å¤åˆ¶å¤±è´¥');
            }
        }
        
        /**
         * æ˜¾ç¤ºä¸´æ—¶æç¤º
         */
        function showToast(message) {
            const toast = document.createElement('div');
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10001;
                pointer-events: none;
            `;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1000);
        }
        
        /**
         * åˆ é™¤æ°”æ³¡
         */
        function deleteBubble(bubble, bubbleElement) {
            chatHistory = chatHistory.filter(b => b.id !== bubble.id);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => b.id !== bubble.id);
            saveChatHistory();
            
            const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubble.id}"]`);
            if (messageDiv) messageDiv.remove();
            
            console.log('ğŸ—‘ï¸ å·²åˆ é™¤æ°”æ³¡:', bubble.id);
        }
        
        /**
         * é‡æ–°ç”Ÿæˆå›å¤
         */
        async function regenerateResponse(bubble) {
            const bubbleIndex = chatHistory.findIndex(b => b.id === bubble.id);
            if (bubbleIndex === -1) return;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰åç»­å¯¹è¯
            const hasFollowingMessages = bubbleIndex < chatHistory.length - 1;
            
            if (hasFollowingMessages) {
                // æœ‰åç»­å¯¹è¯ï¼Œæ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
                showConfirmDialog({
                    title: 'é‡æ–°ç”Ÿæˆç¡®è®¤',
                    message: 'é‡æ–°ç”Ÿæˆä¼šåˆ é™¤å½“å‰å›å¤åŠä¹‹åçš„æ‰€æœ‰å¯¹è¯ã€‚æ˜¯å¦ä¿å­˜å½“å‰åˆ†æ”¯ï¼Ÿ',
                    buttons: [
                        {
                            text: 'ä¿å­˜å¹¶é‡æ–°ç”Ÿæˆ',
                            className: 'primary',
                            action: async () => {
                                // å¯¼å‡ºå½“å‰åˆ†æ”¯
                                exportCurrentBranch();
                                // æ‰§è¡Œé‡æ–°ç”Ÿæˆ
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: 'ç›´æ¥é‡æ–°ç”Ÿæˆ',
                            className: 'secondary',
                            action: async () => {
                                await doRegenerate(bubbleIndex);
                            }
                        },
                        {
                            text: 'å–æ¶ˆ',
                            className: 'cancel',
                            action: () => {
                                hideConfirmDialog();
                            }
                        }
                    ]
                });
            } else {
                // æ˜¯æœ€åä¸€æ¡ï¼Œç›´æ¥é‡æ–°ç”Ÿæˆ
                await doRegenerate(bubbleIndex);
            }
        }
        
        /**
         * æ‰§è¡Œé‡æ–°ç”Ÿæˆï¼ˆå†…éƒ¨å‡½æ•°ï¼‰
         */
        async function doRegenerate(bubbleIndex) {
            // å‘ä¸ŠæŸ¥æ‰¾ï¼šæ‰¾åˆ°æœ¬è½®assistantå›å¤çš„ç¬¬ä¸€æ¡
            // å³å‘ä¸Šæ‰¾åˆ°æœ€åä¸€ä¸ªuseræ°”æ³¡åçš„ç¬¬ä¸€ä¸ªassistantæ°”æ³¡
            let startIndex = bubbleIndex;
            
            // å‘ä¸Šéå†ï¼Œæ‰¾åˆ°åŒä¸€ç»„çš„ç¬¬ä¸€ä¸ªassistant
            while (startIndex > 0 && chatHistory[startIndex - 1].role === 'assistant') {
                startIndex--;
            }
            
            console.log('ğŸ” å‘ä¸ŠæŸ¥æ‰¾: ä»ç´¢å¼•', bubbleIndex, 'æ‰¾åˆ°ç¬¬ä¸€ä¸ªassistantåœ¨ç´¢å¼•', startIndex);
            
            // åˆ é™¤ä»startIndexå¼€å§‹çš„æ‰€æœ‰æ°”æ³¡ï¼ˆåŒ…æ‹¬userå’Œassistantï¼‰
            const bubblestoDelete = chatHistory.slice(startIndex);
            
            // ä»UIåˆ é™¤
            bubblestoDelete.forEach(b => {
                const msgDiv = chatContainer.querySelector(`[data-bubble-id="${b.id}"]`);
                if (msgDiv) msgDiv.remove();
            });
            
            // ä»æ•°æ®åˆ é™¤
            chatHistory = chatHistory.slice(0, startIndex);
            pendingSummaryBubbles = pendingSummaryBubbles.filter(b => 
                !bubblestoDelete.find(deleted => deleted.id === b.id)
            );
            saveChatHistory();
            
            console.log('ğŸ”„ é‡æ–°ç”Ÿæˆï¼Œåˆ é™¤äº†', bubblestoDelete.length, 'ä¸ªæ°”æ³¡ (ä»ç´¢å¼•', startIndex, 'å¼€å§‹)');
            
            // è°ƒç”¨API
            await callAPIForRegeneration();
        }
        
        /**
         * å¯¼å‡ºå½“å‰åˆ†æ”¯
         */
        function exportCurrentBranch() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `chat_branch_${timestamp}.json`;
            
            const dataStr = JSON.stringify(chatHistory, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
            
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showToast('åˆ†æ”¯å·²ä¿å­˜');
            console.log('ğŸ’¾ å·²å¯¼å‡ºåˆ†æ”¯:', filename);
        }
        
        /**
         * æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
         */
        function showConfirmDialog({ title, message, buttons }) {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            const titleEl = document.getElementById('confirm-title');
            const messageEl = document.getElementById('confirm-message');
            const buttonsEl = document.getElementById('confirm-buttons');
            
            if (!dialog || !overlay) return;
            
            // è®¾ç½®å†…å®¹
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            // ç”ŸæˆæŒ‰é’®
            buttonsEl.innerHTML = buttons.map((btn, idx) => `
                <button class="confirm-dialog-button ${btn.className}" data-btn-index="${idx}">
                    ${btn.text}
                </button>
            `).join('');
            
            // ç»‘å®šäº‹ä»¶
            buttonsEl.querySelectorAll('button').forEach((btnEl, idx) => {
                btnEl.onclick = () => {
                    hideConfirmDialog();
                    if (buttons[idx].action) {
                        buttons[idx].action();
                    }
                };
            });
            
            // æ˜¾ç¤º
            overlay.classList.add('active');
            dialog.classList.add('active');
            
            // ç‚¹å‡»é®ç½©å…³é—­
            overlay.onclick = hideConfirmDialog;
        }
        
        /**
         * éšè—ç¡®è®¤å¯¹è¯æ¡†
         */
        function hideConfirmDialog() {
            const dialog = document.getElementById('confirm-dialog');
            const overlay = document.getElementById('menu-overlay');
            
            if (dialog) dialog.classList.remove('active');
            if (overlay) overlay.classList.remove('active');
        }
        
        /**
         * è°ƒç”¨APIé‡æ–°ç”Ÿæˆ
         */
        async function callAPIForRegeneration() {
            showTypingIndicator();
            
            try {
                const N = parseInt(localStorage.getItem('contextWindowSize')) || 50;
                const recentBubbles = chatHistory.slice(-N);
                const apiMessages = convertToAPIFormat(recentBubbles);
                
                let finalSystemPrompt = config.systemPrompt;
                const now = new Date();
                const currentTimeStr = now.toLocaleString('zh-CN', {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
                });
                finalSystemPrompt += `\n\n[å½“å‰æ—¶é—´]: ${currentTimeStr}`;
                
                const messagesWithTime = apiMessages.map(msg => {
                    if (msg.timestamp) {
                        const time = new Date(msg.timestamp);
                        const timeStr = time.toLocaleString('zh-CN', {
                            year: 'numeric', month: '2-digit', day: '2-digit',
                            hour: '2-digit', minute: '2-digit', hour12: false
                        });
                        return { role: msg.role, content: `[${timeStr}] ${msg.content}` };
                    }
                    return { role: msg.role, content: msg.content };
                });
                
                const messages = [
                    { role: "system", content: finalSystemPrompt },
                    ...messagesWithTime
                ];
                
                const response = await fetch(config.baseurl + '/chat/completions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apikey}` },
                    body: JSON.stringify({ model: config.modelname, messages: messages })
                });
                
                const data = await response.json();
                hideTypingIndicator();
                
                if (data.choices && data.choices[0]) {
                    const aiResponseText = data.choices[0].message.content.trim();
                    processAndDisplaySegments(aiResponseText);
                }
            } catch (error) {
                hideTypingIndicator();
                console.error('é‡æ–°ç”Ÿæˆå¤±è´¥:', error);
                alert('é‡æ–°ç”Ÿæˆå¤±è´¥');
            }
        }
        
        /**
         * å¼•ç”¨æ°”æ³¡ï¼ˆå ä½ï¼‰
         */
        function quoteBubble(bubble) {
            showToast('å¼•ç”¨åŠŸèƒ½å¼€å‘ä¸­');
        }
        
        /**
         * ç¼–è¾‘æ°”æ³¡ï¼ˆå ä½ï¼‰
         */
        function editBubble(bubble) {
            showToast('ç¼–è¾‘åŠŸèƒ½å¼€å‘ä¸­');
        }
        // ====================================

        /**
         * åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºä¸€æ¡æ¶ˆæ¯
         * @param {string} text - æ¶ˆæ¯å†…å®¹
         * @param {string} role - æ¶ˆæ¯è§’è‰² ('user' æˆ– 'ai')
         * @param {number} status - æ¶ˆæ¯çŠ¶æ€ (1=å•å‹¾, 2=åŒå‹¾, 0=æ— å‹¾)
         * @param {string} timestamp - å¯é€‰çš„æ—¶é—´æˆ³ï¼Œå¦‚æœä¸æä¾›åˆ™ä½¿ç”¨å½“å‰æ—¶é—´
         * @returns {string} è¿”å›ä½¿ç”¨çš„æ—¶é—´æˆ³
         */
        /**
         * æ˜¾ç¤ºä¸€æ¡æ¶ˆæ¯ï¼ˆæ°”æ³¡ï¼‰
         * @param {string} text - æ¶ˆæ¯å†…å®¹
         * @param {string} role - 'user' æˆ– 'ai' / 'assistant'
         * @param {number} status - å¯¹å‹¾çŠ¶æ€ (0=æ— , 1=å•å‹¾, 2=åŒå‹¾)
         * @param {string} timestamp - æ—¶é—´æˆ³ï¼ˆå¯é€‰ï¼‰
         * @param {boolean} saveToHistory - æ˜¯å¦ä¿å­˜åˆ°chatHistoryï¼ˆé»˜è®¤trueï¼‰
         * @returns {object} è¿”å›åˆ›å»ºçš„æ°”æ³¡å¯¹è±¡
         */
        function displayMessage(text, role, status = 0, timestamp = null, saveToHistory = true, existingId = null, skipScroll = false) {
            // ç”Ÿæˆæ—¶é—´æˆ³
            const fullTimestamp = timestamp || new Date().toISOString();
            // ç”Ÿæˆå”¯ä¸€ID
            const bubbleId = existingId || ('bubble_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
            // åˆ›å»ºæ°”æ³¡å¯¹è±¡
            const bubble = {
                id: bubbleId,
                role: role,
                content: text,
                timestamp: fullTimestamp
            };
            
            // ä¿å­˜åˆ°chatHistory
            if (saveToHistory) {
                chatHistory.push(bubble);
                pendingSummaryBubbles.push(bubble); // åŒæ—¶åŠ å…¥å¾…æ€»ç»“é˜Ÿåˆ—
                saveChatHistory();
            }
            
            // === æ¸²æŸ“UI ===
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);
            messageDiv.dataset.bubbleId = bubble.id; // ä¿å­˜æ°”æ³¡ID

            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bubble');
            bubbleDiv.textContent = text;
            
            const metaDiv = document.createElement('div');
            metaDiv.classList.add('message-meta');
            
            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
            const time = new Date(fullTimestamp);
            const timeStr = time.getHours().toString().padStart(2, '0') + ':' + 
                         time.getMinutes().toString().padStart(2, '0');
            
            const timeSpan = document.createElement('span');
            timeSpan.textContent = timeStr;
            metaDiv.appendChild(timeSpan);
            
            // ç”¨æˆ·æ¶ˆæ¯æ˜¾ç¤ºå¯¹å‹¾
            if (role === 'user') {
                const checkmark = document.createElement('span');
                checkmark.classList.add('checkmark');
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = 'âœ“âœ“';
                } else if (status === 1) {
                    checkmark.textContent = 'âœ“';
                }
                metaDiv.appendChild(checkmark);
                messageDiv.dataset.status = status;
            }
            
            bubbleDiv.appendChild(metaDiv);
            messageDiv.appendChild(bubbleDiv);
            chatContainer.appendChild(messageDiv);
            
            // æ·»åŠ é•¿æŒ‰èœå•
            setupLongPressMenu(bubbleDiv, bubble);
            
            // é™¤éskipScroll=trueï¼Œå¦åˆ™æ¯æ¡æ¶ˆæ¯éƒ½æ»šåŠ¨ï¼ˆè¿™æ ·AIæ¶ˆæ¯è·³å‡ºæ¥æ—¶èƒ½çœ‹åˆ°ï¼‰
            if (!skipScroll) {
                scrollToBottom();
            }
            
            return bubble;
        }
        
        /**
         * æ›´æ–°æœ€åä¸€æ¡ç”¨æˆ·æ¶ˆæ¯çš„å¯¹å‹¾çŠ¶æ€
         * @param {number} status - 1=å•å‹¾, 2=åŒå‹¾
         */
        function updateLastMessageStatus(status) {
            const userMessages = chatContainer.querySelectorAll('.message.user');
            if (userMessages.length === 0) return;
            
            const lastMessage = userMessages[userMessages.length - 1];
            const checkmark = lastMessage.querySelector('.checkmark');
            
            if (checkmark) {
                if (status === 2) {
                    checkmark.classList.add('double');
                    checkmark.textContent = 'âœ“âœ“';
                } else if (status === 1) {
                    checkmark.textContent = 'âœ“';
                }
                lastMessage.dataset.status = status;
            }
        }
        
        /**
         * æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
         */
        function showTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement) {
                chatNameElement.dataset.originalName = chatNameElement.textContent;
                chatNameElement.innerHTML = '<span class="typing-indicator">å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­...</span>';
            }
        }
        
        /**
         * éšè—"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."ï¼Œæ¢å¤èŠå¤©å¯¹è±¡åç§°
         */
        function hideTypingIndicator() {
            const chatNameElement = document.getElementById('chat-name');
            if (chatNameElement && chatNameElement.dataset.originalName) {
                chatNameElement.textContent = chatNameElement.dataset.originalName;
            }
        }
        /**
         * æ¸…ç† API å“åº”æ–‡æœ¬ï¼Œå»é™¤æ—¶é—´æˆ³ç­‰å¤šä½™ä¿¡æ¯
         * @param {string} text - åŸå§‹æ–‡æœ¬
         * @returns {string} æ¸…ç†åçš„æ–‡æœ¬
         */
        function cleanApiResponse(text) {
            if (!text) return "";
            
            // ç§»é™¤å¼€å¤´çš„æ—¶é—´æˆ³ï¼š[2024/12/20 21:39] æˆ– [2024/12/20 21:39 æ˜ŸæœŸäº”]
            // åŒ¹é…æ ¼å¼ï¼š[å¹´/æœˆ/æ—¥ æ—¶:åˆ†] æˆ– [å¹´/æœˆ/æ—¥ æ—¶:åˆ† æ˜ŸæœŸX]
            const timestampRegex = /^\s*\[\d{4}\/\d{2}\/\d{2}\s+\d{2}:\d{2}(?:\s+æ˜ŸæœŸ[ä¸€äºŒä¸‰å››äº”å…­æ—¥])?\]\s*/;
            
            // ç§»é™¤æ—¶é—´æˆ³
            let cleaned = text.replace(timestampRegex, '');
            
            // å¦‚æœè¿˜æœ‰å¤šä½™çš„ç©ºç™½ï¼Œå†æ¸…ç†ä¸€æ¬¡
            cleaned = cleaned.trim();
            
            //console.log('ğŸ§¹ æ¸…ç†å‰:', text.substring(0, 50));
            //console.log('ğŸ§¹ æ¸…ç†å:', cleaned.substring(0, 50));
            
            return cleaned;
        }
        /**
         * å¤„ç† AI çš„å®Œæ•´å“åº”ï¼Œå¹¶æ ¹æ® '\n\n' é€æ¡æ˜¾ç¤ºæ¶ˆæ¯ã€‚
         * åŒæ—¶å°†å®Œæ•´çš„AIå›å¤è®¡å…¥ chatHistoryã€‚
         * @param {string} fullAiText - ä» AI API æ¥æ”¶åˆ°çš„å®Œæ•´æ–‡æœ¬ã€‚
         */
        function processAndDisplaySegments(fullAiText) {
            // 1. å®šä¹‰æ¶ˆæ¯åˆ†éš”ç¬¦å’Œé—´éš”æ—¶é—´
            const separator = '\n\n';
            const delay = 500; // æ¯æ¡æ¶ˆæ¯ä¹‹é—´çš„é—´éš”ï¼Œå•ä½ï¼šæ¯«ç§’ (0.5 ç§’)
            
            // ç”ŸæˆAIæ¶ˆæ¯çš„æ—¶é—´æˆ³ï¼ˆæ‰€æœ‰åˆ†æ®µä½¿ç”¨åŒä¸€ä¸ªæ—¶é—´ï¼‰
            const aiTimestamp = new Date().toISOString();

            // 2. æ ¹æ® '\n\n' åˆ†å‰²å®Œæ•´çš„å“åº”æ–‡æœ¬
            const messageSegments = fullAiText.split(separator).filter(seg => seg.trim());

            // 3. é€æ¡éå†å¹¶ä½¿ç”¨ setTimeout å®ç°å»¶è¿Ÿæ˜¾ç¤º
            messageSegments.forEach((segment, index) => {
                // æ¸…ç†å¯èƒ½çš„æ—¶é—´æˆ³ï¼ˆæœ‰äº›AIå¯èƒ½åœ¨æ¯æ®µéƒ½åŠ æ—¶é—´æˆ³ï¼‰
                let cleanSegment = cleanApiResponse(segment);
                cleanSegment = cleanSegment.trim();

                if (cleanSegment.length > 0) {
                    // å®ç°å»¶è¿Ÿæ•ˆæœ
                    setTimeout(() => {
                        // æ¯æ¡æ¶ˆæ¯éƒ½æ˜¾ç¤ºï¼ˆè·³è¿‡scrollToBottomï¼Œå› ä¸ºdisplayMessageä¼šè‡ªåŠ¨è°ƒç”¨ï¼‰
                        displayMessage(cleanSegment, 'assistant', 0, aiTimestamp, true, null, false); 
                    }, index * delay); 
                }
            });

            // 4. åœ¨æ‰€æœ‰åˆ†æ®µæ˜¾ç¤ºå®Œæ¯•åï¼Œå¤„ç†æœ€ç»ˆçš„çŠ¶æ€
            const totalDelay = messageSegments.length * delay;
            setTimeout(() => {
                // AIå›å¤å®Œæˆåï¼Œé‡ç½®ç­‰å¾…çŠ¶æ€
                isWaitingForAI = false;
                console.log('âœ… AIå›å¤å®Œæˆï¼Œç­‰å¾…çŠ¶æ€å·²é‡ç½®');
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å‘é€çš„æ¶ˆæ¯
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        // é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯å·²ç»ç­‰å¤Ÿ7ç§’ â†’ å¼‚æ­¥å»¶è¿Ÿå‘é€
                        console.log('ğŸ“¬ å‘ç°å¾…å‘é€æ¶ˆæ¯', pendingUserMessages.length, 'æ¡ï¼Œä¸”å·²åˆ°æ—¶é—´ï¼Œå‡†å¤‡å‘é€');
                        // ä½¿ç”¨setTimeoutå¼‚æ­¥è°ƒç”¨ï¼Œé¿å…åœ¨å½“å‰äº‹ä»¶å¾ªç¯ä¸­ç«‹å³æ‰§è¡Œ
                        setTimeout(() => {
                            sendBatchMessages();
                        }, 100); // å»¶è¿Ÿ100msï¼Œç»™æµè§ˆå™¨å¤„ç†å®Œå½“å‰çŠ¶æ€çš„æ—¶é—´
                    } else {
                        // é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯è¿˜æœªåˆ°7ç§’ â†’ ç»§ç»­è®¡æ—¶
                        console.log('ğŸ“¬ å‘ç°å¾…å‘é€æ¶ˆæ¯', pendingUserMessages.length, 'æ¡ï¼Œä½†æœªåˆ°æ—¶é—´ï¼Œç»§ç»­è®¡æ—¶');
                        startBatchTimer();
                    }
                }
            }, totalDelay);
        }
        
        // ========== æ‰¹é‡å‘é€åŠŸèƒ½ ==========
        /**
         * å¼€å§‹æ‰¹é‡å‘é€è®¡æ—¶å™¨
         */
        function startBatchTimer() {
            // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
            }
            
            // é‡ç½®"å·²åˆ°æ—¶é—´"æ ‡è®°
            hasReachedWaitTime = false;
            
            // è·å–ç­‰å¾…æ—¶é—´ï¼ˆç§’ï¼‰
            const waitTime = parseInt(localStorage.getItem('batchWaitTime')) || 7;
            
            console.log('â° å¯åŠ¨è®¡æ—¶å™¨ï¼Œç­‰å¾…', waitTime, 'ç§’...');
            
            // å¯åŠ¨æ–°è®¡æ—¶å™¨
            batchSendTimer = setTimeout(() => {
                console.log('â° è®¡æ—¶å™¨åˆ°æœŸ');
                sendBatchMessages();
            }, waitTime * 1000);
        }
        
        /**
         * å–æ¶ˆæ‰¹é‡å‘é€è®¡æ—¶å™¨
         */
        function cancelBatchTimer() {
            if (batchSendTimer) {
                clearTimeout(batchSendTimer);
                batchSendTimer = null;
                console.log('â° è®¡æ—¶å™¨å·²å–æ¶ˆ');
            }
        }
        
        /**
         * å‘é€æ‰¹é‡æ¶ˆæ¯ï¼ˆè®¡æ—¶å™¨åˆ°æœŸæ—¶è°ƒç”¨ï¼‰
         */
        async function sendBatchMessages() {
            // æ ‡è®°å·²åˆ°è¾¾ç­‰å¾…æ—¶é—´
            hasReachedWaitTime = true;
            
            if (pendingUserMessages.length === 0) {
                console.log('ğŸ“­ æ²¡æœ‰å¾…å‘é€çš„æ¶ˆæ¯');
                hasReachedWaitTime = false;
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ­£åœ¨ç­‰å¾…AIå›å¤
            if (isWaitingForAI) {
                console.log('â³ å·²åˆ°7ç§’ä½†æ­£åœ¨ç­‰å¾…AIå›å¤ï¼Œä¿æŒhasReachedWaitTime=true');
                // ä¸é‡å¯è®¡æ—¶å™¨ï¼Œä¿æŒhasReachedWaitTime=true
                // ç­‰AIå›å¤å®Œæˆåä¼šæ£€æŸ¥è¿™ä¸ªæ ‡è®°
                return;
            }
            
            // ä¸¤ä¸ªæ¡ä»¶éƒ½æ»¡è¶³ï¼šå·²åˆ°æ—¶é—´ AND ä¸åœ¨ç­‰å¾…AI
            console.log('ğŸ“¤ å‘é€æ‰¹é‡æ¶ˆæ¯ï¼Œå…±', pendingUserMessages.length, 'æ¡');
            
            // é‡ç½®æ ‡è®°
            hasReachedWaitTime = false;
            
            // æ ‡è®°æ­£åœ¨ç­‰å¾…AI
            isWaitingForAI = true;
            
            // å°†æ‰€æœ‰å¾…å‘é€æ¶ˆæ¯çš„çŠ¶æ€æ›´æ–°ä¸ºåŒå‹¾
            pendingUserMessages.forEach(bubbleId => {
                const messageDiv = chatContainer.querySelector(`[data-bubble-id="${bubbleId}"]`);
                if (messageDiv) {
                    const checkmark = messageDiv.querySelector('.checkmark');
                    if (checkmark) {
                        checkmark.classList.add('double');
                        checkmark.textContent = 'âœ“âœ“';
                    }
                    messageDiv.dataset.status = '2';
                }
            });
            
            // æ˜¾ç¤º"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
            showTypingIndicator();
            
            // æ¸…ç©ºå¾…å‘é€é˜Ÿåˆ—
            pendingUserMessages = [];
            
            // è°ƒç”¨API
            await callAPIToGenerate();
        }
        
        /**
         * è°ƒç”¨APIç”Ÿæˆå›å¤ï¼ˆä»generateBtn.onclickä¸­æå–ï¼‰
         */
        async function callAPIToGenerate() {
            // å¯åŠ¨APIè¶…æ—¶è®¡æ—¶å™¨
            const timeoutSeconds = parseInt(localStorage.getItem('apiTimeout')) || 60;
            console.log('â° å¯åŠ¨APIè¶…æ—¶è®¡æ—¶å™¨:', timeoutSeconds, 'ç§’');
            
            apiTimeoutTimer = setTimeout(() => {
                console.error('â° APIè¯·æ±‚è¶…æ—¶ï¼ˆ', timeoutSeconds, 'ç§’ï¼‰');
                
                // é‡ç½®çŠ¶æ€
                isWaitingForAI = false;
                hasReachedWaitTime = false;
                hideTypingIndicator();
                
                // ç§»é™¤åŠ è½½å ä½ç¬¦
                const placeholder = chatContainer.querySelector('.message.ai .bubble');
                if (placeholder && placeholder.textContent === '...') {
                    placeholder.parentElement.remove();
                }
                
                // æ˜¾ç¤ºè¶…æ—¶æ¶ˆæ¯
                const errorBubble = document.createElement('div');
                errorBubble.classList.add('message', 'ai');
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                bubble.style.color = '#d32f2f';
                bubble.textContent = `â° API è¯·æ±‚è¶…æ—¶ï¼ˆ${timeoutSeconds}ç§’æœªå“åº”ï¼‰ã€‚è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚`;
                errorBubble.appendChild(bubble);
                chatContainer.appendChild(errorBubble);
                scrollToBottom();
                
                // æ£€æŸ¥é˜Ÿåˆ—ï¼Œå¦‚æœæœ‰æ¶ˆæ¯å¯èƒ½éœ€è¦é‡è¯•
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('ğŸ“¬ è¶…æ—¶åå‘ç°å¾…å‘é€æ¶ˆæ¯ï¼Œå‡†å¤‡é‡è¯•');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('ğŸ“¬ è¶…æ—¶åå‘ç°å¾…å‘é€æ¶ˆæ¯ï¼Œé‡å¯è®¡æ—¶å™¨');
                        startBatchTimer();
                    }
                }
            }, timeoutSeconds * 1000);
            
            // é¢„ç•™ä¸€ä¸ªä½ç½®ç»™ AI çš„å›å¤ï¼Œç”¨äºæµå¼å“åº”æˆ–åŠ è½½æŒ‡ç¤º
            const aiMessagePlaceholder = document.createElement('div');
            aiMessagePlaceholder.classList.add('message', 'ai');
            const aiBubble = document.createElement('div');
            aiBubble.classList.add('bubble');
            aiBubble.textContent = '...'; // åŠ è½½æŒ‡ç¤º
            aiMessagePlaceholder.appendChild(aiBubble);
            chatContainer.appendChild(aiMessagePlaceholder);
            scrollToBottom();

            // B. è·å–ç”¨æˆ·è®¾ç½®çš„ä¸Šä¸‹æ–‡çª—å£å¤§å° (N)
            const contextSizeKey = 'contextWindowSize'; 
            const N = parseInt(localStorage.getItem(contextSizeKey)) || 50; 
            
            // C. æˆªå–æœ€åNä¸ªæ°”æ³¡
            const recentBubbles = chatHistory.slice(-N);
            
            // D. è½¬æ¢ä¸ºAPIæ ¼å¼ï¼ˆåˆå¹¶ç›¸é‚»åŒroleçš„æ¶ˆæ¯ï¼Œå¤§å¹…èŠ‚çœtokenğŸ’°ï¼‰
            const apiMessages = convertToAPIFormat(recentBubbles);
            console.log('ğŸ’° Tokenä¼˜åŒ–:', recentBubbles.length, 'ä¸ªæ°”æ³¡ â†’', apiMessages.length, 'æ¡APIæ¶ˆæ¯');

            // E. æ„å»ºæœ€ç»ˆçš„ Messages åˆ—è¡¨
            let finalSystemPrompt = config.systemPrompt;
            
            // æ·»åŠ å½“å‰æ—¶é—´ä¿¡æ¯åˆ°ç³»ç»Ÿæç¤º
            const now = new Date();
            const currentTimeStr = now.toLocaleString('zh-CN', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', weekday: 'long', hour12: false
            });
            finalSystemPrompt += `\n\n[å½“å‰æ—¶é—´]: ${currentTimeStr}`;
            
            // ä¸ºæ¯æ¡æ¶ˆæ¯æ·»åŠ æ—¶é—´ä¿¡æ¯
            const messagesWithTime = apiMessages.map(msg => {
                if (msg.timestamp) {
                    const time = new Date(msg.timestamp);
                    const timeStr = time.toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', hour12: false
                    });
                    return {
                        role: msg.role,
                        content: `[${timeStr}] ${msg.content}`
                    };
                } else {
                    return {
                        role: msg.role,
                        content: msg.content
                    };
                }
            });
            
            const messages = [
                { role: "system", content: finalSystemPrompt },
                ...messagesWithTime 
            ];
            
            const requestBody = {
                model: config.modelname,
                messages: messages,
                max_tokens: 3000,
                temperature: 1.2
            };

            const apiUrl = config.baseurl.endsWith('/v1') ? 
                           `${config.baseurl}/chat/completions` : 
                           `${config.baseurl}/v1/chat/completions`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                
                // æ¸…é™¤è¶…æ—¶è®¡æ—¶å™¨
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('âœ… APIå“åº”æˆåŠŸï¼Œå·²æ¸…é™¤è¶…æ—¶è®¡æ—¶å™¨');
                }
                
                // å®‰å…¨è®¿é—®APIæ•°æ®
                if (!data || !data.choices || !data.choices[0] || 
                    !data.choices[0].message || !data.choices[0].message.content) {
                    throw new Error('APIè¿”å›æ•°æ®æ ¼å¼ä¸æ­£ç¡®: ' + JSON.stringify(data).substring(0, 200));
                }
                
                let aiResponseText = data.choices[0].message.content.trim();
                console.log("ã€APIåŸå§‹è¾“å‡ºã€‘:", encodeURI(aiResponseText).substring(0, 50));
                aiResponseText = cleanApiResponse(aiResponseText);
                console.log("ã€APIæ¸…ç†åè¾“å‡ºã€‘:", encodeURI(aiResponseText).substring(0, 50));
                
                // ç§»é™¤é¢„ç•™çš„å ä½ç¬¦
                if (chatContainer.contains(aiMessagePlaceholder)) {
                    chatContainer.removeChild(aiMessagePlaceholder);
                }
                
                // éšè—"å¯¹æ–¹æ­£åœ¨è¾“å…¥ä¸­..."
                hideTypingIndicator();
                
                // è°ƒç”¨å‡½æ•°æ¥å¤„ç†å¹¶é€æ¡æ˜¾ç¤ºæ¶ˆæ¯
                processAndDisplaySegments(aiResponseText);

            } catch (error) {
                console.error("API è°ƒç”¨å‡ºé”™:", error);
                
                // æ¸…é™¤è¶…æ—¶è®¡æ—¶å™¨
                if (apiTimeoutTimer) {
                    clearTimeout(apiTimeoutTimer);
                    apiTimeoutTimer = null;
                    console.log('âŒ APIè°ƒç”¨å‡ºé”™ï¼Œå·²æ¸…é™¤è¶…æ—¶è®¡æ—¶å™¨');
                }
                
                aiBubble.textContent = `[é”™è¯¯] æ— æ³•è·å–å›å¤ã€‚è¯·æ£€æŸ¥æ‚¨çš„è®¾ç½®å’Œç½‘ç»œè¿æ¥ã€‚è¯¦ç»†é”™è¯¯ï¼š${error.message}`;
                hideTypingIndicator();
                isWaitingForAI = false;
                
                // æ£€æŸ¥é˜Ÿåˆ—ï¼Œå¦‚æœæœ‰æ¶ˆæ¯å¯èƒ½éœ€è¦é‡è¯•
                if (pendingUserMessages.length > 0) {
                    if (hasReachedWaitTime) {
                        console.log('ğŸ“¬ é”™è¯¯åå‘ç°å¾…å‘é€æ¶ˆæ¯ï¼Œå‡†å¤‡é‡è¯•');
                        setTimeout(() => sendBatchMessages(), 100);
                    } else {
                        console.log('ğŸ“¬ é”™è¯¯åå‘ç°å¾…å‘é€æ¶ˆæ¯ï¼Œé‡å¯è®¡æ—¶å™¨');
                        startBatchTimer();
                    }
                }
            }
        }
        // ====================================

        /**
         * ç‚¹å‡»ç”ŸæˆæŒ‰é’®ï¼Œè°ƒç”¨ API
         */
        /**
         * ç‚¹å‡»å‘é€æŒ‰é’®
         */
        generateBtn.onclick = async () => {
            const userMessage = userInput.value.trim();
            if (!userMessage) return;

            // æ£€æŸ¥é…ç½®
            if (!config.baseurl || !config.apikey) {
                alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­å¡«å†™ Base URL å’Œ API Keyï¼');
                return;
            }

            // 1. æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯ï¼ˆå•å‹¾ï¼‰
            const bubble = displayMessage(userMessage, 'user', 1);
            
            // 2. æ¸…ç©ºè¾“å…¥æ¡†
            userInput.value = '';
            updateSendButtonState();
            
            // 3. å°†æ­¤æ°”æ³¡IDåŠ å…¥å¾…å‘é€é˜Ÿåˆ—
            pendingUserMessages.push(bubble.id);
            console.log('ğŸ“ æ·»åŠ åˆ°é˜Ÿåˆ—:', bubble.id, 'å½“å‰é˜Ÿåˆ—é•¿åº¦:', pendingUserMessages.length);
            
            // 4. å¯åŠ¨/é‡å¯è®¡æ—¶å™¨
            startBatchTimer();
        };
        /**
         *æ»šåŠ¨åˆ°èŠå¤©å†…å®¹åº•éƒ¨ï¼ˆåŒ requestAnimationFrame ç¡®ä¿æ¸²æŸ“å®Œæˆï¼‰
         
        /**
         * æ»šåŠ¨åˆ°èŠå¤©å†…å®¹åº•éƒ¨
         */
        function scrollToBottom() {
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            
            if (contentArea && contentArea.scrollHeight > 0) {
                // ä½¿ç”¨requestAnimationFrameç¡®ä¿DOMå·²æ¸²æŸ“ï¼Œç„¶åç«‹å³æ»šåŠ¨
                requestAnimationFrame(() => {
                    contentArea.scrollTop = contentArea.scrollHeight;
                });
            }
        }
        // ç›‘å¬ Enter é”®å‘é€ (å¯é€‰)
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ¢è¡Œè¡Œä¸º
                if (!generateBtn.disabled) {
                    generateBtn.click();
                }
            }
        });
        
        /**
         * å…¨å±€è¯Šæ–­å‡½æ•° - åœ¨consoleä¸­è°ƒç”¨æ¥æ£€æŸ¥å¸ƒå±€
         */
        window.debugLayout = function() {
            console.log('========== å¸ƒå±€è¯Šæ–­æŠ¥å‘Š ==========');
            
            const body = document.body;
            const appContainer = document.getElementById('app-container');
            const activePage = document.querySelector('.page.active');
            const contentArea = activePage ? activePage.querySelector('.content') : null;
            const chatContainer = document.getElementById('chat-container');
            
            console.log('ğŸ“± Body:', {
                height: body.style.height,
                computedHeight: window.getComputedStyle(body).height,
                overflow: window.getComputedStyle(body).overflow
            });
            
            console.log('ğŸ“¦ Appå®¹å™¨:', {
                height: appContainer.style.height,
                width: appContainer.style.width,
                computedHeight: window.getComputedStyle(appContainer).height,
                display: window.getComputedStyle(appContainer).display
            });
            
            console.log('ğŸ“„ æ´»è·ƒé¡µé¢:', {
                id: activePage ? activePage.id : 'æ— ',
                height: activePage ? window.getComputedStyle(activePage).height : 'æ— ',
                display: activePage ? window.getComputedStyle(activePage).display : 'æ— ',
                flexGrow: activePage ? window.getComputedStyle(activePage).flexGrow : 'æ— '
            });
            
            console.log('ğŸ“‹ Contentå®¹å™¨:', {
                found: !!contentArea,
                height: contentArea ? window.getComputedStyle(contentArea).height : 'æ— ',
                scrollHeight: contentArea ? contentArea.scrollHeight : 'æ— ',
                clientHeight: contentArea ? contentArea.clientHeight : 'æ— ',
                offsetHeight: contentArea ? contentArea.offsetHeight : 'æ— ',
                display: contentArea ? window.getComputedStyle(contentArea).display : 'æ— ',
                overflow: contentArea ? window.getComputedStyle(contentArea).overflow : 'æ— ',
                flexGrow: contentArea ? window.getComputedStyle(contentArea).flexGrow : 'æ— ',
                minHeight: contentArea ? window.getComputedStyle(contentArea).minHeight : 'æ— '
            });
            
            console.log('ğŸ’¬ Chatå®¹å™¨:', {
                height: chatContainer ? window.getComputedStyle(chatContainer).height : 'æ— ',
                scrollHeight: chatContainer ? chatContainer.scrollHeight : 'æ— ',
                childCount: chatContainer ? chatContainer.children.length : 'æ— '
            });
            
            console.log('================================');
            console.log('ğŸ’¡ æç¤º: è°ƒç”¨ window.scrollToBottom() æ¥æ‰‹åŠ¨æ»šåŠ¨');
        };
        
        console.log('âœ… è°ƒè¯•å·¥å…·å·²åŠ è½½ï¼Œåœ¨consoleä¸­è¾“å…¥ debugLayout() æ¥æ£€æŸ¥å¸ƒå±€');
        
        
    </script>

</body>
</html>
