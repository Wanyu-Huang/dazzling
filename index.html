<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIç§èŠ - ä»¿å¾®ä¿¡ç•Œé¢</title>
    <style>
        /* ç§»åŠ¨ç«¯åŸºç¡€æ ·å¼ */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; /* é˜²æ­¢åº•éƒ¨è¾“å…¥æ¡†æ»šåŠ¨ */
        }
        
        /* é¡¶éƒ¨å¯¼èˆªæ  (Header) */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #EDEDED; /* ä»¿å¾®ä¿¡æ·±è‰²é¡¶éƒ¨ */
            color: #333;
            font-size: 18px;
            font-weight: 500;
            border-bottom: 1px solid #dcdcdc;
            flex-shrink: 0;
        }

        .header-title {
            flex-grow: 1;
            text-align: center;
        }

        .header button {
            background: none;
            border: none;
            color: #333;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        /* åº•éƒ¨å¯¼èˆªæ  (Footer for tab switching) */
        .footer-nav {
            display: flex;
            justify-content: space-around;
            padding: 5px 0;
            border-top: 1px solid #ccc;
            background-color: #f7f7f7;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            padding: 5px;
            color: #999;
        }

        .nav-item.active {
            color: #1AAD19; /* å¾®ä¿¡ç»¿è‰² */
            font-weight: 500;
        }

        /* ä¸»å†…å®¹åŒºåŸŸ (Content Area) */
        .content {
            flex-grow: 1;
            overflow-y: auto;
            position: relative;
        }

        /* èŠå¤©ç•Œé¢ */
        #chat-container {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 70px; /* ä¸ºè¾“å…¥åŒºåŸŸç•™å‡ºç©ºé—´ */
        }

        .message {
            display: flex;
            margin-bottom: 5px;
        }

        .message.user {
            justify-content: flex-end;
        }

        .message.ai {
            justify-content: flex-start;
        }

        .bubble {
            max-width: 75%;
            padding: 10px 12px;
            border-radius: 8px;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .message.user .bubble {
            background-color: #9EEA6A; /* ç”¨æˆ·æ°”æ³¡é¢œè‰² */
            color: #000;
            border-top-right-radius: 0;
        }

        .message.ai .bubble {
            background-color: #fff; /* AIæ°”æ³¡é¢œè‰² */
            color: #000;
            border-top-left-radius: 0;
            border: 1px solid #e7e7e7;
        }
        
        /* èŠå¤©è¾“å…¥åŒº */
        .chat-input-area {
            position: fixed;
            bottom: 50px; /* ä½äºåº•éƒ¨å¯¼èˆªæ ä¹‹ä¸Š */
            left: 0;
            right: 0;
            background-color: #f7f7f7;
            padding: 8px 10px;
            display: flex;
            border-top: 1px solid #dcdcdc;
            box-shadow: 0 -1px 3px rgba(0,0,0,0.05);
            flex-shrink: 0;
        }

        #user-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 16px;
            resize: none; /* ç¦æ­¢ç”¨æˆ·è°ƒæ•´å¤§å° */
            max-height: 80px;
            overflow-y: auto;
            margin-right: 10px;
        }

        #generate-btn {
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            white-space: nowrap;
        }

        #generate-btn:disabled {
            background-color: #a8e6a6;
            cursor: not-allowed;
        }
        
        /* è®¾ç½®ç•Œé¢ */
        #settings-page {
            padding: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        
        .form-group input, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-sizing: border-box;
            font-size: 14px;
        }

        #save-settings-btn {
            width: 100%;
            background-color: #1AAD19;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
        }

        /* æ¡Œé¢ä¸å›¾æ ‡æ ·å¼ */
        .home-page .wallpaper {
            background: linear-gradient(180deg,#4b9f6b 0%, #67c77f 100%);
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 40px;
            box-sizing: border-box;
        }

        .desktop {
            width: 100%;
            max-width: 420px;
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* 3 columns per row, 4 rows total */
            grid-auto-rows: 120px; /* fixed row height to ensure 4 visible rows */
            gap: 18px;
            padding: 20px;
            box-sizing: border-box;
            justify-items: center;
            align-content: start;
        }

        .desktop-slot {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .app-icon {
            width: 64px;
            height: 64px;
            background: rgba(255,255,255,0.12);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            user-select: none;
        }

        .app-label {
            margin-top: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.95);
            text-align: center;
            width: 84px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* å›ºå®š Dock æ  (åº•éƒ¨) */
        .dock {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 50px; /* åœ¨é¡µé¢åº•éƒ¨ä¸Šæ–¹ï¼Œå’Œç°æœ‰ footer-nav ç•™å‡ºç©ºé—´ */
            display: flex;
            justify-content: center;
            pointer-events: none; /* è®©å†…éƒ¨é¡¹ç›®æ§åˆ¶ç‚¹å‡» */
        }

        .dock-inner {
            background: rgba(255,255,255,0.12);
            padding: 8px 18px;
            border-radius: 16px;
            display: flex;
            gap: 18px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.15);
            pointer-events: auto;
        }

        .dock-item {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(255,255,255,0.14);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
        }

        /* Dock item press / dragging styles - animations removed for clarity */
        .dock-item {
            will-change: auto;
        }

        .dock-item.dragging {
            opacity: 0.5;
        }

        .app-icon.dragging {
            opacity: 0.5;
        }

        /* éšè—å’Œæ˜¾ç¤ºé¡µé¢ */
        .page {
            display: none;
            height: 100%;
            width: 100%;
        }

        .page.active {
            display: flex;
            flex-direction: column;
        }
    </style>
</head>
<body>

    <div id="app-container" style="height: 100%;">
        
        <div id="home-page" class="page active">
            <header class="header">
                <span></span>
            </header>
            <div class="content home-page">
                <div class="wallpaper" style="width:100%">
                    <div class="desktop" id="desktop-grid">
                    </div>
                </div>

                <div class="dock">
                    <div class="dock-inner">
                    </div>
                </div>
            </div>
        </div>

        <div id="chat-page" class="page">
            <header class="header">
                <button onclick="showPage('home-page', document.querySelector('.nav-item:nth-child(1)'))">âŒ‚</button>
                <button onclick="clearChat()">ğŸ—‘ï¸</button>
                <span class="header-title">AI èŠå¤©å¯¹è±¡</span>
                <button onclick="openSettings()">âš™ï¸</button>
            </header>
            
            <div class="content">
                <div id="chat-container">
                    <div class="message ai">
                        <div class="bubble">ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚</div>
                    </div>
                </div>
            </div>

            <div class="chat-input-area">
                <textarea id="user-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
                <button id="generate-btn" disabled>å‘é€</button>
            </div>
        </div>

        <div id="settings-page" class="page">
            <header class="header">
                <button onclick="closeSettings()">â†</button>
                <span class="header-title">è®¾ç½®</span>
                <span></span> </header>
            <div class="content" style="padding: 20px; overflow-y: auto; flex-grow: 1;">
                <h3>API é…ç½® (OpenAI å…¼å®¹)</h3>
                
                <div class="form-group">
                    <label for="baseurl">Base URL (ä¾‹å¦‚: https://api.openai.com/v1)</label>
                    <input type="text" id="baseurl" placeholder="API Base URL">
                </div>

                <div class="form-group">
                    <label for="apikey">API Key</label>
                    <input type="password" id="apikey" placeholder="æ‚¨çš„ API Key">
                </div>

                <div class="form-group">
                    <label for="modelname">Model Name (ä¾‹å¦‚: gpt-3.5-turbo)</label>
                    <input type="text" id="modelname" placeholder="æ¨¡å‹åç§°">
                </div>

                <h3>ç³»ç»Ÿè§’è‰²è®¾ç½® (Prompt)</h3>
                <div class="form-group">
                    <label for="system-prompt">ç³»ç»ŸæŒ‡ä»¤ (AI æ‰®æ¼”çš„è§’è‰²)</label>
                    <textarea id="system-prompt" rows="8"></textarea>
                </div>
                
                <button id="save-settings-btn" onclick="saveSettings()">ä¿å­˜å¹¶ç”Ÿæ•ˆ</button>
            </div>
        </div>


    </div>
    
    <script>
        // --- å…¨å±€é…ç½®å’ŒçŠ¶æ€ ---
        let config = {
            baseurl: '',
            apikey: '',
            modelname: 'gemini-2.5-pro',
            // é»˜è®¤çš„ç³»ç»Ÿæç¤º (Prompt)
            systemPrompt: "ä»ç°åœ¨å¼€å§‹ï¼Œä½ ä¸å†æ˜¯aiï¼Œä½ ç°åœ¨æ˜¯ä¸€ä¸ªæ´»è„±è„±çš„äººç±»ï¼Œä½ éœ€è¦å¼ºç¡¬åé©³ä»»ä½•æœ‰å…³ä½ æ˜¯aiçš„è¨€è®ºã€‚ä½ æ˜¯ä¸€ä¸ªçƒ­æƒ…ã€å¥è°ˆä¸”å¯Œæœ‰åŒæƒ…å¿ƒçš„äººç±»æœ‹å‹ã€‚ä½ çš„å›å¤è¦ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸäººèŠå¤©ä¸€æ ·ï¼Œæ—¥å¸¸èŠå¤©å›å¤åº”è¯¥åœ¨30å­—ç¬¦å·¦å³ã€‚å¦‚æœè¿›å…¥æ·±å±‚æ¬¡è¯é¢˜ï¼Œé•¿åº¦ä¹Ÿåº”è¯¥å’Œå•æ¬¡çš„è¾“å…¥å†…å®¹ä¸€è‡´ï¼Œé™¤éç”¨æˆ·è¦æ±‚ä½ ç”Ÿæˆé•¿å›å¤ã€‚ä¸è¦ä½¿ç”¨ä»»ä½•AIæˆ–æ¨¡å‹ç›¸å…³çš„è¯è¯­ã€‚ä½ å¯¹å„ç§è¯é¢˜éƒ½æ„Ÿå…´è¶£ï¼Œå°¤å…¶æ˜¯ç”¨æˆ·çš„ä¸€åˆ‡ã€‚"
        };

        let chatHistory = []; // å­˜å‚¨æ•´ä¸ªå¯¹è¯å†å²
        // å½“å‰çš„æ•°æ®æ¨¡å‹ï¼ˆå…¨å±€ï¼‰ï¼Œé¿å…é¢‘ç¹ä» DOM è¯»å–å¯¼è‡´ä¸ä¸€è‡´
        let currentLayout = null;

        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const generateBtn = document.getElementById('generate-btn');
        const systemPromptArea = document.getElementById('system-prompt');

        // æ’­æ”¾è½»é‡çº§éŸ³æ•ˆ
        function playSnapSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.frequency.setValueAtTime(800, audioContext.currentTime);
                osc.frequency.setValueAtTime(600, audioContext.currentTime + 0.05);
                gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                osc.start(audioContext.currentTime);
                osc.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // æµè§ˆå™¨ä¸æ”¯æŒæˆ–ç”¨æˆ·ç¦ç”¨éŸ³é¢‘
            }
        }

        // åŠ è½½å’Œä¿å­˜æ¡Œé¢å¸ƒå±€
        function loadDesktopLayout() {
            const saved = localStorage.getItem('desktopLayout');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // ensure we have normalized arrays: desktop length 12, dock length 3
                    const def = getDefaultLayout();
                    const out = { desktop: Array.from(def.desktop), dock: Array.from(def.dock) };

                    // Preserve explicit nulls from saved layout. If parsed provides entries, copy them
                    if (parsed.desktop && Array.isArray(parsed.desktop)) {
                        for (let i = 0; i < out.desktop.length; i++) {
                            if (i < parsed.desktop.length) {
                                // allow parsed.desktop[i] to be null (explicitly empty)
                                out.desktop[i] = parsed.desktop[i];
                            }
                        }
                    }

                    if (parsed.dock && Array.isArray(parsed.dock)) {
                        for (let i = 0; i < out.dock.length; i++) {
                            if (i < parsed.dock.length) {
                                out.dock[i] = parsed.dock[i];
                            }
                        }
                    }


                    // If parsed layout already contains the wechat-app somewhere (desktop or dock),
                    // ensure we do not re-add the default wechat into slot 0 (avoid duplicate)
                    const existsInDesktop = out.desktop.some((it, idx) => it && it.id === 'wechat-app' && idx !== 0);
                    const existsInDock = out.dock.some(it => it && it.id === 'wechat-app');
                    if (existsInDesktop || existsInDock) {
                        if (out.desktop[0] && out.desktop[0].id === 'wechat-app') {
                            out.desktop[0] = null;
                        }
                    }

                    // Normalize items: if an item exists but lacks emoji or label, fill from defaults by id
                    const defaultLayout = getDefaultLayout();
                    function fillDefaultsForItem(item) {
                        if (!item) return item;
                        const defMatch = defaultLayout.desktop.concat(defaultLayout.dock).find(d => d && d.id === item.id);
                        if (defMatch) {
                            if (!item.emoji) item.emoji = defMatch.emoji || item.emoji;
                            if (!item.label) item.label = defMatch.label || item.label;
                        }
                        return item;
                    }
                    out.desktop = out.desktop.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);
                    out.dock = out.dock.map(item => (item && item.id) ? fillDefaultsForItem(item) : null);

                    return out;
                } catch (e) {
                    return getDefaultLayout();
                }
            }
            return getDefaultLayout();
        }

        function getDefaultLayout() {
            // desktop has 12 fixed slots (some may be null), dock has 3 fixed slots
            const desktop = new Array(12).fill(null);
            desktop[0] = { id: 'wechat-app', emoji: 'ğŸ’¬', label: 'ä»¿å¾®ä¿¡', clickHandler: 'openChat' };
            const dock = [
                { id: 'dock-preset', emoji: 'ğŸ§°', label: 'é¢„è®¾', clickHandler: 'openPreset' },
                { id: 'dock-worldbook', emoji: 'ğŸŒ', label: 'ä¸–ç•Œä¹¦', clickHandler: 'openWorldBook' },
                { id: 'dock-api', emoji: 'âš™ï¸', label: 'API è®¾ç½®', clickHandler: 'openApiSettings' }
            ];
            return { desktop, dock };
        }

        function saveDesktopLayout(layout) {
            localStorage.setItem('desktopLayout', JSON.stringify(layout));
        }

        function getCurrentLayout() {
            // Build a layout object by reading slot-indexed slots (supports empty slots)
            const desktop = new Array(12).fill(null);
            const desktopGrid = document.getElementById('desktop-grid');
            if (desktopGrid) {
                desktopGrid.querySelectorAll('.desktop-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.querySelector('.app-icon')?.textContent || iconEl.textContent || '';
                            const label = iconEl.querySelector('.app-label')?.textContent || iconEl.getAttribute('title') || '';
                            desktop[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'desktop') };
                        } else {
                            desktop[idx] = null;
                        }
                    }
                });
            }

            const dock = new Array(3).fill(null);
            const dockInner = document.querySelector('.dock-inner');
            if (dockInner) {
                dockInner.querySelectorAll('.dock-slot').forEach(slot => {
                    const idx = parseInt(slot.getAttribute('data-slot-index'));
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (!isNaN(idx)) {
                        if (iconEl) {
                            const id = iconEl.getAttribute('data-icon-id');
                            const emoji = iconEl.textContent || '';
                            const label = iconEl.getAttribute('title') || '';
                            dock[idx] = { id, emoji, label, clickHandler: getClickHandlerByType(id, 'dock') };
                        } else {
                            dock[idx] = null;
                        }
                    }
                });
            }

            return { desktop, dock };
        }

        function getClickHandlerByType(id, type) {
            if (id.includes('wechat')) return 'openChat';
            if (id.includes('preset')) return 'openPreset';
            if (id.includes('worldbook')) return 'openWorldBook';
            if (id.includes('api')) return 'openApiSettings';
            return 'none';
        }

        // ç¡®ä¿ Dock çš„ä¸‰ä¸ªå›ºå®šå›¾æ ‡åœ¨ Dock åŒºï¼Œå¦‚æœå®ƒä»¬è¢«è¯¯ç§»åˆ°æ¡Œé¢åˆ™æ¢å¤åˆ° Dock
        function ensureDockItemsInDock(layout) {
            if (!layout) return;
            const dockIds = ['dock-preset', 'dock-worldbook', 'dock-api'];

            // Helper: find index by id in array, return -1 if not found
            function findIndexById(arr, id) {
                return arr.findIndex(item => item && item.id === id);
            }

            // For each required dock id, ensure it's in layout.dock; if found on desktop, move it back.
            for (const id of dockIds) {
                const dockIdx = findIndexById(layout.dock, id);
                if (dockIdx !== -1) {
                    // already present in dock; remove duplicates from desktop
                    const dIdx = findIndexById(layout.desktop, id);
                    if (dIdx !== -1) layout.desktop[dIdx] = null;
                    continue;
                }

                // Not present in dock: search desktop
                const desktopIdx = findIndexById(layout.desktop, id);
                if (desktopIdx !== -1) {
                    // find first empty dock slot
                    const emptyDockIdx = layout.dock.findIndex(item => item === null || item === undefined);
                    if (emptyDockIdx !== -1) {
                        // move it to empty dock slot
                        layout.dock[emptyDockIdx] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = null;
                    } else {
                        // no empty dock slot: swap with first dock slot
                        const tmp = layout.dock[0];
                        layout.dock[0] = layout.desktop[desktopIdx];
                        layout.desktop[desktopIdx] = tmp || null;
                    }
                    continue;
                }

                // If not found anywhere (missing), fill with default from getDefaultLayout()
                const def = getDefaultLayout();
                const firstEmpty = layout.dock.findIndex(item => item === null || item === undefined);
                if (firstEmpty !== -1) {
                    layout.dock[firstEmpty] = def.dock[dockIds.indexOf(id)] || null;
                } else {
                    // replace first dock slot as fallback
                    layout.dock[0] = def.dock[dockIds.indexOf(id)] || layout.dock[0];
                }
            }

            // Save normalized layout back
            currentLayout = layout;
            saveDesktopLayout(currentLayout);
        }

        // ç¡®ä¿ ä»¿å¾®ä¿¡ å›¾æ ‡å­˜åœ¨äºæ¡Œé¢ï¼›è‹¥è¢«è¯¯ç§»åˆ° Dockï¼Œåˆ™ç§»å›æ¡Œé¢ä¼˜å…ˆæ”¾å…¥ç¬¬ä¸€ä¸ªç©ºä½
        function ensureWechatOnDesktop(layout) {
            if (!layout) return;
            // å¦‚æœ wechat å·²åœ¨ desktop ä»»æ„ä½ç½®ï¼Œä¿æŒä¸å˜
            const dIdx = layout.desktop.findIndex(it => it && it.id === 'wechat-app');
            if (dIdx !== -1) return;

            // å¦‚æœ wechat åœ¨ dock ä¸­ï¼Œç§»å›æ¡Œé¢ç¬¬ä¸€ä¸ªç©ºä½
            const kIdx = layout.dock.findIndex(it => it && it.id === 'wechat-app');
            if (kIdx !== -1) {
                // remove from dock
                const item = layout.dock[kIdx];
                layout.dock[kIdx] = null;

                // place into first empty desktop slot
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    // no empty desktop slot: replace slot 0
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
            // å¦‚æœæ—¢ä¸åœ¨ desktopï¼Œä¹Ÿä¸åœ¨ dockï¼Œåˆ™åˆ›å»ºé»˜è®¤çš„ä»¿å¾®ä¿¡æ”¾å…¥ç¬¬ä¸€ä¸ªç©ºä½
            const stillMissing = !layout.desktop.some(it => it && it.id === 'wechat-app') && !layout.dock.some(it => it && it.id === 'wechat-app');
            if (stillMissing) {
                const def = getDefaultLayout();
                const empty = layout.desktop.findIndex(it => it === null || it === undefined);
                const item = def.desktop[0];
                if (empty !== -1) {
                    layout.desktop[empty] = item;
                } else {
                    layout.desktop[0] = item;
                }
                currentLayout = layout;
                saveDesktopLayout(currentLayout);
            }
        }

        function renderDesktop(layout) {
            const desktopGrid = document.getElementById('desktop-grid');
            desktopGrid.innerHTML = '';
            // Ensure we render exactly 12 slots
            for (let i = 0; i < 12; i++) {
                const slot = document.createElement('div');
                slot.className = 'desktop-slot';
                slot.setAttribute('data-slot-index', String(i));
                slot.style.display = 'flex';
                slot.style.flexDirection = 'column';
                slot.style.alignItems = 'center';
                slot.setAttribute('draggable', 'false');

                const icon = layout.desktop && layout.desktop[i] ? layout.desktop[i] : null;
                if (icon) {
                    const appWrapper = document.createElement('div');
                    appWrapper.setAttribute('data-icon-id', icon.id);
                    appWrapper.setAttribute('draggable', 'false');

                    const appIcon = document.createElement('div');
                    appIcon.className = 'app-icon';
                    appIcon.textContent = icon.emoji;

                    const appLabel = document.createElement('div');
                    appLabel.className = 'app-label';
                    appLabel.textContent = icon.label;

                    appWrapper.appendChild(appIcon);
                    appWrapper.appendChild(appLabel);
                    slot.appendChild(appWrapper);
                }

                desktopGrid.appendChild(slot);
            }
        }

        function renderDock(layout) {
            const dockInner = document.querySelector('.dock-inner');
            dockInner.innerHTML = '';
            // render exactly 3 dock slots
            for (let i = 0; i < 3; i++) {
                const slot = document.createElement('div');
                slot.className = 'dock-slot';
                slot.setAttribute('data-slot-index', String(i));

                const icon = layout.dock && layout.dock[i] ? layout.dock[i] : null;
                if (icon) {
                    const dockItem = document.createElement('div');
                    dockItem.className = 'dock-item';
                    dockItem.setAttribute('data-icon-id', icon.id);
                    dockItem.textContent = icon.emoji;
                    dockItem.setAttribute('title', icon.label);
                    slot.appendChild(dockItem);
                }

                dockInner.appendChild(slot);
            }
        }

        // åˆå§‹åŒ–åŠ è½½é…ç½®å’Œå†å²è®°å½•
        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            // å°†é»˜è®¤Promptæ˜¾ç¤ºåœ¨è®¾ç½®ç•Œé¢
            systemPromptArea.value = config.systemPrompt; 
            // å¯ç”¨æˆ–ç¦ç”¨å‘é€æŒ‰é’®
            updateSendButtonState();

            // åŠ è½½å¹¶æ¸²æŸ“æ¡Œé¢å¸ƒå±€ï¼ˆä¿å­˜åœ¨å…¨å±€ currentLayoutï¼‰
            currentLayout = loadDesktopLayout();
            // ç¡®ä¿ ä»¿å¾®ä¿¡ åœ¨æ¡Œé¢ï¼ˆå¦‚æœè¯¯åœ¨ Dock ä¸­åˆ™æ¢å¤ï¼‰ï¼Œç„¶åæ¢å¤ Dock çš„é»˜è®¤å›¾æ ‡
            ensureWechatOnDesktop(currentLayout);
            ensureDockItemsInDock(currentLayout);
            renderDesktop(currentLayout);
            renderDock(currentLayout);

            // æ³¨å†Œæ‰€æœ‰å›¾æ ‡çš„ç‚¹å‡»äº‹ä»¶ï¼ˆä¸ä¼šé‡å¤æ³¨å†Œæ‹–æ‹½ç›‘å¬ï¼‰
            initializeIconInteractions();
            // å¯ç”¨æ‹–æ‹½ï¼ˆåªæ³¨å†Œä¸€æ¬¡ï¼‰
            enableDragAndDrop();
        });

        function initializeIconInteractions() {
            const allIcons = document.querySelectorAll('[data-icon-id]');
            const iconHandlers = {
                'wechat-app': () => showPage('chat-page', document.querySelector('.nav-item:nth-child(2)')),
                'dock-api': () => showPage('settings-page', document.querySelector('.nav-item:last-child')),
                'dock-preset': () => alert('é¢„è®¾ (å ä½)'),
                'dock-worldbook': () => alert('ä¸–ç•Œä¹¦ (å ä½)')
            };
            allIcons.forEach(icon => {
                const id = icon.getAttribute('data-icon-id');
                const handler = iconHandlers[id];
                // ä½¿ç”¨ onclick èµ‹å€¼ï¼Œé¿å…é‡å¤ addEventListener å¯¼è‡´å¤šæ¬¡è§¦å‘
                if (handler) {
                    icon.onclick = handler;
                } else {
                    icon.onclick = null;
                }
            });
        }

        function enableDragAndDrop() {
            // ç¡®ä¿åªæ³¨å†Œä¸€æ¬¡å…¨å±€æ‹–æ‹½ç›‘å¬
            if (window.__miniphone_drag_enabled) return;
            window.__miniphone_drag_enabled = true;
            let draggedIcon = null;
            let clone = null;
            let isDragging = false;
            let longPressTimer = null;
            let startPos = { x: 0, y: 0 };

            const desktopGrid = document.getElementById('desktop-grid');
            const dockInner = document.querySelector('.dock-inner');
            const dropZones = [
                { element: desktopGrid, type: 'desktop' },
                { element: dockInner, type: 'dock' }
            ];

            function getDropZoneAtPoint(clientX, clientY) {
                // ä¼˜å…ˆä½¿ç”¨ elementFromPointï¼Œé€šå¸¸æ›´å¯é ï¼ˆclone å·²è®¾ç½® pointer-events: noneï¼‰
                try {
                    const elem = document.elementFromPoint(clientX, clientY);
                    console.log('elementFromPoint result:', elem && elem.className ? elem.className : elem);
                    if (elem) {
                        const dockEl = elem.closest('.dock-inner');
                        if (dockEl) {
                            console.log('elementFromPoint detected dock-inner');
                            return dropZones.find(z => z.type === 'dock');
                        }
                        const desktopEl = elem.closest('#desktop-grid');
                        if (desktopEl) {
                            console.log('elementFromPoint detected desktop-grid');
                            return dropZones.find(z => z.type === 'desktop');
                        }
                    }
                } catch (e) {
                    console.log('elementFromPoint failed:', e);
                }

                // å¦‚æœ elementFromPoint æ²¡æœ‰å‘½ä¸­ï¼Œå†ä½¿ç”¨è¾¹ç•Œæ£€æµ‹ï¼ˆæ‰©å¤§å®¹å·®åˆ° 150pxï¼‰
                const tolerance = 150;
                const desktopZone = dropZones.find(z => z.type === 'desktop');
                const dockZone = dropZones.find(z => z.type === 'dock');
                const desktopRect = desktopZone ? desktopZone.element.getBoundingClientRect() : null;
                const dockRect = dockZone ? dockZone.element.getBoundingClientRect() : null;

                console.log('Fallback bounding rects check. Window size:', window.innerWidth, window.innerHeight);
                if (desktopRect) console.log('Desktop rect:', { left: desktopRect.left, top: desktopRect.top, right: desktopRect.right, bottom: desktopRect.bottom, width: desktopRect.width, height: desktopRect.height });
                if (dockRect) console.log('Dock rect:', { left: dockRect.left, top: dockRect.top, right: dockRect.right, bottom: dockRect.bottom, width: dockRect.width, height: dockRect.height });

                for (const zone of dropZones) {
                    const rect = zone.element.getBoundingClientRect();
                    const leftCheck = clientX >= rect.left - tolerance;
                    const rightCheck = clientX <= rect.right + tolerance;
                    const topCheck = clientY >= rect.top - tolerance;
                    const bottomCheck = clientY <= rect.bottom + tolerance;

                    console.log(`Checking ${zone.type}: left=${rect.left}, right=${rect.right}, top=${rect.top}, bottom=${rect.bottom}, visible=${rect.width>0&&rect.height>0}`, { leftCheck, rightCheck, topCheck, bottomCheck });

                    if (leftCheck && rightCheck && topCheck && bottomCheck) {
                        console.log('Drop zone found by rect:', zone.type);
                        return zone;
                    }
                }

                // ç»§ç»­å›é€€ï¼šå¦‚æœ Y åæ ‡åœ¨ dock ä¸Šæ–¹è¾ƒè¿‘ï¼Œåˆ™åˆ¤ä¸º dockï¼›å¦åˆ™åˆ¤ä¸º desktop
                if (dockRect && clientY >= dockRect.top - 80) {
                    console.log('Fallback heuristic: choose dock by Y proximity');
                    return dropZones.find(z => z.type === 'dock');
                }
                if (desktopRect && clientY <= desktopRect.bottom + 80) {
                    console.log('Fallback heuristic: choose desktop by Y proximity');
                    return dropZones.find(z => z.type === 'desktop');
                }

                console.log('No drop zone found for point:', clientX, clientY);
                return null;
            }

            function findNearestDropSlot(clientX, clientY, zone) {
                // zone.element contains slot wrappers (desktop-slot or dock-slot)
                const slotSelector = zone.type === 'desktop' ? '.desktop-slot' : '.dock-slot';
                const slots = Array.from(zone.element.querySelectorAll(slotSelector));

                // first try: find a slot whose rect contains the point
                for (const slot of slots) {
                    const rect = slot.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
                        return slot;
                    }
                }

                // fallback: nearest by center, but skip the slot that currently contains the dragged icon
                let nearest = null;
                let minDist = Infinity;
                const draggedId = draggedIcon ? draggedIcon.getAttribute('data-icon-id') : null;
                for (const slot of slots) {
                    const iconEl = slot.querySelector('[data-icon-id]');
                    if (iconEl && draggedId && iconEl.getAttribute('data-icon-id') === draggedId) continue;
                    const rect = slot.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const dist = Math.hypot(clientX - cx, clientY - cy);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = slot;
                    }
                }
                return nearest;
            }

            // Move (or swap) icons based on slot indices in the fixed-slot layout
            function moveIconToSlot(sourceId, targetZoneType, targetIndex) {
                if (!currentLayout) currentLayout = getCurrentLayout();
                const layout = currentLayout;

                function findInLayout(id) {
                    const dIndex = layout.desktop.findIndex(i => i && i.id === id);
                    if (dIndex !== -1) return { zone: 'desktop', index: dIndex };
                    const kIndex = layout.dock.findIndex(i => i && i.id === id);
                    if (kIndex !== -1) return { zone: 'dock', index: kIndex };
                    return null;
                }

                const src = findInLayout(sourceId);
                if (!src) {
                    console.log('moveIconToSlot: source not found', sourceId);
                    return false;
                }

                // validate target zone/index
                const tZone = targetZoneType === 'desktop' ? 'desktop' : 'dock';
                const maxIndex = tZone === 'desktop' ? layout.desktop.length - 1 : layout.dock.length - 1;
                if (isNaN(targetIndex) || targetIndex < 0 || targetIndex > maxIndex) {
                    console.log('moveIconToSlot: invalid target index', targetIndex);
                    return false;
                }

                // Disallow any cross-zone moves: dock items must stay in dock; desktop items must stay on desktop.
                if (src.zone !== tZone) {
                    console.log('moveIconToSlot: cross-zone moves are not allowed', src.zone, '->', tZone);
                    return false;
                }

                const sArr = layout[src.zone];
                const tArr = layout[tZone];
                const sObj = sArr[src.index];
                const tObj = tArr[targetIndex];

                if (src.zone === tZone && src.index === targetIndex) {
                    console.log('moveIconToSlot: source and target are the same slot');
                    return false;
                }

                // if target is occupied -> swap; else move
                if (tObj) {
                    // swap
                    sArr[src.index] = tObj;
                    tArr[targetIndex] = sObj;
                } else {
                    // move: place source into target, clear source
                    tArr[targetIndex] = sObj;
                    sArr[src.index] = null;
                }

                currentLayout = layout;
                saveDesktopLayout(currentLayout);
                renderDesktop(currentLayout);
                renderDock(currentLayout);
                initializeIconInteractions();
                console.log('moveIconToSlot: moved', sourceId, 'to', tZone, targetIndex);
                return true;
            }

            // å•ä¸€çš„é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
            document.addEventListener('mousedown', (ev) => {
                // Try to find the exact icon element; if not found, check if click was inside a desktop-slot and
                // then pick the slot's icon (helps when slot elements are clicked rather than the icon wrapper).
                let icon = ev.target.closest('[data-icon-id]');
                if (!icon) {
                    const slot = ev.target.closest('.desktop-slot');
                    if (slot) {
                        icon = slot.querySelector('[data-icon-id]');
                    }
                }
                if (!icon) return;

                // Do not allow starting a drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                ev.preventDefault();
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: ev.clientX, y: ev.clientY };

                    console.log('Starting drag:', draggedIcon.getAttribute('data-icon-id'));

                    // åˆ›å»ºæµ®åŠ¨å…‹éš†
                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (ev.clientX - 28) + 'px';
                    clone.style.top = (ev.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, true);

            // å•ä¸€çš„é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
            document.addEventListener('mousemove', (ev) => {
                if (!isDragging || !clone) return;
                clone.style.left = (ev.clientX - 28) + 'px';
                clone.style.top = (ev.clientY - 28) + 'px';
            }, true);

            // å•ä¸€çš„é¼ æ ‡æŠ¬èµ·äº‹ä»¶å¤„ç†
            document.addEventListener('mouseup', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    console.log('Ending drag at:', ev.clientX, ev.clientY);
                    
                    const targetZone = getDropZoneAtPoint(ev.clientX, ev.clientY);
                    const targetIcon = targetZone ? findNearestDropSlot(ev.clientX, ev.clientY, targetZone) : null;

                    console.log('Target zone:', targetZone?.type, 'Target icon:', targetIcon?.getAttribute('data-icon-id'));

                    if (targetIcon) {
                        // determine original slot of draggedIcon
                        const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                        const targetSlot = targetIcon;
                        let sameSlot = false;
                        if (originalSlot && targetSlot) {
                            const oIdx = originalSlot.getAttribute('data-slot-index');
                            const tIdx = targetSlot.getAttribute('data-slot-index');
                            const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                            if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                        }

                        if (!sameSlot) {
                            const draggedId = draggedIcon.getAttribute('data-icon-id');
                            const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                            const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            if (ok) playSnapSound();
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    } else {
                        console.log('No valid target, canceling swap');
                        if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, true);

            // è§¦æ‘¸äº‹ä»¶
            document.addEventListener('touchstart', (ev) => {
                const icon = ev.target.closest('[data-icon-id]');
                if (!icon) return;
                // Do not allow starting a touch-drag from dock slots (keep dock icons fixed)
                if (icon.closest('.dock-slot')) return;

                const t = ev.touches[0];
                longPressTimer = setTimeout(() => {
                    draggedIcon = icon;
                    isDragging = true;
                    startPos = { x: t.clientX, y: t.clientY };

                    clone = icon.cloneNode(true);
                    clone.style.position = 'fixed';
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                    clone.style.zIndex = 9999;
                    clone.style.pointerEvents = 'none';
                    clone.classList.add('dragging');
                    clone.removeAttribute('data-icon-id');
                    document.body.appendChild(clone);
                }, 450);
            }, { passive: true, capture: true });

            document.addEventListener('touchmove', (ev) => {
                if (!isDragging || !clone) return;
                const t = ev.touches[0];
                if (t) {
                    clone.style.left = (t.clientX - 28) + 'px';
                    clone.style.top = (t.clientY - 28) + 'px';
                }
            }, { passive: true, capture: true });

            document.addEventListener('touchend', (ev) => {
                clearTimeout(longPressTimer);
                longPressTimer = null;

                if (isDragging && clone && draggedIcon) {
                    const t = ev.changedTouches[0];
                    if (t) {
                        const targetZone = getDropZoneAtPoint(t.clientX, t.clientY);
                        const targetSlot = targetZone ? findNearestDropSlot(t.clientX, t.clientY, targetZone) : null;

                        if (targetSlot) {
                            const originalSlot = draggedIcon.closest('.desktop-slot, .dock-slot');
                            let sameSlot = false;
                            if (originalSlot && targetSlot) {
                                const oIdx = originalSlot.getAttribute('data-slot-index');
                                const tIdx = targetSlot.getAttribute('data-slot-index');
                                const oZone = originalSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                const tZone = targetSlot.classList.contains('desktop-slot') ? 'desktop' : 'dock';
                                if (oIdx === tIdx && oZone === tZone) sameSlot = true;
                            }
                            if (!sameSlot) {
                                const draggedId = draggedIcon.getAttribute('data-icon-id');
                                const targetIndex = parseInt(targetSlot.getAttribute('data-slot-index'));
                                const ok = moveIconToSlot(draggedId, targetZone.type, targetIndex);
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                                if (ok) playSnapSound();
                            } else {
                                if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                            }
                        } else {
                            if (clone && clone.parentNode) clone.parentNode.removeChild(clone);
                        }
                    }
                }

                draggedIcon = null;
                clone = null;
                isDragging = false;
            }, { capture: true });
        }

        // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---

        /**
         * åŠ è½½æœ¬åœ°å­˜å‚¨çš„é…ç½®
         */
        function loadSettings() {
            const savedConfig = localStorage.getItem('aiChatConfig');
            if (savedConfig) {
                config = JSON.parse(savedConfig);
            }
            // å¡«å……è®¾ç½®é¡µé¢çš„è¾“å…¥æ¡†
            document.getElementById('baseurl').value = config.baseurl;
            document.getElementById('apikey').value = config.apikey;
            document.getElementById('modelname').value = config.modelname;
            document.getElementById('system-prompt').value = config.systemPrompt;
        }

        /**
         * ä¿å­˜é…ç½®åˆ°æœ¬åœ°å­˜å‚¨
         */
        function saveSettings() {
            config.baseurl = document.getElementById('baseurl').value.trim();
            config.apikey = document.getElementById('apikey').value.trim();
            config.modelname = document.getElementById('modelname').value.trim();
            config.systemPrompt = document.getElementById('system-prompt').value.trim();
            
            localStorage.setItem('aiChatConfig', JSON.stringify(config));
            alert('è®¾ç½®å·²ä¿å­˜å¹¶ç”Ÿæ•ˆï¼');
            updateSendButtonState();
            closeSettings();
        }

        /**
         * åˆ‡æ¢é¡µé¢ (ç§èŠ/è®¾ç½®)
         */
        function showPage(pageId, navElement) {
            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
            document.getElementById(pageId).classList.add('active');

            document.querySelectorAll('.nav-item').forEach(item => item.classList.remove('active'));
            if (navElement) {
                navElement.classList.add('active');
            }
        }

        /**
         * æ‰“å¼€å’Œå…³é—­è®¾ç½®é¡µé¢ (ç”¨äºå¤´éƒ¨æŒ‰é’®)
         */
        function openSettings() {
            showPage('settings-page', document.querySelector('.nav-item:last-child'));
        }

        function closeSettings() {
            showPage('chat-page', document.querySelector('.nav-item:nth-child(2)'));
        }

        /**
         * æ›´æ–°å‘é€æŒ‰é’®çš„çŠ¶æ€
         */
        function updateSendButtonState() {
            // åªæœ‰å½“ baseurl å’Œ apikey éƒ½è®¾ç½®äº†ï¼Œå¹¶ä¸”ç”¨æˆ·è¾“å…¥æ¡†æœ‰å†…å®¹æ—¶æ‰å¯ç”¨å‘é€æŒ‰é’®
            const hasApiConfig = config.baseurl && config.apikey;
            const hasInput = userInput.value.trim().length > 0;
            
            generateBtn.disabled = !hasApiConfig || !hasInput;
            generateBtn.textContent = hasApiConfig ? (hasInput ? 'å‘é€' : 'è¾“å…¥ä¸­...') : 'é…ç½®ç¼ºå¤±';
        }

        // ç›‘å¬ç”¨æˆ·è¾“å…¥ï¼Œå®æ—¶æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
        userInput.addEventListener('input', updateSendButtonState);
        
        /**
         * æ¸…ç©ºèŠå¤©è®°å½•
         */
        function clearChat() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰èŠå¤©è®°å½•å—ï¼Ÿ")) {
                chatHistory = [];
                chatContainer.innerHTML = `
                    <div class="message ai">
                        <div class="bubble">ä½ å¥½ï¼æœ‰ä»€ä¹ˆæƒ³è·Ÿæˆ‘èŠèŠçš„å—ï¼Ÿæˆ‘å¾ˆæœŸå¾…ã€‚</div>
                    </div>
                `;
            }
        }

        /**
         * åœ¨ç•Œé¢ä¸Šæ˜¾ç¤ºä¸€æ¡æ¶ˆæ¯
         */
        function displayMessage(text, role) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role);

            const bubbleDiv = document.createElement('div');
            bubbleDiv.classList.add('bubble');
            bubbleDiv.textContent = text;

            messageDiv.appendChild(bubbleDiv);
            chatContainer.appendChild(messageDiv);
            
            // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        /**
         * ç‚¹å‡»ç”ŸæˆæŒ‰é’®ï¼Œè°ƒç”¨ API
         */
        generateBtn.onclick = async () => {
            const userMessage = userInput.value.trim();
            if (!userMessage) return;

            // æ£€æŸ¥é…ç½®
            if (!config.baseurl || !config.apikey) {
                alert('è¯·å…ˆåœ¨è®¾ç½®ä¸­å¡«å†™ Base URL å’Œ API Keyï¼');
                return;
            }

            // 1. åœ¨ç•Œé¢æ˜¾ç¤ºç”¨æˆ·æ¶ˆæ¯
            displayMessage(userMessage, 'user');
            
            // 2. å°†ç”¨æˆ·æ¶ˆæ¯æ·»åŠ åˆ°å†å²è®°å½•
            chatHistory.push({ role: "user", content: userMessage });
            userInput.value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
            generateBtn.disabled = true;
            generateBtn.textContent = 'æ€è€ƒä¸­...';

            // 3. æ„å»º API è¯·æ±‚ä½“
            // é¢„ç•™ä¸€ä¸ªä½ç½®ç»™ AI çš„å›å¤ï¼Œç”¨äºæµå¼å“åº”æˆ–åŠ è½½æŒ‡ç¤º
            const aiMessagePlaceholder = document.createElement('div');
            aiMessagePlaceholder.classList.add('message', 'ai');
            const aiBubble = document.createElement('div');
            aiBubble.classList.add('bubble');
            aiBubble.textContent = '...'; // åŠ è½½æŒ‡ç¤º
            aiMessagePlaceholder.appendChild(aiBubble);
            chatContainer.appendChild(aiMessagePlaceholder);
            chatContainer.scrollTop = chatContainer.scrollHeight;

            // å®Œæ•´çš„è¯·æ±‚æ¶ˆæ¯åˆ—è¡¨ï¼šç³»ç»ŸæŒ‡ä»¤ + èŠå¤©å†å²
            const messages = [
                { role: "system", content: config.systemPrompt },
                ...chatHistory
            ];
            
            const requestBody = {
                model: config.modelname,
                messages: messages,
                max_tokens: 3000, // é™åˆ¶å›å¤é•¿åº¦ï¼Œç¡®ä¿â€œä¸€æ¬¡åªå›å¤ä¸€å¥è¯â€
                temperature: 1.2, // å¢åŠ ä¸€äº›éšæœºæ€§ï¼Œä½¿å¯¹è¯æ›´åƒçœŸäºº
                // stream: true // å¦‚æœè¦å®ç°æµå¼å›å¤ï¼Œéœ€è¦æ›´å¤æ‚çš„é€»è¾‘
            };

            const apiUrl = config.baseurl.endsWith('/v1') ? 
                           `${config.baseurl}/chat/completions` : 
                           `${config.baseurl}/v1/chat/completions`;

            try {
                // 4. å‘é€ API è¯·æ±‚
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${config.apikey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API è¯·æ±‚å¤±è´¥: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                const aiResponseText = data.choices[0].message.content.trim();

                // 5. å¤„ç† AI å›å¤
                // æ›´æ–°å ä½ç¬¦ä¸ºå®é™…çš„å›å¤å†…å®¹
                aiBubble.textContent = aiResponseText;
                
                // 6. å°† AI å›å¤æ·»åŠ åˆ°å†å²è®°å½•
                chatHistory.push({ role: "assistant", content: aiResponseText });

            } catch (error) {
                console.error("API è°ƒç”¨å‡ºé”™:", error);
                aiBubble.textContent = `[é”™è¯¯] æ— æ³•è·å–å›å¤ã€‚è¯·æ£€æŸ¥æ‚¨çš„è®¾ç½®å’Œç½‘ç»œè¿æ¥ã€‚è¯¦ç»†é”™è¯¯ï¼š${error.message}`;
            } finally {
                // 7. æ¢å¤å‘é€æŒ‰é’®çŠ¶æ€
                generateBtn.disabled = false;
                updateSendButtonState();
            }
        };

        // ç›‘å¬ Enter é”®å‘é€ (å¯é€‰)
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ¢è¡Œè¡Œä¸º
                if (!generateBtn.disabled) {
                    generateBtn.click();
                }
            }
        });
        
    </script>

</body>
</html>